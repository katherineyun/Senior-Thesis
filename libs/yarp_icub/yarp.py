# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.8
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.





from sys import version_info
if version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_yarp', [dirname(__file__)])
        except ImportError:
            import _yarp
            return _yarp
        if fp is not None:
            try:
                _mod = imp.load_module('_yarp', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _yarp = swig_import_helper()
    del swig_import_helper
else:
    import _yarp
del version_info
try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.


def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        if _newclass:
            object.__setattr__(self, name, value)
        else:
            self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr_nondynamic(self, class_type, name, static=1):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    if (not static):
        return object.__getattr__(self, name)
    else:
        raise AttributeError(name)

def _swig_getattr(self, class_type, name):
    return _swig_getattr_nondynamic(self, class_type, name, 0)


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object:
        pass
    _newclass = 0


try:
    import weakref
    weakref_proxy = weakref.proxy
except Exception:
    weakref_proxy = lambda x: x


class SwigPyIterator(_object):
    """Proxy of C++ swig::SwigPyIterator class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SwigPyIterator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SwigPyIterator, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_SwigPyIterator
    __del__ = lambda self: None

    def value(self):
        """value(SwigPyIterator self) -> PyObject *"""
        return _yarp.SwigPyIterator_value(self)


    def incr(self, n=1):
        """
        incr(SwigPyIterator self, size_t n=1) -> SwigPyIterator
        incr(SwigPyIterator self) -> SwigPyIterator
        """
        return _yarp.SwigPyIterator_incr(self, n)


    def decr(self, n=1):
        """
        decr(SwigPyIterator self, size_t n=1) -> SwigPyIterator
        decr(SwigPyIterator self) -> SwigPyIterator
        """
        return _yarp.SwigPyIterator_decr(self, n)


    def distance(self, x):
        """distance(SwigPyIterator self, SwigPyIterator x) -> ptrdiff_t"""
        return _yarp.SwigPyIterator_distance(self, x)


    def equal(self, x):
        """equal(SwigPyIterator self, SwigPyIterator x) -> bool"""
        return _yarp.SwigPyIterator_equal(self, x)


    def copy(self):
        """copy(SwigPyIterator self) -> SwigPyIterator"""
        return _yarp.SwigPyIterator_copy(self)


    def next(self):
        """next(SwigPyIterator self) -> PyObject *"""
        return _yarp.SwigPyIterator_next(self)


    def __next__(self):
        """__next__(SwigPyIterator self) -> PyObject *"""
        return _yarp.SwigPyIterator___next__(self)


    def previous(self):
        """previous(SwigPyIterator self) -> PyObject *"""
        return _yarp.SwigPyIterator_previous(self)


    def advance(self, n):
        """advance(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator"""
        return _yarp.SwigPyIterator_advance(self, n)


    def __eq__(self, x):
        """__eq__(SwigPyIterator self, SwigPyIterator x) -> bool"""
        return _yarp.SwigPyIterator___eq__(self, x)


    def __ne__(self, x):
        """__ne__(SwigPyIterator self, SwigPyIterator x) -> bool"""
        return _yarp.SwigPyIterator___ne__(self, x)


    def __iadd__(self, n):
        """__iadd__(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator"""
        return _yarp.SwigPyIterator___iadd__(self, n)


    def __isub__(self, n):
        """__isub__(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator"""
        return _yarp.SwigPyIterator___isub__(self, n)


    def __add__(self, n):
        """__add__(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator"""
        return _yarp.SwigPyIterator___add__(self, n)


    def __sub__(self, *args):
        """
        __sub__(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator
        __sub__(SwigPyIterator self, SwigPyIterator x) -> ptrdiff_t
        """
        return _yarp.SwigPyIterator___sub__(self, *args)

    def __iter__(self):
        return self
SwigPyIterator_swigregister = _yarp.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)


_yarp.YARP_CONSTSTRING_IS_STD_STRING_swigconstant(_yarp)
YARP_CONSTSTRING_IS_STD_STRING = _yarp.YARP_CONSTSTRING_IS_STD_STRING
class PortReport(_object):
    """Proxy of C++ yarp::os::PortReport class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PortReport, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PortReport, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_PortReport
    __del__ = lambda self: None

    def report(self, info):
        """report(PortReport self, yarp::os::PortInfo const & info)"""
        return _yarp.PortReport_report(self, info)

PortReport_swigregister = _yarp.PortReport_swigregister
PortReport_swigregister(PortReport)

class Contact(_object):
    """Proxy of C++ yarp::os::Contact class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Contact, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Contact, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(yarp::os::Contact self, yarp::os::ConstString const & name, yarp::os::ConstString const & carrier, yarp::os::ConstString const & hostname, int port=-1) -> Contact
        __init__(yarp::os::Contact self, yarp::os::ConstString const & name, yarp::os::ConstString const & carrier, yarp::os::ConstString const & hostname) -> Contact
        __init__(yarp::os::Contact self, yarp::os::ConstString const & name, yarp::os::ConstString const & carrier) -> Contact
        __init__(yarp::os::Contact self, yarp::os::ConstString const & name) -> Contact
        __init__(yarp::os::Contact self) -> Contact
        __init__(yarp::os::Contact self, yarp::os::ConstString const & hostname, int port) -> Contact
        __init__(yarp::os::Contact self, yarp::os::ConstString const & carrier, yarp::os::ConstString const & hostname, int port) -> Contact
        __init__(yarp::os::Contact self, Contact rhs) -> Contact
        __init__(yarp::os::Contact self, Contact rhs) -> Contact
        """
        this = _yarp.new_Contact(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _yarp.delete_Contact
    __del__ = lambda self: None

    def fromConfig(config):
        """fromConfig(Searchable config) -> Contact"""
        return _yarp.Contact_fromConfig(config)

    if _newclass:
        fromConfig = staticmethod(fromConfig)
    __swig_getmethods__["fromConfig"] = lambda x: fromConfig

    def fromString(txt):
        """fromString(yarp::os::ConstString const & txt) -> Contact"""
        return _yarp.Contact_fromString(txt)

    if _newclass:
        fromString = staticmethod(fromString)
    __swig_getmethods__["fromString"] = lambda x: fromString

    def getName(self):
        """getName(Contact self) -> yarp::os::ConstString"""
        return _yarp.Contact_getName(self)


    def setName(self, name):
        """setName(Contact self, yarp::os::ConstString const & name)"""
        return _yarp.Contact_setName(self, name)


    def getRegName(self):
        """getRegName(Contact self) -> yarp::os::ConstString"""
        return _yarp.Contact_getRegName(self)


    def getHost(self):
        """getHost(Contact self) -> yarp::os::ConstString"""
        return _yarp.Contact_getHost(self)


    def setHost(self, hostname):
        """setHost(Contact self, yarp::os::ConstString const & hostname)"""
        return _yarp.Contact_setHost(self, hostname)


    def getPort(self):
        """getPort(Contact self) -> int"""
        return _yarp.Contact_getPort(self)


    def setPort(self, port):
        """setPort(Contact self, int port)"""
        return _yarp.Contact_setPort(self, port)


    def getCarrier(self):
        """getCarrier(Contact self) -> yarp::os::ConstString"""
        return _yarp.Contact_getCarrier(self)


    def setCarrier(self, carrier):
        """setCarrier(Contact self, yarp::os::ConstString const & carrier)"""
        return _yarp.Contact_setCarrier(self, carrier)


    def getNested(self):
        """getNested(Contact self) -> NestedContact const &"""
        return _yarp.Contact_getNested(self)


    def setNestedContact(self, nestedContact):
        """setNestedContact(Contact self, yarp::os::NestedContact const & nestedContact)"""
        return _yarp.Contact_setNestedContact(self, nestedContact)


    def hasTimeout(self):
        """hasTimeout(Contact self) -> bool"""
        return _yarp.Contact_hasTimeout(self)


    def getTimeout(self):
        """getTimeout(Contact self) -> float"""
        return _yarp.Contact_getTimeout(self)


    def setTimeout(self, timeout):
        """setTimeout(Contact self, float timeout)"""
        return _yarp.Contact_setTimeout(self, timeout)


    def setSocket(self, carrier, hostname, port):
        """setSocket(Contact self, yarp::os::ConstString const & carrier, yarp::os::ConstString const & hostname, int port)"""
        return _yarp.Contact_setSocket(self, carrier, hostname, port)


    def isValid(self):
        """isValid(Contact self) -> bool"""
        return _yarp.Contact_isValid(self)


    def toString_c(self):
        """toString_c(Contact self) -> yarp::os::ConstString"""
        return _yarp.Contact_toString_c(self)


    def toURI(self, includeCarrier=True):
        """
        toURI(Contact self, bool includeCarrier=True) -> yarp::os::ConstString
        toURI(Contact self) -> yarp::os::ConstString
        """
        return _yarp.Contact_toURI(self, includeCarrier)


    def convertHostToIp(name):
        """convertHostToIp(char const * name) -> yarp::os::ConstString"""
        return _yarp.Contact_convertHostToIp(name)

    if _newclass:
        convertHostToIp = staticmethod(convertHostToIp)
    __swig_getmethods__["convertHostToIp"] = lambda x: convertHostToIp

    def addName(self, name):
        """addName(Contact self, yarp::os::ConstString const & name) -> Contact"""
        return _yarp.Contact_addName(self, name)


    def addCarrier(self, carrier):
        """addCarrier(Contact self, yarp::os::ConstString const & carrier) -> Contact"""
        return _yarp.Contact_addCarrier(self, carrier)


    def addHost(self, hostname):
        """addHost(Contact self, yarp::os::ConstString const & hostname) -> Contact"""
        return _yarp.Contact_addHost(self, hostname)


    def addPort(self, port):
        """addPort(Contact self, int port) -> Contact"""
        return _yarp.Contact_addPort(self, port)


    def addNested(self, nestedContact):
        """addNested(Contact self, NestedContact const & nestedContact) -> Contact"""
        return _yarp.Contact_addNested(self, nestedContact)


    def addSocket(self, carrier, hostname, port):
        """addSocket(Contact self, yarp::os::ConstString const & carrier, yarp::os::ConstString const & hostname, int port) -> Contact"""
        return _yarp.Contact_addSocket(self, carrier, hostname, port)


    def empty():
        """empty() -> Contact"""
        return _yarp.Contact_empty()

    if _newclass:
        empty = staticmethod(empty)
    __swig_getmethods__["empty"] = lambda x: empty

    def invalid():
        """invalid() -> Contact"""
        return _yarp.Contact_invalid()

    if _newclass:
        invalid = staticmethod(invalid)
    __swig_getmethods__["invalid"] = lambda x: invalid

    def byName(name):
        """byName(yarp::os::ConstString const & name) -> Contact"""
        return _yarp.Contact_byName(name)

    if _newclass:
        byName = staticmethod(byName)
    __swig_getmethods__["byName"] = lambda x: byName

    def byCarrier(carrier):
        """byCarrier(yarp::os::ConstString const & carrier) -> Contact"""
        return _yarp.Contact_byCarrier(carrier)

    if _newclass:
        byCarrier = staticmethod(byCarrier)
    __swig_getmethods__["byCarrier"] = lambda x: byCarrier

    def bySocket(carrier, hostname, port):
        """bySocket(yarp::os::ConstString const & carrier, yarp::os::ConstString const & hostname, int port) -> Contact"""
        return _yarp.Contact_bySocket(carrier, hostname, port)

    if _newclass:
        bySocket = staticmethod(bySocket)
    __swig_getmethods__["bySocket"] = lambda x: bySocket

    def byConfig(config):
        """byConfig(Searchable config) -> Contact"""
        return _yarp.Contact_byConfig(config)

    if _newclass:
        byConfig = staticmethod(byConfig)
    __swig_getmethods__["byConfig"] = lambda x: byConfig
Contact_swigregister = _yarp.Contact_swigregister
Contact_swigregister(Contact)

def Contact_fromConfig(config):
    """Contact_fromConfig(Searchable config) -> Contact"""
    return _yarp.Contact_fromConfig(config)

def Contact_fromString(txt):
    """Contact_fromString(yarp::os::ConstString const & txt) -> Contact"""
    return _yarp.Contact_fromString(txt)

def Contact_convertHostToIp(name):
    """Contact_convertHostToIp(char const * name) -> yarp::os::ConstString"""
    return _yarp.Contact_convertHostToIp(name)

def Contact_empty():
    """Contact_empty() -> Contact"""
    return _yarp.Contact_empty()

def Contact_invalid():
    """Contact_invalid() -> Contact"""
    return _yarp.Contact_invalid()

def Contact_byName(name):
    """Contact_byName(yarp::os::ConstString const & name) -> Contact"""
    return _yarp.Contact_byName(name)

def Contact_byCarrier(carrier):
    """Contact_byCarrier(yarp::os::ConstString const & carrier) -> Contact"""
    return _yarp.Contact_byCarrier(carrier)

def Contact_bySocket(carrier, hostname, port):
    """Contact_bySocket(yarp::os::ConstString const & carrier, yarp::os::ConstString const & hostname, int port) -> Contact"""
    return _yarp.Contact_bySocket(carrier, hostname, port)

def Contact_byConfig(config):
    """Contact_byConfig(Searchable config) -> Contact"""
    return _yarp.Contact_byConfig(config)

class ConnectionReader(_object):
    """Proxy of C++ yarp::os::ConnectionReader class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ConnectionReader, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ConnectionReader, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_ConnectionReader
    __del__ = lambda self: None

    def expectBlock(self, data, len):
        """expectBlock(ConnectionReader self, char const * data, size_t len) -> bool"""
        return _yarp.ConnectionReader_expectBlock(self, data, len)


    def expectText(self, *args):
        """
        expectText(ConnectionReader self, int terminatingChar) -> yarp::os::ConstString
        expectText(ConnectionReader self) -> yarp::os::ConstString
        """
        return _yarp.ConnectionReader_expectText(self, *args)


    def expectInt(self):
        """expectInt(ConnectionReader self) -> int"""
        return _yarp.ConnectionReader_expectInt(self)


    def expectInt64(self):
        """expectInt64(ConnectionReader self) -> YARP_INT64"""
        return _yarp.ConnectionReader_expectInt64(self)


    def expectDouble(self):
        """expectDouble(ConnectionReader self) -> double"""
        return _yarp.ConnectionReader_expectDouble(self)


    def isTextMode(self):
        """isTextMode(ConnectionReader self) -> bool"""
        return _yarp.ConnectionReader_isTextMode(self)


    def isBareMode(self):
        """isBareMode(ConnectionReader self) -> bool"""
        return _yarp.ConnectionReader_isBareMode(self)


    def convertTextMode(self):
        """convertTextMode(ConnectionReader self) -> bool"""
        return _yarp.ConnectionReader_convertTextMode(self)


    def getSize(self):
        """getSize(ConnectionReader self) -> size_t"""
        return _yarp.ConnectionReader_getSize(self)


    def getWriter(self):
        """getWriter(ConnectionReader self) -> ConnectionWriter"""
        return _yarp.ConnectionReader_getWriter(self)


    def readEnvelope(self):
        """readEnvelope(ConnectionReader self) -> Bytes"""
        return _yarp.ConnectionReader_readEnvelope(self)


    def getReference(self):
        """getReference(ConnectionReader self) -> Portable"""
        return _yarp.ConnectionReader_getReference(self)


    def getRemoteContact(self):
        """getRemoteContact(ConnectionReader self) -> Contact"""
        return _yarp.ConnectionReader_getRemoteContact(self)


    def getLocalContact(self):
        """getLocalContact(ConnectionReader self) -> Contact"""
        return _yarp.ConnectionReader_getLocalContact(self)


    def isValid(self):
        """isValid(ConnectionReader self) -> bool"""
        return _yarp.ConnectionReader_isValid(self)


    def isActive(self):
        """isActive(ConnectionReader self) -> bool"""
        return _yarp.ConnectionReader_isActive(self)


    def isError(self):
        """isError(ConnectionReader self) -> bool"""
        return _yarp.ConnectionReader_isError(self)


    def requestDrop(self):
        """requestDrop(ConnectionReader self)"""
        return _yarp.ConnectionReader_requestDrop(self)


    def getConnectionModifiers(self):
        """getConnectionModifiers(ConnectionReader self) -> Searchable"""
        return _yarp.ConnectionReader_getConnectionModifiers(self)


    def pushInt(self, x):
        """pushInt(ConnectionReader self, int x) -> bool"""
        return _yarp.ConnectionReader_pushInt(self, x)


    def setSize(self, len):
        """setSize(ConnectionReader self, size_t len) -> bool"""
        return _yarp.ConnectionReader_setSize(self, len)


    def createConnectionReader(arg1):
        """createConnectionReader(yarp::os::InputStream & arg1) -> ConnectionReader"""
        return _yarp.ConnectionReader_createConnectionReader(arg1)

    if _newclass:
        createConnectionReader = staticmethod(createConnectionReader)
    __swig_getmethods__["createConnectionReader"] = lambda x: createConnectionReader

    def readFromStream(portable, arg2):
        """readFromStream(PortReader portable, yarp::os::InputStream & arg2) -> bool"""
        return _yarp.ConnectionReader_readFromStream(portable, arg2)

    if _newclass:
        readFromStream = staticmethod(readFromStream)
    __swig_getmethods__["readFromStream"] = lambda x: readFromStream

    def setParentConnectionReader(self, parentConnectionReader):
        """setParentConnectionReader(ConnectionReader self, ConnectionReader parentConnectionReader)"""
        return _yarp.ConnectionReader_setParentConnectionReader(self, parentConnectionReader)

ConnectionReader_swigregister = _yarp.ConnectionReader_swigregister
ConnectionReader_swigregister(ConnectionReader)

def ConnectionReader_createConnectionReader(arg2):
    """ConnectionReader_createConnectionReader(yarp::os::InputStream & arg2) -> ConnectionReader"""
    return _yarp.ConnectionReader_createConnectionReader(arg2)

def ConnectionReader_readFromStream(portable, arg3):
    """ConnectionReader_readFromStream(PortReader portable, yarp::os::InputStream & arg3) -> bool"""
    return _yarp.ConnectionReader_readFromStream(portable, arg3)

class ConnectionWriter(_object):
    """Proxy of C++ yarp::os::ConnectionWriter class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ConnectionWriter, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ConnectionWriter, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_ConnectionWriter
    __del__ = lambda self: None

    def appendBlock(self, data, len):
        """appendBlock(ConnectionWriter self, char const * data, size_t len)"""
        return _yarp.ConnectionWriter_appendBlock(self, data, len)


    def appendInt(self, data):
        """appendInt(ConnectionWriter self, int data)"""
        return _yarp.ConnectionWriter_appendInt(self, data)


    def appendInt64(self, data):
        """appendInt64(ConnectionWriter self, YARP_INT64 const & data)"""
        return _yarp.ConnectionWriter_appendInt64(self, data)


    def appendDouble(self, data):
        """appendDouble(ConnectionWriter self, double data)"""
        return _yarp.ConnectionWriter_appendDouble(self, data)


    def appendString(self, *args):
        """
        appendString(ConnectionWriter self, char const * str, int terminate)
        appendString(ConnectionWriter self, char const * str)
        """
        return _yarp.ConnectionWriter_appendString(self, *args)


    def appendExternalBlock(self, data, len):
        """appendExternalBlock(ConnectionWriter self, char const * data, size_t len)"""
        return _yarp.ConnectionWriter_appendExternalBlock(self, data, len)


    def isTextMode(self):
        """isTextMode(ConnectionWriter self) -> bool"""
        return _yarp.ConnectionWriter_isTextMode(self)


    def isBareMode(self):
        """isBareMode(ConnectionWriter self) -> bool"""
        return _yarp.ConnectionWriter_isBareMode(self)


    def declareSizes(self, argc, argv):
        """declareSizes(ConnectionWriter self, int argc, int * argv)"""
        return _yarp.ConnectionWriter_declareSizes(self, argc, argv)


    def setReplyHandler(self, reader):
        """setReplyHandler(ConnectionWriter self, PortReader reader)"""
        return _yarp.ConnectionWriter_setReplyHandler(self, reader)


    def setReference(self, obj):
        """setReference(ConnectionWriter self, Portable obj)"""
        return _yarp.ConnectionWriter_setReference(self, obj)


    def convertTextMode(self):
        """convertTextMode(ConnectionWriter self) -> bool"""
        return _yarp.ConnectionWriter_convertTextMode(self)


    def isValid(self):
        """isValid(ConnectionWriter self) -> bool"""
        return _yarp.ConnectionWriter_isValid(self)


    def isActive(self):
        """isActive(ConnectionWriter self) -> bool"""
        return _yarp.ConnectionWriter_isActive(self)


    def isError(self):
        """isError(ConnectionWriter self) -> bool"""
        return _yarp.ConnectionWriter_isError(self)


    def requestDrop(self):
        """requestDrop(ConnectionWriter self)"""
        return _yarp.ConnectionWriter_requestDrop(self)


    def isNull(self):
        """isNull(ConnectionWriter self) -> bool"""
        return _yarp.ConnectionWriter_isNull(self)


    def getBuffer(self):
        """getBuffer(ConnectionWriter self) -> yarp::os::SizedWriter *"""
        return _yarp.ConnectionWriter_getBuffer(self)


    def appendRawString(self, str):
        """appendRawString(ConnectionWriter self, yarp::os::ConstString const & str)"""
        return _yarp.ConnectionWriter_appendRawString(self, str)


    def createBufferedConnectionWriter():
        """createBufferedConnectionWriter() -> ConnectionWriter"""
        return _yarp.ConnectionWriter_createBufferedConnectionWriter()

    if _newclass:
        createBufferedConnectionWriter = staticmethod(createBufferedConnectionWriter)
    __swig_getmethods__["createBufferedConnectionWriter"] = lambda x: createBufferedConnectionWriter

    def writeToStream(portable, os):
        """writeToStream(PortWriter portable, yarp::os::OutputStream & os) -> bool"""
        return _yarp.ConnectionWriter_writeToStream(portable, os)

    if _newclass:
        writeToStream = staticmethod(writeToStream)
    __swig_getmethods__["writeToStream"] = lambda x: writeToStream
ConnectionWriter_swigregister = _yarp.ConnectionWriter_swigregister
ConnectionWriter_swigregister(ConnectionWriter)

def ConnectionWriter_createBufferedConnectionWriter():
    """ConnectionWriter_createBufferedConnectionWriter() -> ConnectionWriter"""
    return _yarp.ConnectionWriter_createBufferedConnectionWriter()

def ConnectionWriter_writeToStream(portable, os):
    """ConnectionWriter_writeToStream(PortWriter portable, yarp::os::OutputStream & os) -> bool"""
    return _yarp.ConnectionWriter_writeToStream(portable, os)

class PortReader(_object):
    """Proxy of C++ yarp::os::PortReader class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PortReader, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PortReader, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_PortReader
    __del__ = lambda self: None

    def read(self, reader):
        """read(PortReader self, ConnectionReader reader) -> bool"""
        return _yarp.PortReader_read(self, reader)


    def getReadType(self):
        """getReadType(PortReader self) -> Type"""
        return _yarp.PortReader_getReadType(self)


    def __init__(self):
        """__init__(yarp::os::PortReader self) -> PortReader"""
        if self.__class__ == PortReader:
            _self = None
        else:
            _self = self
        this = _yarp.new_PortReader(_self, )
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    def __disown__(self):
        self.this.disown()
        _yarp.disown_PortReader(self)
        return weakref_proxy(self)
PortReader_swigregister = _yarp.PortReader_swigregister
PortReader_swigregister(PortReader)

class PortWriter(_object):
    """Proxy of C++ yarp::os::PortWriter class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PortWriter, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PortWriter, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_PortWriter
    __del__ = lambda self: None

    def write(self, writer):
        """write(PortWriter self, ConnectionWriter writer) -> bool"""
        return _yarp.PortWriter_write(self, writer)


    def onCompletion(self):
        """onCompletion(PortWriter self)"""
        return _yarp.PortWriter_onCompletion(self)


    def onCommencement(self):
        """onCommencement(PortWriter self)"""
        return _yarp.PortWriter_onCommencement(self)


    def getWriteType(self):
        """getWriteType(PortWriter self) -> Type"""
        return _yarp.PortWriter_getWriteType(self)

PortWriter_swigregister = _yarp.PortWriter_swigregister
PortWriter_swigregister(PortWriter)

class Portable(PortReader, PortWriter):
    """Proxy of C++ yarp::os::Portable class."""

    __swig_setmethods__ = {}
    for _s in [PortReader, PortWriter]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Portable, name, value)
    __swig_getmethods__ = {}
    for _s in [PortReader, PortWriter]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Portable, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def read(self, reader):
        """read(Portable self, ConnectionReader reader) -> bool"""
        return _yarp.Portable_read(self, reader)


    def write(self, writer):
        """write(Portable self, ConnectionWriter writer) -> bool"""
        return _yarp.Portable_write(self, writer)


    def getType(self):
        """getType(Portable self) -> Type"""
        return _yarp.Portable_getType(self)


    def copyPortable(writer, reader):
        """copyPortable(PortWriter writer, PortReader reader) -> bool"""
        return _yarp.Portable_copyPortable(writer, reader)

    if _newclass:
        copyPortable = staticmethod(copyPortable)
    __swig_getmethods__["copyPortable"] = lambda x: copyPortable
    __swig_destroy__ = _yarp.delete_Portable
    __del__ = lambda self: None
Portable_swigregister = _yarp.Portable_swigregister
Portable_swigregister(Portable)

def Portable_copyPortable(writer, reader):
    """Portable_copyPortable(PortWriter writer, PortReader reader) -> bool"""
    return _yarp.Portable_copyPortable(writer, reader)

class SearchReport(_object):
    """Proxy of C++ yarp::os::SearchReport class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SearchReport, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SearchReport, name)
    __repr__ = _swig_repr
    __swig_setmethods__["key"] = _yarp.SearchReport_key_set
    __swig_getmethods__["key"] = _yarp.SearchReport_key_get
    if _newclass:
        key = _swig_property(_yarp.SearchReport_key_get, _yarp.SearchReport_key_set)
    __swig_setmethods__["value"] = _yarp.SearchReport_value_set
    __swig_getmethods__["value"] = _yarp.SearchReport_value_get
    if _newclass:
        value = _swig_property(_yarp.SearchReport_value_get, _yarp.SearchReport_value_set)
    __swig_setmethods__["isFound"] = _yarp.SearchReport_isFound_set
    __swig_getmethods__["isFound"] = _yarp.SearchReport_isFound_get
    if _newclass:
        isFound = _swig_property(_yarp.SearchReport_isFound_get, _yarp.SearchReport_isFound_set)
    __swig_setmethods__["isGroup"] = _yarp.SearchReport_isGroup_set
    __swig_getmethods__["isGroup"] = _yarp.SearchReport_isGroup_get
    if _newclass:
        isGroup = _swig_property(_yarp.SearchReport_isGroup_get, _yarp.SearchReport_isGroup_set)
    __swig_setmethods__["isComment"] = _yarp.SearchReport_isComment_set
    __swig_getmethods__["isComment"] = _yarp.SearchReport_isComment_get
    if _newclass:
        isComment = _swig_property(_yarp.SearchReport_isComment_get, _yarp.SearchReport_isComment_set)
    __swig_setmethods__["isDefault"] = _yarp.SearchReport_isDefault_set
    __swig_getmethods__["isDefault"] = _yarp.SearchReport_isDefault_get
    if _newclass:
        isDefault = _swig_property(_yarp.SearchReport_isDefault_get, _yarp.SearchReport_isDefault_set)

    def __init__(self):
        """__init__(yarp::os::SearchReport self) -> SearchReport"""
        this = _yarp.new_SearchReport()
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _yarp.delete_SearchReport
    __del__ = lambda self: None
SearchReport_swigregister = _yarp.SearchReport_swigregister
SearchReport_swigregister(SearchReport)

class SearchMonitor(_object):
    """Proxy of C++ yarp::os::SearchMonitor class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SearchMonitor, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SearchMonitor, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_SearchMonitor
    __del__ = lambda self: None

    def report(self, report, context):
        """report(SearchMonitor self, SearchReport report, char const * context)"""
        return _yarp.SearchMonitor_report(self, report, context)

SearchMonitor_swigregister = _yarp.SearchMonitor_swigregister
SearchMonitor_swigregister(SearchMonitor)

class Searchable(_object):
    """Proxy of C++ yarp::os::Searchable class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Searchable, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Searchable, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_Searchable
    __del__ = lambda self: None

    def find(self, key):
        """find(Searchable self, yarp::os::ConstString const & key) -> Value"""
        return _yarp.Searchable_find(self, key)


    def findGroup(self, *args):
        """
        findGroup(Searchable self, yarp::os::ConstString const & key) -> Bottle
        findGroup(Searchable self, yarp::os::ConstString const & key, yarp::os::ConstString const & comment) -> Bottle
        """
        return _yarp.Searchable_findGroup(self, *args)


    def check(self, *args):
        """
        check(Searchable self, yarp::os::ConstString const & key) -> bool
        check(Searchable self, yarp::os::ConstString const & key, yarp::os::ConstString const & comment) -> bool
        check(Searchable self, yarp::os::ConstString const & key, Value fallback, yarp::os::ConstString const & comment) -> Value
        check(Searchable self, yarp::os::ConstString const & key, Value fallback) -> Value
        """
        return _yarp.Searchable_check(self, *args)


    def isNull(self):
        """isNull(Searchable self) -> bool"""
        return _yarp.Searchable_isNull(self)


    def toString_c(self):
        """toString_c(Searchable self) -> yarp::os::ConstString"""
        return _yarp.Searchable_toString_c(self)


    def setMonitor(self, *args):
        """
        setMonitor(Searchable self, SearchMonitor monitor, char const * context)
        setMonitor(Searchable self, SearchMonitor monitor)
        """
        return _yarp.Searchable_setMonitor(self, *args)


    def getMonitor(self):
        """getMonitor(Searchable self) -> SearchMonitor"""
        return _yarp.Searchable_getMonitor(self)


    def getMonitorContext(self):
        """getMonitorContext(Searchable self) -> yarp::os::ConstString"""
        return _yarp.Searchable_getMonitorContext(self)


    def reportToMonitor(self, report):
        """reportToMonitor(Searchable self, SearchReport report)"""
        return _yarp.Searchable_reportToMonitor(self, report)

Searchable_swigregister = _yarp.Searchable_swigregister
Searchable_swigregister(Searchable)

class Value(Portable, Searchable):
    """Proxy of C++ yarp::os::Value class."""

    __swig_setmethods__ = {}
    for _s in [Portable, Searchable]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Value, name, value)
    __swig_getmethods__ = {}
    for _s in [Portable, Searchable]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Value, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(yarp::os::Value self) -> Value
        __init__(yarp::os::Value self, int x, bool isVocab=False) -> Value
        __init__(yarp::os::Value self, int x) -> Value
        __init__(yarp::os::Value self, double x) -> Value
        __init__(yarp::os::Value self, yarp::os::ConstString const & str, bool isVocab=False) -> Value
        __init__(yarp::os::Value self, yarp::os::ConstString const & str) -> Value
        __init__(yarp::os::Value self, void * data, int length) -> Value
        __init__(yarp::os::Value self, Value alt) -> Value
        """
        this = _yarp.new_Value(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _yarp.delete_Value
    __del__ = lambda self: None

    def isBool(self):
        """isBool(Value self) -> bool"""
        return _yarp.Value_isBool(self)


    def isInt(self):
        """isInt(Value self) -> bool"""
        return _yarp.Value_isInt(self)


    def isInt64(self):
        """isInt64(Value self) -> bool"""
        return _yarp.Value_isInt64(self)


    def isString(self):
        """isString(Value self) -> bool"""
        return _yarp.Value_isString(self)


    def isDouble(self):
        """isDouble(Value self) -> bool"""
        return _yarp.Value_isDouble(self)


    def isList(self):
        """isList(Value self) -> bool"""
        return _yarp.Value_isList(self)


    def isDict(self):
        """isDict(Value self) -> bool"""
        return _yarp.Value_isDict(self)


    def isVocab(self):
        """isVocab(Value self) -> bool"""
        return _yarp.Value_isVocab(self)


    def isBlob(self):
        """isBlob(Value self) -> bool"""
        return _yarp.Value_isBlob(self)


    def asBool(self):
        """asBool(Value self) -> bool"""
        return _yarp.Value_asBool(self)


    def asInt(self):
        """asInt(Value self) -> int"""
        return _yarp.Value_asInt(self)


    def asInt64(self):
        """asInt64(Value self) -> YARP_INT64"""
        return _yarp.Value_asInt64(self)


    def asVocab(self):
        """asVocab(Value self) -> int"""
        return _yarp.Value_asVocab(self)


    def asDouble(self):
        """asDouble(Value self) -> double"""
        return _yarp.Value_asDouble(self)


    def asString(self):
        """asString(Value self) -> yarp::os::ConstString"""
        return _yarp.Value_asString(self)


    def asList(self):
        """asList(Value self) -> Bottle"""
        return _yarp.Value_asList(self)


    def asDict(self):
        """asDict(Value self) -> Property"""
        return _yarp.Value_asDict(self)


    def asSearchable(self):
        """asSearchable(Value self) -> Searchable"""
        return _yarp.Value_asSearchable(self)


    def asBlob(self):
        """asBlob(Value self) -> char const *"""
        return _yarp.Value_asBlob(self)


    def asBlobLength(self):
        """asBlobLength(Value self) -> size_t"""
        return _yarp.Value_asBlobLength(self)


    def read(self, connection):
        """read(Value self, ConnectionReader connection) -> bool"""
        return _yarp.Value_read(self, connection)


    def write(self, connection):
        """write(Value self, ConnectionWriter connection) -> bool"""
        return _yarp.Value_write(self, connection)


    def check(self, *args):
        """
        check(Value self, yarp::os::ConstString const & key) -> bool
        check(Value self, yarp::os::ConstString const & key, yarp::os::ConstString const & comment) -> bool
        check(Value self, yarp::os::ConstString const & key, Value fallback, yarp::os::ConstString const & comment) -> Value
        check(Value self, yarp::os::ConstString const & key, Value fallback) -> Value
        check(Value self, yarp::os::ConstString const & key) -> bool
        """
        return _yarp.Value_check(self, *args)


    def find(self, key):
        """find(Value self, yarp::os::ConstString const & key) -> Value"""
        return _yarp.Value_find(self, key)


    def findGroup(self, *args):
        """
        findGroup(Value self, yarp::os::ConstString const & key) -> Bottle
        findGroup(Value self, yarp::os::ConstString const & key, yarp::os::ConstString const & comment) -> Bottle
        findGroup(Value self, yarp::os::ConstString const & key) -> Bottle
        """
        return _yarp.Value_findGroup(self, *args)


    def isEqual(self, *args):
        """
        isEqual(Value self, Value alt) -> bool
        isEqual(Value self, char const * alt) -> bool
        """
        return _yarp.Value_isEqual(self, *args)


    def notEqual(self, *args):
        """
        notEqual(Value self, Value alt) -> bool
        notEqual(Value self, char const * alt) -> bool
        """
        return _yarp.Value_notEqual(self, *args)


    def fromString(self, str):
        """fromString(Value self, char const * str)"""
        return _yarp.Value_fromString(self, str)


    def toString_c(self):
        """toString_c(Value self) -> yarp::os::ConstString"""
        return _yarp.Value_toString_c(self)


    def create(self):
        """create(Value self) -> Value"""
        return _yarp.Value_create(self)


    def clone(self):
        """clone(Value self) -> Value"""
        return _yarp.Value_clone(self)


    def getCode(self):
        """getCode(Value self) -> int"""
        return _yarp.Value_getCode(self)


    def isNull(self):
        """isNull(Value self) -> bool"""
        return _yarp.Value_isNull(self)


    def isLeaf(self):
        """isLeaf(Value self) -> bool"""
        return _yarp.Value_isLeaf(self)


    def makeInt(x):
        """makeInt(int x) -> Value"""
        return _yarp.Value_makeInt(x)

    if _newclass:
        makeInt = staticmethod(makeInt)
    __swig_getmethods__["makeInt"] = lambda x: makeInt

    def makeDouble(x):
        """makeDouble(double x) -> Value"""
        return _yarp.Value_makeDouble(x)

    if _newclass:
        makeDouble = staticmethod(makeDouble)
    __swig_getmethods__["makeDouble"] = lambda x: makeDouble

    def makeString(str):
        """makeString(yarp::os::ConstString const & str) -> Value"""
        return _yarp.Value_makeString(str)

    if _newclass:
        makeString = staticmethod(makeString)
    __swig_getmethods__["makeString"] = lambda x: makeString

    def makeVocab(*args):
        """
        makeVocab(int v) -> Value
        makeVocab(yarp::os::ConstString const & str) -> Value
        """
        return _yarp.Value_makeVocab(*args)

    if _newclass:
        makeVocab = staticmethod(makeVocab)
    __swig_getmethods__["makeVocab"] = lambda x: makeVocab

    def makeBlob(data, length):
        """makeBlob(void * data, int length) -> Value"""
        return _yarp.Value_makeBlob(data, length)

    if _newclass:
        makeBlob = staticmethod(makeBlob)
    __swig_getmethods__["makeBlob"] = lambda x: makeBlob

    def makeList(*args):
        """
        makeList() -> Value
        makeList(char const * txt) -> Value
        """
        return _yarp.Value_makeList(*args)

    if _newclass:
        makeList = staticmethod(makeList)
    __swig_getmethods__["makeList"] = lambda x: makeList

    def makeValue(txt):
        """makeValue(yarp::os::ConstString const & txt) -> Value"""
        return _yarp.Value_makeValue(txt)

    if _newclass:
        makeValue = staticmethod(makeValue)
    __swig_getmethods__["makeValue"] = lambda x: makeValue

    def getNullValue():
        """getNullValue() -> Value"""
        return _yarp.Value_getNullValue()

    if _newclass:
        getNullValue = staticmethod(getNullValue)
    __swig_getmethods__["getNullValue"] = lambda x: getNullValue

    def toString(self):
        """toString(Value self) -> std::string"""
        return _yarp.Value_toString(self)

Value_swigregister = _yarp.Value_swigregister
Value_swigregister(Value)

def Value_makeInt(x):
    """Value_makeInt(int x) -> Value"""
    return _yarp.Value_makeInt(x)

def Value_makeDouble(x):
    """Value_makeDouble(double x) -> Value"""
    return _yarp.Value_makeDouble(x)

def Value_makeString(str):
    """Value_makeString(yarp::os::ConstString const & str) -> Value"""
    return _yarp.Value_makeString(str)

def Value_makeVocab(*args):
    """
    makeVocab(int v) -> Value
    Value_makeVocab(yarp::os::ConstString const & str) -> Value
    """
    return _yarp.Value_makeVocab(*args)

def Value_makeBlob(data, length):
    """Value_makeBlob(void * data, int length) -> Value"""
    return _yarp.Value_makeBlob(data, length)

def Value_makeList(*args):
    """
    makeList() -> Value
    Value_makeList(char const * txt) -> Value
    """
    return _yarp.Value_makeList(*args)

def Value_makeValue(txt):
    """Value_makeValue(yarp::os::ConstString const & txt) -> Value"""
    return _yarp.Value_makeValue(txt)

def Value_getNullValue():
    """Value_getNullValue() -> Value"""
    return _yarp.Value_getNullValue()

class Vocab(_object):
    """Proxy of C++ yarp::os::Vocab class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Vocab, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Vocab, name)
    __repr__ = _swig_repr

    def encode(str):
        """encode(yarp::os::ConstString const & str) -> yarp::os::NetInt32"""
        return _yarp.Vocab_encode(str)

    if _newclass:
        encode = staticmethod(encode)
    __swig_getmethods__["encode"] = lambda x: encode

    def decode(code):
        """decode(yarp::os::NetInt32 code) -> yarp::os::ConstString"""
        return _yarp.Vocab_decode(code)

    if _newclass:
        decode = staticmethod(decode)
    __swig_getmethods__["decode"] = lambda x: decode

    def __init__(self):
        """__init__(yarp::os::Vocab self) -> Vocab"""
        this = _yarp.new_Vocab()
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _yarp.delete_Vocab
    __del__ = lambda self: None
Vocab_swigregister = _yarp.Vocab_swigregister
Vocab_swigregister(Vocab)

def Vocab_encode(str):
    """Vocab_encode(yarp::os::ConstString const & str) -> yarp::os::NetInt32"""
    return _yarp.Vocab_encode(str)

def Vocab_decode(code):
    """Vocab_decode(yarp::os::NetInt32 code) -> yarp::os::ConstString"""
    return _yarp.Vocab_decode(code)

class Contactable(_object):
    """Proxy of C++ yarp::os::Contactable class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Contactable, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Contactable, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_Contactable
    __del__ = lambda self: None

    def open(self, *args):
        """
        open(Contactable self) -> bool
        open(Contactable self, yarp::os::ConstString const & name) -> bool
        open(Contactable self, Contact contact, bool registerName=True) -> bool
        open(Contactable self, Contact contact) -> bool
        """
        return _yarp.Contactable_open(self, *args)


    def addOutput(self, *args):
        """
        addOutput(Contactable self, yarp::os::ConstString const & name) -> bool
        addOutput(Contactable self, yarp::os::ConstString const & name, yarp::os::ConstString const & carrier) -> bool
        addOutput(Contactable self, Contact contact) -> bool
        """
        return _yarp.Contactable_addOutput(self, *args)


    def close(self):
        """close(Contactable self)"""
        return _yarp.Contactable_close(self)


    def interrupt(self):
        """interrupt(Contactable self)"""
        return _yarp.Contactable_interrupt(self)


    def resume(self):
        """resume(Contactable self)"""
        return _yarp.Contactable_resume(self)


    def where(self):
        """where(Contactable self) -> Contact"""
        return _yarp.Contactable_where(self)


    def getName(self):
        """getName(Contactable self) -> yarp::os::ConstString"""
        return _yarp.Contactable_getName(self)


    def getEnvelope(self, envelope):
        """getEnvelope(Contactable self, PortReader envelope) -> bool"""
        return _yarp.Contactable_getEnvelope(self, envelope)


    def getInputCount(self):
        """getInputCount(Contactable self) -> int"""
        return _yarp.Contactable_getInputCount(self)


    def getOutputCount(self):
        """getOutputCount(Contactable self) -> int"""
        return _yarp.Contactable_getOutputCount(self)


    def getReport(self, reporter):
        """getReport(Contactable self, PortReport reporter)"""
        return _yarp.Contactable_getReport(self, reporter)


    def setReporter(self, reporter):
        """setReporter(Contactable self, PortReport reporter)"""
        return _yarp.Contactable_setReporter(self, reporter)


    def resetReporter(self):
        """resetReporter(Contactable self)"""
        return _yarp.Contactable_resetReporter(self)


    def isWriting(self):
        """isWriting(Contactable self) -> bool"""
        return _yarp.Contactable_isWriting(self)


    def setReader(self, reader):
        """setReader(Contactable self, PortReader reader)"""
        return _yarp.Contactable_setReader(self, reader)


    def setAdminReader(self, reader):
        """setAdminReader(Contactable self, PortReader reader)"""
        return _yarp.Contactable_setAdminReader(self, reader)


    def setInputMode(self, expectInput):
        """setInputMode(Contactable self, bool expectInput)"""
        return _yarp.Contactable_setInputMode(self, expectInput)


    def setOutputMode(self, expectOutput):
        """setOutputMode(Contactable self, bool expectOutput)"""
        return _yarp.Contactable_setOutputMode(self, expectOutput)


    def setRpcMode(self, expectRpc):
        """setRpcMode(Contactable self, bool expectRpc)"""
        return _yarp.Contactable_setRpcMode(self, expectRpc)


    def getType(self):
        """getType(Contactable self) -> Type"""
        return _yarp.Contactable_getType(self)


    def promiseType(self, typ):
        """promiseType(Contactable self, Type const & typ)"""
        return _yarp.Contactable_promiseType(self, typ)


    def acquireProperties(self, readOnly):
        """acquireProperties(Contactable self, bool readOnly) -> Property"""
        return _yarp.Contactable_acquireProperties(self, readOnly)


    def releaseProperties(self, prop):
        """releaseProperties(Contactable self, Property prop)"""
        return _yarp.Contactable_releaseProperties(self, prop)


    def includeNodeInName(self, flag):
        """includeNodeInName(Contactable self, bool flag)"""
        return _yarp.Contactable_includeNodeInName(self, flag)


    def setReadOnly(self):
        """setReadOnly(Contactable self)"""
        return _yarp.Contactable_setReadOnly(self)


    def setWriteOnly(self):
        """setWriteOnly(Contactable self)"""
        return _yarp.Contactable_setWriteOnly(self)


    def setRpcServer(self):
        """setRpcServer(Contactable self)"""
        return _yarp.Contactable_setRpcServer(self)


    def setRpcClient(self):
        """setRpcClient(Contactable self)"""
        return _yarp.Contactable_setRpcClient(self)


    def setCallbackLock(self, mutex=None):
        """
        setCallbackLock(Contactable self, yarp::os::Mutex * mutex=None) -> bool
        setCallbackLock(Contactable self) -> bool
        """
        return _yarp.Contactable_setCallbackLock(self, mutex)


    def removeCallbackLock(self):
        """removeCallbackLock(Contactable self) -> bool"""
        return _yarp.Contactable_removeCallbackLock(self)


    def lockCallback(self):
        """lockCallback(Contactable self) -> bool"""
        return _yarp.Contactable_lockCallback(self)


    def tryLockCallback(self):
        """tryLockCallback(Contactable self) -> bool"""
        return _yarp.Contactable_tryLockCallback(self)


    def unlockCallback(self):
        """unlockCallback(Contactable self)"""
        return _yarp.Contactable_unlockCallback(self)


    def setEnvelope(self, *args):
        """
        setEnvelope(Contactable self, PortWriter envelope) -> bool
        setEnvelope(Contactable self, Portable data) -> bool
        """
        return _yarp.Contactable_setEnvelope(self, *args)

Contactable_swigregister = _yarp.Contactable_swigregister
Contactable_swigregister(Contactable)

class UnbufferedContactable(Contactable):
    """Proxy of C++ yarp::os::UnbufferedContactable class."""

    __swig_setmethods__ = {}
    for _s in [Contactable]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, UnbufferedContactable, name, value)
    __swig_getmethods__ = {}
    for _s in [Contactable]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, UnbufferedContactable, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def write(self, *args):
        """
        write(UnbufferedContactable self, PortWriter writer, PortWriter callback=None) -> bool
        write(UnbufferedContactable self, PortWriter writer) -> bool
        write(UnbufferedContactable self, PortWriter writer, PortReader reader, PortWriter callback=None) -> bool
        write(UnbufferedContactable self, PortWriter writer, PortReader reader) -> bool
        """
        return _yarp.UnbufferedContactable_write(self, *args)


    def read(self, reader, willReply=False):
        """
        read(UnbufferedContactable self, PortReader reader, bool willReply=False) -> bool
        read(UnbufferedContactable self, PortReader reader) -> bool
        """
        return _yarp.UnbufferedContactable_read(self, reader, willReply)


    def reply(self, writer):
        """reply(UnbufferedContactable self, PortWriter writer) -> bool"""
        return _yarp.UnbufferedContactable_reply(self, writer)


    def replyAndDrop(self, writer):
        """replyAndDrop(UnbufferedContactable self, PortWriter writer) -> bool"""
        return _yarp.UnbufferedContactable_replyAndDrop(self, writer)

    __swig_destroy__ = _yarp.delete_UnbufferedContactable
    __del__ = lambda self: None
UnbufferedContactable_swigregister = _yarp.UnbufferedContactable_swigregister
UnbufferedContactable_swigregister(UnbufferedContactable)

class Port(UnbufferedContactable):
    """Proxy of C++ yarp::os::Port class."""

    __swig_setmethods__ = {}
    for _s in [UnbufferedContactable]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Port, name, value)
    __swig_getmethods__ = {}
    for _s in [UnbufferedContactable]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Port, name)
    __repr__ = _swig_repr

    def __init__(self):
        """__init__(yarp::os::Port self) -> Port"""
        this = _yarp.new_Port()
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _yarp.delete_Port
    __del__ = lambda self: None

    def sharedOpen(self, port):
        """sharedOpen(Port self, Port port) -> bool"""
        return _yarp.Port_sharedOpen(self, port)


    def openFake(self, name):
        """openFake(Port self, yarp::os::ConstString const & name) -> bool"""
        return _yarp.Port_openFake(self, name)


    def addOutput(self, *args):
        """
        addOutput(Port self, yarp::os::ConstString const & name) -> bool
        addOutput(Port self, yarp::os::ConstString const & name, yarp::os::ConstString const & carrier) -> bool
        addOutput(Port self, Contact contact) -> bool
        """
        return _yarp.Port_addOutput(self, *args)


    def close(self):
        """close(Port self)"""
        return _yarp.Port_close(self)


    def interrupt(self):
        """interrupt(Port self)"""
        return _yarp.Port_interrupt(self)


    def resume(self):
        """resume(Port self)"""
        return _yarp.Port_resume(self)


    def where(self):
        """where(Port self) -> Contact"""
        return _yarp.Port_where(self)


    def read(self, reader, willReply=False):
        """
        read(Port self, PortReader reader, bool willReply=False) -> bool
        read(Port self, PortReader reader) -> bool
        """
        return _yarp.Port_read(self, reader, willReply)


    def replyAndDrop(self, writer):
        """replyAndDrop(Port self, PortWriter writer) -> bool"""
        return _yarp.Port_replyAndDrop(self, writer)


    def setReader(self, reader):
        """setReader(Port self, PortReader reader)"""
        return _yarp.Port_setReader(self, reader)


    def setAdminReader(self, reader):
        """setAdminReader(Port self, PortReader reader)"""
        return _yarp.Port_setAdminReader(self, reader)


    def setReaderCreator(self, creator):
        """setReaderCreator(Port self, PortReaderCreator & creator)"""
        return _yarp.Port_setReaderCreator(self, creator)


    def enableBackgroundWrite(self, backgroundFlag):
        """enableBackgroundWrite(Port self, bool backgroundFlag)"""
        return _yarp.Port_enableBackgroundWrite(self, backgroundFlag)


    def isWriting(self):
        """isWriting(Port self) -> bool"""
        return _yarp.Port_isWriting(self)


    def setEnvelope(self, envelope):
        """setEnvelope(Port self, PortWriter envelope) -> bool"""
        return _yarp.Port_setEnvelope(self, envelope)


    def getEnvelope(self, envelope):
        """getEnvelope(Port self, PortReader envelope) -> bool"""
        return _yarp.Port_getEnvelope(self, envelope)


    def getInputCount(self):
        """getInputCount(Port self) -> int"""
        return _yarp.Port_getInputCount(self)


    def getOutputCount(self):
        """getOutputCount(Port self) -> int"""
        return _yarp.Port_getOutputCount(self)


    def getReport(self, reporter):
        """getReport(Port self, PortReport reporter)"""
        return _yarp.Port_getReport(self, reporter)


    def setReporter(self, reporter):
        """setReporter(Port self, PortReport reporter)"""
        return _yarp.Port_setReporter(self, reporter)


    def resetReporter(self):
        """resetReporter(Port self)"""
        return _yarp.Port_resetReporter(self)


    def setAdminMode(self, adminMode=True):
        """
        setAdminMode(Port self, bool adminMode=True)
        setAdminMode(Port self)
        """
        return _yarp.Port_setAdminMode(self, adminMode)


    def setInputMode(self, expectInput):
        """setInputMode(Port self, bool expectInput)"""
        return _yarp.Port_setInputMode(self, expectInput)


    def setOutputMode(self, expectOutput):
        """setOutputMode(Port self, bool expectOutput)"""
        return _yarp.Port_setOutputMode(self, expectOutput)


    def setRpcMode(self, expectRpc):
        """setRpcMode(Port self, bool expectRpc)"""
        return _yarp.Port_setRpcMode(self, expectRpc)


    def setTimeout(self, timeout):
        """setTimeout(Port self, float timeout) -> bool"""
        return _yarp.Port_setTimeout(self, timeout)


    def setVerbosity(self, level):
        """setVerbosity(Port self, int level)"""
        return _yarp.Port_setVerbosity(self, level)


    def getVerbosity(self):
        """getVerbosity(Port self) -> int"""
        return _yarp.Port_getVerbosity(self)


    def getType(self):
        """getType(Port self) -> Type"""
        return _yarp.Port_getType(self)


    def promiseType(self, typ):
        """promiseType(Port self, Type const & typ)"""
        return _yarp.Port_promiseType(self, typ)


    def acquireProperties(self, readOnly):
        """acquireProperties(Port self, bool readOnly) -> Property"""
        return _yarp.Port_acquireProperties(self, readOnly)


    def releaseProperties(self, prop):
        """releaseProperties(Port self, Property prop)"""
        return _yarp.Port_releaseProperties(self, prop)


    def includeNodeInName(self, flag):
        """includeNodeInName(Port self, bool flag)"""
        return _yarp.Port_includeNodeInName(self, flag)


    def isOpen(self):
        """isOpen(Port self) -> bool"""
        return _yarp.Port_isOpen(self)


    def setCallbackLock(self, mutex=None):
        """
        setCallbackLock(Port self, yarp::os::Mutex * mutex=None) -> bool
        setCallbackLock(Port self) -> bool
        """
        return _yarp.Port_setCallbackLock(self, mutex)


    def removeCallbackLock(self):
        """removeCallbackLock(Port self) -> bool"""
        return _yarp.Port_removeCallbackLock(self)


    def lockCallback(self):
        """lockCallback(Port self) -> bool"""
        return _yarp.Port_lockCallback(self)


    def tryLockCallback(self):
        """tryLockCallback(Port self) -> bool"""
        return _yarp.Port_tryLockCallback(self)


    def unlockCallback(self):
        """unlockCallback(Port self)"""
        return _yarp.Port_unlockCallback(self)


    def write(self, *args):
        """
        write(Port self, PortWriter writer, PortWriter callback=None) -> bool
        write(Port self, PortWriter writer) -> bool
        write(Port self, PortWriter writer, PortReader reader, PortWriter callback=None) -> bool
        write(Port self, PortWriter writer, PortReader reader) -> bool
        write(Port self, Bottle data) -> bool
        write(Port self, Property data) -> bool
        write(Port self, ImageRgb data) -> bool
        write(Port self, ImageFloat data) -> bool
        write(Port self, Bottle data1, Bottle data2) -> bool
        write(Port self, Bottle data1, ImageFloat data2) -> bool
        """
        return _yarp.Port_write(self, *args)


    def reply(self, *args):
        """
        reply(Port self, PortWriter writer) -> bool
        reply(Port self, Bottle data) -> bool
        """
        return _yarp.Port_reply(self, *args)

Port_swigregister = _yarp.Port_swigregister
Port_swigregister(Port)

class AbstractContactable(UnbufferedContactable):
    """Proxy of C++ yarp::os::AbstractContactable class."""

    __swig_setmethods__ = {}
    for _s in [UnbufferedContactable]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, AbstractContactable, name, value)
    __swig_getmethods__ = {}
    for _s in [UnbufferedContactable]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, AbstractContactable, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def asPort(self, *args):
        """
        asPort(AbstractContactable self) -> Port
        asPort(AbstractContactable self) -> Port
        """
        return _yarp.AbstractContactable_asPort(self, *args)


    def open(self, *args):
        """
        open(AbstractContactable self) -> bool
        open(AbstractContactable self, yarp::os::ConstString const & name) -> bool
        open(AbstractContactable self, Contact contact, bool registerName=True) -> bool
        open(AbstractContactable self, Contact contact) -> bool
        open(AbstractContactable self, yarp::os::ConstString const & name) -> bool
        open(AbstractContactable self, Contact contact, bool registerName=True) -> bool
        open(AbstractContactable self, Contact contact) -> bool
        """
        return _yarp.AbstractContactable_open(self, *args)


    def addOutput(self, *args):
        """
        addOutput(AbstractContactable self, yarp::os::ConstString const & name) -> bool
        addOutput(AbstractContactable self, yarp::os::ConstString const & name, yarp::os::ConstString const & carrier) -> bool
        addOutput(AbstractContactable self, Contact contact) -> bool
        """
        return _yarp.AbstractContactable_addOutput(self, *args)


    def close(self):
        """close(AbstractContactable self)"""
        return _yarp.AbstractContactable_close(self)


    def interrupt(self):
        """interrupt(AbstractContactable self)"""
        return _yarp.AbstractContactable_interrupt(self)


    def resume(self):
        """resume(AbstractContactable self)"""
        return _yarp.AbstractContactable_resume(self)


    def where(self):
        """where(AbstractContactable self) -> Contact"""
        return _yarp.AbstractContactable_where(self)


    def getName(self):
        """getName(AbstractContactable self) -> yarp::os::ConstString"""
        return _yarp.AbstractContactable_getName(self)


    def setEnvelope(self, envelope):
        """setEnvelope(AbstractContactable self, PortWriter envelope) -> bool"""
        return _yarp.AbstractContactable_setEnvelope(self, envelope)


    def getEnvelope(self, envelope):
        """getEnvelope(AbstractContactable self, PortReader envelope) -> bool"""
        return _yarp.AbstractContactable_getEnvelope(self, envelope)


    def getInputCount(self):
        """getInputCount(AbstractContactable self) -> int"""
        return _yarp.AbstractContactable_getInputCount(self)


    def getOutputCount(self):
        """getOutputCount(AbstractContactable self) -> int"""
        return _yarp.AbstractContactable_getOutputCount(self)


    def getReport(self, reporter):
        """getReport(AbstractContactable self, PortReport reporter)"""
        return _yarp.AbstractContactable_getReport(self, reporter)


    def setReporter(self, reporter):
        """setReporter(AbstractContactable self, PortReport reporter)"""
        return _yarp.AbstractContactable_setReporter(self, reporter)


    def resetReporter(self):
        """resetReporter(AbstractContactable self)"""
        return _yarp.AbstractContactable_resetReporter(self)


    def isWriting(self):
        """isWriting(AbstractContactable self) -> bool"""
        return _yarp.AbstractContactable_isWriting(self)


    def setReader(self, reader):
        """setReader(AbstractContactable self, PortReader reader)"""
        return _yarp.AbstractContactable_setReader(self, reader)


    def setAdminReader(self, reader):
        """setAdminReader(AbstractContactable self, PortReader reader)"""
        return _yarp.AbstractContactable_setAdminReader(self, reader)


    def setInputMode(self, expectInput):
        """setInputMode(AbstractContactable self, bool expectInput)"""
        return _yarp.AbstractContactable_setInputMode(self, expectInput)


    def setOutputMode(self, expectOutput):
        """setOutputMode(AbstractContactable self, bool expectOutput)"""
        return _yarp.AbstractContactable_setOutputMode(self, expectOutput)


    def setRpcMode(self, expectRpc):
        """setRpcMode(AbstractContactable self, bool expectRpc)"""
        return _yarp.AbstractContactable_setRpcMode(self, expectRpc)


    def getType(self):
        """getType(AbstractContactable self) -> Type"""
        return _yarp.AbstractContactable_getType(self)


    def promiseType(self, typ):
        """promiseType(AbstractContactable self, Type const & typ)"""
        return _yarp.AbstractContactable_promiseType(self, typ)


    def acquireProperties(self, readOnly):
        """acquireProperties(AbstractContactable self, bool readOnly) -> Property"""
        return _yarp.AbstractContactable_acquireProperties(self, readOnly)


    def releaseProperties(self, prop):
        """releaseProperties(AbstractContactable self, Property prop)"""
        return _yarp.AbstractContactable_releaseProperties(self, prop)


    def write(self, *args):
        """
        write(AbstractContactable self, PortWriter writer, PortWriter callback=None) -> bool
        write(AbstractContactable self, PortWriter writer) -> bool
        write(AbstractContactable self, PortWriter writer, PortReader reader, PortWriter callback=None) -> bool
        write(AbstractContactable self, PortWriter writer, PortReader reader) -> bool
        """
        return _yarp.AbstractContactable_write(self, *args)


    def read(self, reader, willReply=False):
        """
        read(AbstractContactable self, PortReader reader, bool willReply=False) -> bool
        read(AbstractContactable self, PortReader reader) -> bool
        """
        return _yarp.AbstractContactable_read(self, reader, willReply)


    def reply(self, writer):
        """reply(AbstractContactable self, PortWriter writer) -> bool"""
        return _yarp.AbstractContactable_reply(self, writer)


    def replyAndDrop(self, writer):
        """replyAndDrop(AbstractContactable self, PortWriter writer) -> bool"""
        return _yarp.AbstractContactable_replyAndDrop(self, writer)


    def includeNodeInName(self, flag):
        """includeNodeInName(AbstractContactable self, bool flag)"""
        return _yarp.AbstractContactable_includeNodeInName(self, flag)


    def setCallbackLock(self, mutex=None):
        """
        setCallbackLock(AbstractContactable self, yarp::os::Mutex * mutex=None) -> bool
        setCallbackLock(AbstractContactable self) -> bool
        """
        return _yarp.AbstractContactable_setCallbackLock(self, mutex)


    def removeCallbackLock(self):
        """removeCallbackLock(AbstractContactable self) -> bool"""
        return _yarp.AbstractContactable_removeCallbackLock(self)


    def lockCallback(self):
        """lockCallback(AbstractContactable self) -> bool"""
        return _yarp.AbstractContactable_lockCallback(self)


    def tryLockCallback(self):
        """tryLockCallback(AbstractContactable self) -> bool"""
        return _yarp.AbstractContactable_tryLockCallback(self)


    def unlockCallback(self):
        """unlockCallback(AbstractContactable self)"""
        return _yarp.AbstractContactable_unlockCallback(self)

    __swig_destroy__ = _yarp.delete_AbstractContactable
    __del__ = lambda self: None
AbstractContactable_swigregister = _yarp.AbstractContactable_swigregister
AbstractContactable_swigregister(AbstractContactable)

class NetworkBase(_object):
    """Proxy of C++ yarp::os::NetworkBase class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, NetworkBase, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, NetworkBase, name)
    __repr__ = _swig_repr

    def initMinimum(*args):
        """
        initMinimum()
        initMinimum(yarp::os::yarpClockType clockType, yarp::os::Clock * custom=None)
        initMinimum(yarp::os::yarpClockType clockType)
        """
        return _yarp.NetworkBase_initMinimum(*args)

    if _newclass:
        initMinimum = staticmethod(initMinimum)
    __swig_getmethods__["initMinimum"] = lambda x: initMinimum

    def autoInitMinimum(*args):
        """
        autoInitMinimum()
        autoInitMinimum(yarp::os::yarpClockType clockType, yarp::os::Clock * custom=None)
        autoInitMinimum(yarp::os::yarpClockType clockType)
        """
        return _yarp.NetworkBase_autoInitMinimum(*args)

    if _newclass:
        autoInitMinimum = staticmethod(autoInitMinimum)
    __swig_getmethods__["autoInitMinimum"] = lambda x: autoInitMinimum

    def finiMinimum():
        """finiMinimum()"""
        return _yarp.NetworkBase_finiMinimum()

    if _newclass:
        finiMinimum = staticmethod(finiMinimum)
    __swig_getmethods__["finiMinimum"] = lambda x: finiMinimum

    def connect(*args):
        """
        connect(yarp::os::ConstString const & src, yarp::os::ConstString const & dest, yarp::os::ConstString const & carrier, bool quiet=True) -> bool
        connect(yarp::os::ConstString const & src, yarp::os::ConstString const & dest, yarp::os::ConstString const & carrier) -> bool
        connect(yarp::os::ConstString const & src, yarp::os::ConstString const & dest) -> bool
        connect(char const * src, char const * dest, char const * carrier, bool quiet=True) -> bool
        connect(char const * src, char const * dest, char const * carrier) -> bool
        connect(yarp::os::ConstString const & src, yarp::os::ConstString const & dest, ContactStyle style) -> bool
        """
        return _yarp.NetworkBase_connect(*args)

    if _newclass:
        connect = staticmethod(connect)
    __swig_getmethods__["connect"] = lambda x: connect

    def disconnect(*args):
        """
        disconnect(yarp::os::ConstString const & src, yarp::os::ConstString const & dest, bool quiet=True) -> bool
        disconnect(yarp::os::ConstString const & src, yarp::os::ConstString const & dest) -> bool
        disconnect(yarp::os::ConstString const & src, yarp::os::ConstString const & dest, ContactStyle style) -> bool
        """
        return _yarp.NetworkBase_disconnect(*args)

    if _newclass:
        disconnect = staticmethod(disconnect)
    __swig_getmethods__["disconnect"] = lambda x: disconnect

    def isConnected(*args):
        """
        isConnected(yarp::os::ConstString const & src, yarp::os::ConstString const & dest, bool quiet=True) -> bool
        isConnected(yarp::os::ConstString const & src, yarp::os::ConstString const & dest) -> bool
        isConnected(yarp::os::ConstString const & src, yarp::os::ConstString const & dest, ContactStyle style) -> bool
        """
        return _yarp.NetworkBase_isConnected(*args)

    if _newclass:
        isConnected = staticmethod(isConnected)
    __swig_getmethods__["isConnected"] = lambda x: isConnected

    def exists(*args):
        """
        exists(yarp::os::ConstString const & port, bool quiet=True) -> bool
        exists(yarp::os::ConstString const & port) -> bool
        exists(yarp::os::ConstString const & port, ContactStyle style) -> bool
        """
        return _yarp.NetworkBase_exists(*args)

    if _newclass:
        exists = staticmethod(exists)
    __swig_getmethods__["exists"] = lambda x: exists

    def sync(port, quiet=True):
        """
        sync(yarp::os::ConstString const & port, bool quiet=True) -> bool
        sync(yarp::os::ConstString const & port) -> bool
        """
        return _yarp.NetworkBase_sync(port, quiet)

    if _newclass:
        sync = staticmethod(sync)
    __swig_getmethods__["sync"] = lambda x: sync

    def main(argc):
        """main(int argc) -> int"""
        return _yarp.NetworkBase_main(argc)

    if _newclass:
        main = staticmethod(main)
    __swig_getmethods__["main"] = lambda x: main

    def assertion(shouldBeTrue):
        """assertion(bool shouldBeTrue)"""
        return _yarp.NetworkBase_assertion(shouldBeTrue)

    if _newclass:
        assertion = staticmethod(assertion)
    __swig_getmethods__["assertion"] = lambda x: assertion

    def queryName(name):
        """queryName(yarp::os::ConstString const & name) -> Contact"""
        return _yarp.NetworkBase_queryName(name)

    if _newclass:
        queryName = staticmethod(queryName)
    __swig_getmethods__["queryName"] = lambda x: queryName

    def registerName(name):
        """registerName(yarp::os::ConstString const & name) -> Contact"""
        return _yarp.NetworkBase_registerName(name)

    if _newclass:
        registerName = staticmethod(registerName)
    __swig_getmethods__["registerName"] = lambda x: registerName

    def registerContact(contact):
        """registerContact(Contact contact) -> Contact"""
        return _yarp.NetworkBase_registerContact(contact)

    if _newclass:
        registerContact = staticmethod(registerContact)
    __swig_getmethods__["registerContact"] = lambda x: registerContact

    def unregisterName(name):
        """unregisterName(yarp::os::ConstString const & name) -> Contact"""
        return _yarp.NetworkBase_unregisterName(name)

    if _newclass:
        unregisterName = staticmethod(unregisterName)
    __swig_getmethods__["unregisterName"] = lambda x: unregisterName

    def unregisterContact(contact):
        """unregisterContact(Contact contact) -> Contact"""
        return _yarp.NetworkBase_unregisterContact(contact)

    if _newclass:
        unregisterContact = staticmethod(unregisterContact)
    __swig_getmethods__["unregisterContact"] = lambda x: unregisterContact

    def setProperty(name, key, value):
        """setProperty(char const * name, char const * key, Value value) -> bool"""
        return _yarp.NetworkBase_setProperty(name, key, value)

    if _newclass:
        setProperty = staticmethod(setProperty)
    __swig_getmethods__["setProperty"] = lambda x: setProperty

    def getProperty(name, key):
        """getProperty(char const * name, char const * key) -> Value"""
        return _yarp.NetworkBase_getProperty(name, key)

    if _newclass:
        getProperty = staticmethod(getProperty)
    __swig_getmethods__["getProperty"] = lambda x: getProperty

    def getNameServerName():
        """getNameServerName() -> yarp::os::ConstString"""
        return _yarp.NetworkBase_getNameServerName()

    if _newclass:
        getNameServerName = staticmethod(getNameServerName)
    __swig_getmethods__["getNameServerName"] = lambda x: getNameServerName

    def getNameServerContact():
        """getNameServerContact() -> Contact"""
        return _yarp.NetworkBase_getNameServerContact()

    if _newclass:
        getNameServerContact = staticmethod(getNameServerContact)
    __swig_getmethods__["getNameServerContact"] = lambda x: getNameServerContact

    def setNameServerName(name):
        """setNameServerName(yarp::os::ConstString const & name) -> bool"""
        return _yarp.NetworkBase_setNameServerName(name)

    if _newclass:
        setNameServerName = staticmethod(setNameServerName)
    __swig_getmethods__["setNameServerName"] = lambda x: setNameServerName

    def setLocalMode(flag):
        """setLocalMode(bool flag) -> bool"""
        return _yarp.NetworkBase_setLocalMode(flag)

    if _newclass:
        setLocalMode = staticmethod(setLocalMode)
    __swig_getmethods__["setLocalMode"] = lambda x: setLocalMode

    def getLocalMode():
        """getLocalMode() -> bool"""
        return _yarp.NetworkBase_getLocalMode()

    if _newclass:
        getLocalMode = staticmethod(getLocalMode)
    __swig_getmethods__["getLocalMode"] = lambda x: getLocalMode

    def readString(eof=None):
        """
        readString(bool * eof=None) -> yarp::os::ConstString
        readString() -> yarp::os::ConstString
        """
        return _yarp.NetworkBase_readString(eof)

    if _newclass:
        readString = staticmethod(readString)
    __swig_getmethods__["readString"] = lambda x: readString

    def writeToNameServer(cmd, reply, style):
        """writeToNameServer(PortWriter cmd, PortReader reply, ContactStyle style) -> bool"""
        return _yarp.NetworkBase_writeToNameServer(cmd, reply, style)

    if _newclass:
        writeToNameServer = staticmethod(writeToNameServer)
    __swig_getmethods__["writeToNameServer"] = lambda x: writeToNameServer

    def write(*args):
        """
        write(Contact contact, PortWriter cmd, PortReader reply, bool admin=False, bool quiet=False, double timeout=-1) -> bool
        write(Contact contact, PortWriter cmd, PortReader reply, bool admin=False, bool quiet=False) -> bool
        write(Contact contact, PortWriter cmd, PortReader reply, bool admin=False) -> bool
        write(Contact contact, PortWriter cmd, PortReader reply) -> bool
        write(Contact contact, PortWriter cmd, PortReader reply, ContactStyle style) -> bool
        write(yarp::os::ConstString const & port_name, PortWriter cmd, PortReader reply) -> bool
        """
        return _yarp.NetworkBase_write(*args)

    if _newclass:
        write = staticmethod(write)
    __swig_getmethods__["write"] = lambda x: write

    def checkNetwork(*args):
        """
        checkNetwork() -> bool
        checkNetwork(double timeout) -> bool
        """
        return _yarp.NetworkBase_checkNetwork(*args)

    if _newclass:
        checkNetwork = staticmethod(checkNetwork)
    __swig_getmethods__["checkNetwork"] = lambda x: checkNetwork

    def initialized():
        """initialized() -> bool"""
        return _yarp.NetworkBase_initialized()

    if _newclass:
        initialized = staticmethod(initialized)
    __swig_getmethods__["initialized"] = lambda x: initialized

    def setVerbosity(verbosity):
        """setVerbosity(int verbosity)"""
        return _yarp.NetworkBase_setVerbosity(verbosity)

    if _newclass:
        setVerbosity = staticmethod(setVerbosity)
    __swig_getmethods__["setVerbosity"] = lambda x: setVerbosity

    def queryBypass(store):
        """queryBypass(NameStore * store)"""
        return _yarp.NetworkBase_queryBypass(store)

    if _newclass:
        queryBypass = staticmethod(queryBypass)
    __swig_getmethods__["queryBypass"] = lambda x: queryBypass

    def getQueryBypass():
        """getQueryBypass() -> NameStore *"""
        return _yarp.NetworkBase_getQueryBypass()

    if _newclass:
        getQueryBypass = staticmethod(getQueryBypass)
    __swig_getmethods__["getQueryBypass"] = lambda x: getQueryBypass

    def getEnvironment(key, found=None):
        """
        getEnvironment(char const * key, bool * found=None) -> yarp::os::ConstString
        getEnvironment(char const * key) -> yarp::os::ConstString
        """
        return _yarp.NetworkBase_getEnvironment(key, found)

    if _newclass:
        getEnvironment = staticmethod(getEnvironment)
    __swig_getmethods__["getEnvironment"] = lambda x: getEnvironment

    def setEnvironment(key, val):
        """setEnvironment(yarp::os::ConstString const & key, yarp::os::ConstString const & val)"""
        return _yarp.NetworkBase_setEnvironment(key, val)

    if _newclass:
        setEnvironment = staticmethod(setEnvironment)
    __swig_getmethods__["setEnvironment"] = lambda x: setEnvironment

    def unsetEnvironment(key):
        """unsetEnvironment(yarp::os::ConstString const & key)"""
        return _yarp.NetworkBase_unsetEnvironment(key)

    if _newclass:
        unsetEnvironment = staticmethod(unsetEnvironment)
    __swig_getmethods__["unsetEnvironment"] = lambda x: unsetEnvironment

    def getDirectorySeparator():
        """getDirectorySeparator() -> yarp::os::ConstString"""
        return _yarp.NetworkBase_getDirectorySeparator()

    if _newclass:
        getDirectorySeparator = staticmethod(getDirectorySeparator)
    __swig_getmethods__["getDirectorySeparator"] = lambda x: getDirectorySeparator

    def getPathSeparator():
        """getPathSeparator() -> yarp::os::ConstString"""
        return _yarp.NetworkBase_getPathSeparator()

    if _newclass:
        getPathSeparator = staticmethod(getPathSeparator)
    __swig_getmethods__["getPathSeparator"] = lambda x: getPathSeparator

    def registerCarrier(name, dll):
        """registerCarrier(char const * name, char const * dll) -> bool"""
        return _yarp.NetworkBase_registerCarrier(name, dll)

    if _newclass:
        registerCarrier = staticmethod(registerCarrier)
    __swig_getmethods__["registerCarrier"] = lambda x: registerCarrier

    def lock():
        """lock()"""
        return _yarp.NetworkBase_lock()

    if _newclass:
        lock = staticmethod(lock)
    __swig_getmethods__["lock"] = lambda x: lock

    def unlock():
        """unlock()"""
        return _yarp.NetworkBase_unlock()

    if _newclass:
        unlock = staticmethod(unlock)
    __swig_getmethods__["unlock"] = lambda x: unlock

    def localNetworkAllocation():
        """localNetworkAllocation() -> bool"""
        return _yarp.NetworkBase_localNetworkAllocation()

    if _newclass:
        localNetworkAllocation = staticmethod(localNetworkAllocation)
    __swig_getmethods__["localNetworkAllocation"] = lambda x: localNetworkAllocation

    def detectNameServer(useDetectedServer, scanNeeded, serverUsed):
        """detectNameServer(bool useDetectedServer, bool & scanNeeded, bool & serverUsed) -> Contact"""
        return _yarp.NetworkBase_detectNameServer(useDetectedServer, scanNeeded, serverUsed)

    if _newclass:
        detectNameServer = staticmethod(detectNameServer)
    __swig_getmethods__["detectNameServer"] = lambda x: detectNameServer

    def setNameServerContact(nameServerContact):
        """setNameServerContact(Contact nameServerContact) -> bool"""
        return _yarp.NetworkBase_setNameServerContact(nameServerContact)

    if _newclass:
        setNameServerContact = staticmethod(setNameServerContact)
    __swig_getmethods__["setNameServerContact"] = lambda x: setNameServerContact

    def getConfigFile(fname):
        """getConfigFile(char const * fname) -> yarp::os::ConstString"""
        return _yarp.NetworkBase_getConfigFile(fname)

    if _newclass:
        getConfigFile = staticmethod(getConfigFile)
    __swig_getmethods__["getConfigFile"] = lambda x: getConfigFile

    def getDefaultPortRange():
        """getDefaultPortRange() -> int"""
        return _yarp.NetworkBase_getDefaultPortRange()

    if _newclass:
        getDefaultPortRange = staticmethod(getDefaultPortRange)
    __swig_getmethods__["getDefaultPortRange"] = lambda x: getDefaultPortRange

    def setConnectionQos(*args):
        """
        setConnectionQos(yarp::os::ConstString const & src, yarp::os::ConstString const & dest, QosStyle srcStyle, QosStyle destStyle, bool quiet=True) -> bool
        setConnectionQos(yarp::os::ConstString const & src, yarp::os::ConstString const & dest, QosStyle srcStyle, QosStyle destStyle) -> bool
        setConnectionQos(yarp::os::ConstString const & src, yarp::os::ConstString const & dest, QosStyle style, bool quiet=True) -> bool
        setConnectionQos(yarp::os::ConstString const & src, yarp::os::ConstString const & dest, QosStyle style) -> bool
        """
        return _yarp.NetworkBase_setConnectionQos(*args)

    if _newclass:
        setConnectionQos = staticmethod(setConnectionQos)
    __swig_getmethods__["setConnectionQos"] = lambda x: setConnectionQos

    def getConnectionQos(src, dest, srcStyle, destStyle, quiet=True):
        """
        getConnectionQos(yarp::os::ConstString const & src, yarp::os::ConstString const & dest, QosStyle srcStyle, QosStyle destStyle, bool quiet=True) -> bool
        getConnectionQos(yarp::os::ConstString const & src, yarp::os::ConstString const & dest, QosStyle srcStyle, QosStyle destStyle) -> bool
        """
        return _yarp.NetworkBase_getConnectionQos(src, dest, srcStyle, destStyle, quiet)

    if _newclass:
        getConnectionQos = staticmethod(getConnectionQos)
    __swig_getmethods__["getConnectionQos"] = lambda x: getConnectionQos

    def isValidPortName(portName):
        """isValidPortName(yarp::os::ConstString const & portName) -> bool"""
        return _yarp.NetworkBase_isValidPortName(portName)

    if _newclass:
        isValidPortName = staticmethod(isValidPortName)
    __swig_getmethods__["isValidPortName"] = lambda x: isValidPortName

    def __init__(self):
        """__init__(yarp::os::NetworkBase self) -> NetworkBase"""
        this = _yarp.new_NetworkBase()
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _yarp.delete_NetworkBase
    __del__ = lambda self: None
NetworkBase_swigregister = _yarp.NetworkBase_swigregister
NetworkBase_swigregister(NetworkBase)

def NetworkBase_initMinimum(*args):
    """
    initMinimum()
    initMinimum(yarp::os::yarpClockType clockType, yarp::os::Clock * custom=None)
    NetworkBase_initMinimum(yarp::os::yarpClockType clockType)
    """
    return _yarp.NetworkBase_initMinimum(*args)

def NetworkBase_autoInitMinimum(*args):
    """
    autoInitMinimum()
    autoInitMinimum(yarp::os::yarpClockType clockType, yarp::os::Clock * custom=None)
    NetworkBase_autoInitMinimum(yarp::os::yarpClockType clockType)
    """
    return _yarp.NetworkBase_autoInitMinimum(*args)

def NetworkBase_finiMinimum():
    """NetworkBase_finiMinimum()"""
    return _yarp.NetworkBase_finiMinimum()

def NetworkBase_connect(*args):
    """
    connect(yarp::os::ConstString const & src, yarp::os::ConstString const & dest, yarp::os::ConstString const & carrier, bool quiet=True) -> bool
    connect(yarp::os::ConstString const & src, yarp::os::ConstString const & dest, yarp::os::ConstString const & carrier) -> bool
    connect(yarp::os::ConstString const & src, yarp::os::ConstString const & dest) -> bool
    connect(char const * src, char const * dest, char const * carrier, bool quiet=True) -> bool
    connect(char const * src, char const * dest, char const * carrier) -> bool
    NetworkBase_connect(yarp::os::ConstString const & src, yarp::os::ConstString const & dest, ContactStyle style) -> bool
    """
    return _yarp.NetworkBase_connect(*args)

def NetworkBase_disconnect(*args):
    """
    disconnect(yarp::os::ConstString const & src, yarp::os::ConstString const & dest, bool quiet=True) -> bool
    disconnect(yarp::os::ConstString const & src, yarp::os::ConstString const & dest) -> bool
    NetworkBase_disconnect(yarp::os::ConstString const & src, yarp::os::ConstString const & dest, ContactStyle style) -> bool
    """
    return _yarp.NetworkBase_disconnect(*args)

def NetworkBase_isConnected(*args):
    """
    isConnected(yarp::os::ConstString const & src, yarp::os::ConstString const & dest, bool quiet=True) -> bool
    isConnected(yarp::os::ConstString const & src, yarp::os::ConstString const & dest) -> bool
    NetworkBase_isConnected(yarp::os::ConstString const & src, yarp::os::ConstString const & dest, ContactStyle style) -> bool
    """
    return _yarp.NetworkBase_isConnected(*args)

def NetworkBase_exists(*args):
    """
    exists(yarp::os::ConstString const & port, bool quiet=True) -> bool
    exists(yarp::os::ConstString const & port) -> bool
    NetworkBase_exists(yarp::os::ConstString const & port, ContactStyle style) -> bool
    """
    return _yarp.NetworkBase_exists(*args)

def NetworkBase_sync(port, quiet=True):
    """
    sync(yarp::os::ConstString const & port, bool quiet=True) -> bool
    NetworkBase_sync(yarp::os::ConstString const & port) -> bool
    """
    return _yarp.NetworkBase_sync(port, quiet)

def NetworkBase_main(argc):
    """NetworkBase_main(int argc) -> int"""
    return _yarp.NetworkBase_main(argc)

def NetworkBase_assertion(shouldBeTrue):
    """NetworkBase_assertion(bool shouldBeTrue)"""
    return _yarp.NetworkBase_assertion(shouldBeTrue)

def NetworkBase_queryName(name):
    """NetworkBase_queryName(yarp::os::ConstString const & name) -> Contact"""
    return _yarp.NetworkBase_queryName(name)

def NetworkBase_registerName(name):
    """NetworkBase_registerName(yarp::os::ConstString const & name) -> Contact"""
    return _yarp.NetworkBase_registerName(name)

def NetworkBase_registerContact(contact):
    """NetworkBase_registerContact(Contact contact) -> Contact"""
    return _yarp.NetworkBase_registerContact(contact)

def NetworkBase_unregisterName(name):
    """NetworkBase_unregisterName(yarp::os::ConstString const & name) -> Contact"""
    return _yarp.NetworkBase_unregisterName(name)

def NetworkBase_unregisterContact(contact):
    """NetworkBase_unregisterContact(Contact contact) -> Contact"""
    return _yarp.NetworkBase_unregisterContact(contact)

def NetworkBase_setProperty(name, key, value):
    """NetworkBase_setProperty(char const * name, char const * key, Value value) -> bool"""
    return _yarp.NetworkBase_setProperty(name, key, value)

def NetworkBase_getProperty(name, key):
    """NetworkBase_getProperty(char const * name, char const * key) -> Value"""
    return _yarp.NetworkBase_getProperty(name, key)

def NetworkBase_getNameServerName():
    """NetworkBase_getNameServerName() -> yarp::os::ConstString"""
    return _yarp.NetworkBase_getNameServerName()

def NetworkBase_getNameServerContact():
    """NetworkBase_getNameServerContact() -> Contact"""
    return _yarp.NetworkBase_getNameServerContact()

def NetworkBase_setNameServerName(name):
    """NetworkBase_setNameServerName(yarp::os::ConstString const & name) -> bool"""
    return _yarp.NetworkBase_setNameServerName(name)

def NetworkBase_setLocalMode(flag):
    """NetworkBase_setLocalMode(bool flag) -> bool"""
    return _yarp.NetworkBase_setLocalMode(flag)

def NetworkBase_getLocalMode():
    """NetworkBase_getLocalMode() -> bool"""
    return _yarp.NetworkBase_getLocalMode()

def NetworkBase_readString(eof=None):
    """
    readString(bool * eof=None) -> yarp::os::ConstString
    NetworkBase_readString() -> yarp::os::ConstString
    """
    return _yarp.NetworkBase_readString(eof)

def NetworkBase_writeToNameServer(cmd, reply, style):
    """NetworkBase_writeToNameServer(PortWriter cmd, PortReader reply, ContactStyle style) -> bool"""
    return _yarp.NetworkBase_writeToNameServer(cmd, reply, style)

def NetworkBase_write(*args):
    """
    write(Contact contact, PortWriter cmd, PortReader reply, bool admin=False, bool quiet=False, double timeout=-1) -> bool
    write(Contact contact, PortWriter cmd, PortReader reply, bool admin=False, bool quiet=False) -> bool
    write(Contact contact, PortWriter cmd, PortReader reply, bool admin=False) -> bool
    write(Contact contact, PortWriter cmd, PortReader reply) -> bool
    write(Contact contact, PortWriter cmd, PortReader reply, ContactStyle style) -> bool
    NetworkBase_write(yarp::os::ConstString const & port_name, PortWriter cmd, PortReader reply) -> bool
    """
    return _yarp.NetworkBase_write(*args)

def NetworkBase_checkNetwork(*args):
    """
    checkNetwork() -> bool
    NetworkBase_checkNetwork(double timeout) -> bool
    """
    return _yarp.NetworkBase_checkNetwork(*args)

def NetworkBase_initialized():
    """NetworkBase_initialized() -> bool"""
    return _yarp.NetworkBase_initialized()

def NetworkBase_setVerbosity(verbosity):
    """NetworkBase_setVerbosity(int verbosity)"""
    return _yarp.NetworkBase_setVerbosity(verbosity)

def NetworkBase_queryBypass(store):
    """NetworkBase_queryBypass(NameStore * store)"""
    return _yarp.NetworkBase_queryBypass(store)

def NetworkBase_getQueryBypass():
    """NetworkBase_getQueryBypass() -> NameStore *"""
    return _yarp.NetworkBase_getQueryBypass()

def NetworkBase_getEnvironment(key, found=None):
    """
    getEnvironment(char const * key, bool * found=None) -> yarp::os::ConstString
    NetworkBase_getEnvironment(char const * key) -> yarp::os::ConstString
    """
    return _yarp.NetworkBase_getEnvironment(key, found)

def NetworkBase_setEnvironment(key, val):
    """NetworkBase_setEnvironment(yarp::os::ConstString const & key, yarp::os::ConstString const & val)"""
    return _yarp.NetworkBase_setEnvironment(key, val)

def NetworkBase_unsetEnvironment(key):
    """NetworkBase_unsetEnvironment(yarp::os::ConstString const & key)"""
    return _yarp.NetworkBase_unsetEnvironment(key)

def NetworkBase_getDirectorySeparator():
    """NetworkBase_getDirectorySeparator() -> yarp::os::ConstString"""
    return _yarp.NetworkBase_getDirectorySeparator()

def NetworkBase_getPathSeparator():
    """NetworkBase_getPathSeparator() -> yarp::os::ConstString"""
    return _yarp.NetworkBase_getPathSeparator()

def NetworkBase_registerCarrier(name, dll):
    """NetworkBase_registerCarrier(char const * name, char const * dll) -> bool"""
    return _yarp.NetworkBase_registerCarrier(name, dll)

def NetworkBase_lock():
    """NetworkBase_lock()"""
    return _yarp.NetworkBase_lock()

def NetworkBase_unlock():
    """NetworkBase_unlock()"""
    return _yarp.NetworkBase_unlock()

def NetworkBase_localNetworkAllocation():
    """NetworkBase_localNetworkAllocation() -> bool"""
    return _yarp.NetworkBase_localNetworkAllocation()

def NetworkBase_detectNameServer(useDetectedServer, scanNeeded, serverUsed):
    """NetworkBase_detectNameServer(bool useDetectedServer, bool & scanNeeded, bool & serverUsed) -> Contact"""
    return _yarp.NetworkBase_detectNameServer(useDetectedServer, scanNeeded, serverUsed)

def NetworkBase_setNameServerContact(nameServerContact):
    """NetworkBase_setNameServerContact(Contact nameServerContact) -> bool"""
    return _yarp.NetworkBase_setNameServerContact(nameServerContact)

def NetworkBase_getConfigFile(fname):
    """NetworkBase_getConfigFile(char const * fname) -> yarp::os::ConstString"""
    return _yarp.NetworkBase_getConfigFile(fname)

def NetworkBase_getDefaultPortRange():
    """NetworkBase_getDefaultPortRange() -> int"""
    return _yarp.NetworkBase_getDefaultPortRange()

def NetworkBase_setConnectionQos(*args):
    """
    setConnectionQos(yarp::os::ConstString const & src, yarp::os::ConstString const & dest, QosStyle srcStyle, QosStyle destStyle, bool quiet=True) -> bool
    setConnectionQos(yarp::os::ConstString const & src, yarp::os::ConstString const & dest, QosStyle srcStyle, QosStyle destStyle) -> bool
    setConnectionQos(yarp::os::ConstString const & src, yarp::os::ConstString const & dest, QosStyle style, bool quiet=True) -> bool
    NetworkBase_setConnectionQos(yarp::os::ConstString const & src, yarp::os::ConstString const & dest, QosStyle style) -> bool
    """
    return _yarp.NetworkBase_setConnectionQos(*args)

def NetworkBase_getConnectionQos(src, dest, srcStyle, destStyle, quiet=True):
    """
    getConnectionQos(yarp::os::ConstString const & src, yarp::os::ConstString const & dest, QosStyle srcStyle, QosStyle destStyle, bool quiet=True) -> bool
    NetworkBase_getConnectionQos(yarp::os::ConstString const & src, yarp::os::ConstString const & dest, QosStyle srcStyle, QosStyle destStyle) -> bool
    """
    return _yarp.NetworkBase_getConnectionQos(src, dest, srcStyle, destStyle, quiet)

def NetworkBase_isValidPortName(portName):
    """NetworkBase_isValidPortName(yarp::os::ConstString const & portName) -> bool"""
    return _yarp.NetworkBase_isValidPortName(portName)

class Network(NetworkBase):
    """Proxy of C++ yarp::os::Network class."""

    __swig_setmethods__ = {}
    for _s in [NetworkBase]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Network, name, value)
    __swig_getmethods__ = {}
    for _s in [NetworkBase]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Network, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(yarp::os::Network self) -> Network
        __init__(yarp::os::Network self, yarp::os::yarpClockType clockType, yarp::os::Clock * custom=None) -> Network
        __init__(yarp::os::Network self, yarp::os::yarpClockType clockType) -> Network
        """
        this = _yarp.new_Network(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _yarp.delete_Network
    __del__ = lambda self: None

    def init(*args):
        """
        init()
        init(yarp::os::yarpClockType clockType, Clock * custom=None)
        init(yarp::os::yarpClockType clockType)
        """
        return _yarp.Network_init(*args)

    if _newclass:
        init = staticmethod(init)
    __swig_getmethods__["init"] = lambda x: init

    def fini():
        """fini()"""
        return _yarp.Network_fini()

    if _newclass:
        fini = staticmethod(fini)
    __swig_getmethods__["fini"] = lambda x: fini

    def yarpClockInit(clockType, custom=None):
        """
        yarpClockInit(yarp::os::yarpClockType clockType, Clock * custom=None)
        yarpClockInit(yarp::os::yarpClockType clockType)
        """
        return _yarp.Network_yarpClockInit(clockType, custom)

    if _newclass:
        yarpClockInit = staticmethod(yarpClockInit)
    __swig_getmethods__["yarpClockInit"] = lambda x: yarpClockInit
Network_swigregister = _yarp.Network_swigregister
Network_swigregister(Network)

def Network_init(*args):
    """
    init()
    init(yarp::os::yarpClockType clockType, Clock * custom=None)
    Network_init(yarp::os::yarpClockType clockType)
    """
    return _yarp.Network_init(*args)

def Network_fini():
    """Network_fini()"""
    return _yarp.Network_fini()

def Network_yarpClockInit(clockType, custom=None):
    """
    yarpClockInit(yarp::os::yarpClockType clockType, Clock * custom=None)
    Network_yarpClockInit(yarp::os::yarpClockType clockType)
    """
    return _yarp.Network_yarpClockInit(clockType, custom)

class PortablePairBase(Portable):
    """Proxy of C++ yarp::os::PortablePairBase class."""

    __swig_setmethods__ = {}
    for _s in [Portable]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, PortablePairBase, name, value)
    __swig_getmethods__ = {}
    for _s in [Portable]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, PortablePairBase, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def readPair(connection, head, body):
        """readPair(ConnectionReader connection, Portable head, Portable body) -> bool"""
        return _yarp.PortablePairBase_readPair(connection, head, body)

    if _newclass:
        readPair = staticmethod(readPair)
    __swig_getmethods__["readPair"] = lambda x: readPair

    def writePair(connection, head, body):
        """writePair(ConnectionWriter connection, Portable head, Portable body) -> bool"""
        return _yarp.PortablePairBase_writePair(connection, head, body)

    if _newclass:
        writePair = staticmethod(writePair)
    __swig_getmethods__["writePair"] = lambda x: writePair
    __swig_destroy__ = _yarp.delete_PortablePairBase
    __del__ = lambda self: None
PortablePairBase_swigregister = _yarp.PortablePairBase_swigregister
PortablePairBase_swigregister(PortablePairBase)

def PortablePairBase_readPair(connection, head, body):
    """PortablePairBase_readPair(ConnectionReader connection, Portable head, Portable body) -> bool"""
    return _yarp.PortablePairBase_readPair(connection, head, body)

def PortablePairBase_writePair(connection, head, body):
    """PortablePairBase_writePair(ConnectionWriter connection, Portable head, Portable body) -> bool"""
    return _yarp.PortablePairBase_writePair(connection, head, body)

class PortReaderCreator(_object):
    """Proxy of C++ yarp::os::PortReaderCreator class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PortReaderCreator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PortReaderCreator, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_PortReaderCreator
    __del__ = lambda self: None

    def create(self):
        """create(PortReaderCreator self) -> PortReader"""
        return _yarp.PortReaderCreator_create(self)

PortReaderCreator_swigregister = _yarp.PortReaderCreator_swigregister
PortReaderCreator_swigregister(PortReaderCreator)

class Property(Searchable, Portable):
    """Proxy of C++ yarp::os::Property class."""

    __swig_setmethods__ = {}
    for _s in [Searchable, Portable]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Property, name, value)
    __swig_getmethods__ = {}
    for _s in [Searchable, Portable]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Property, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(yarp::os::Property self, int hash_size=0) -> Property
        __init__(yarp::os::Property self) -> Property
        __init__(yarp::os::Property self, char const * str) -> Property
        __init__(yarp::os::Property self, Property prop) -> Property
        """
        this = _yarp.new_Property(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _yarp.delete_Property
    __del__ = lambda self: None

    def check(self, *args):
        """
        check(Property self, yarp::os::ConstString const & key) -> bool
        check(Property self, yarp::os::ConstString const & key, yarp::os::ConstString const & comment) -> bool
        check(Property self, yarp::os::ConstString const & key, Value fallback, yarp::os::ConstString const & comment) -> Value
        check(Property self, yarp::os::ConstString const & key, Value fallback) -> Value
        check(Property self, yarp::os::ConstString const & key) -> bool
        """
        return _yarp.Property_check(self, *args)


    def put(self, *args):
        """
        put(Property self, yarp::os::ConstString const & key, yarp::os::ConstString const & value)
        put(Property self, yarp::os::ConstString const & key, Value value)
        put(Property self, yarp::os::ConstString const & key, Value value)
        put(Property self, yarp::os::ConstString const & key, int value)
        put(Property self, yarp::os::ConstString const & key, double value)
        """
        return _yarp.Property_put(self, *args)


    def addGroup(self, key):
        """addGroup(Property self, yarp::os::ConstString const & key) -> Property"""
        return _yarp.Property_addGroup(self, key)


    def unput(self, key):
        """unput(Property self, yarp::os::ConstString const & key)"""
        return _yarp.Property_unput(self, key)


    def find(self, key):
        """find(Property self, yarp::os::ConstString const & key) -> Value"""
        return _yarp.Property_find(self, key)


    def findGroup(self, *args):
        """
        findGroup(Property self, yarp::os::ConstString const & key) -> Bottle
        findGroup(Property self, yarp::os::ConstString const & key, yarp::os::ConstString const & comment) -> Bottle
        findGroup(Property self, yarp::os::ConstString const & key) -> Bottle
        """
        return _yarp.Property_findGroup(self, *args)


    def clear(self):
        """clear(Property self)"""
        return _yarp.Property_clear(self)


    def fromString(self, txt, wipe=True):
        """
        fromString(Property self, yarp::os::ConstString const & txt, bool wipe=True)
        fromString(Property self, yarp::os::ConstString const & txt)
        """
        return _yarp.Property_fromString(self, txt, wipe)


    def fromCommand(self, argc, skipFirst=True, wipe=True):
        """
        fromCommand(Property self, int argc, bool skipFirst=True, bool wipe=True)
        fromCommand(Property self, int argc, bool skipFirst=True)
        fromCommand(Property self, int argc)
        """
        return _yarp.Property_fromCommand(self, argc, skipFirst, wipe)


    def fromArguments(self, arguments, wipe=True):
        """
        fromArguments(Property self, char const * arguments, bool wipe=True)
        fromArguments(Property self, char const * arguments)
        """
        return _yarp.Property_fromArguments(self, arguments, wipe)


    def fromConfigFile(self, *args):
        """
        fromConfigFile(Property self, yarp::os::ConstString const & fname, bool wipe=True) -> bool
        fromConfigFile(Property self, yarp::os::ConstString const & fname) -> bool
        fromConfigFile(Property self, yarp::os::ConstString const & fname, Searchable env, bool wipe=True) -> bool
        fromConfigFile(Property self, yarp::os::ConstString const & fname, Searchable env) -> bool
        """
        return _yarp.Property_fromConfigFile(self, *args)


    def fromConfigDir(self, *args):
        """
        fromConfigDir(Property self, yarp::os::ConstString const & dirname, yarp::os::ConstString const & section, bool wipe=True) -> bool
        fromConfigDir(Property self, yarp::os::ConstString const & dirname, yarp::os::ConstString const & section) -> bool
        fromConfigDir(Property self, yarp::os::ConstString const & dirname) -> bool
        """
        return _yarp.Property_fromConfigDir(self, *args)


    def fromConfig(self, *args):
        """
        fromConfig(Property self, char const * txt, bool wipe=True)
        fromConfig(Property self, char const * txt)
        fromConfig(Property self, char const * txt, Searchable env, bool wipe=True)
        fromConfig(Property self, char const * txt, Searchable env)
        """
        return _yarp.Property_fromConfig(self, *args)


    def fromQuery(self, url, wipe=True):
        """
        fromQuery(Property self, char const * url, bool wipe=True)
        fromQuery(Property self, char const * url)
        """
        return _yarp.Property_fromQuery(self, url, wipe)


    def toString_c(self):
        """toString_c(Property self) -> yarp::os::ConstString"""
        return _yarp.Property_toString_c(self)


    def read(self, reader):
        """read(Property self, ConnectionReader reader) -> bool"""
        return _yarp.Property_read(self, reader)


    def write(self, writer):
        """write(Property self, ConnectionWriter writer) -> bool"""
        return _yarp.Property_write(self, writer)


    def toString(self):
        """toString(Property self) -> std::string"""
        return _yarp.Property_toString(self)

Property_swigregister = _yarp.Property_swigregister
Property_swigregister(Property)


_yarp.BOTTLE_TAG_INT_swigconstant(_yarp)
BOTTLE_TAG_INT = _yarp.BOTTLE_TAG_INT

_yarp.BOTTLE_TAG_VOCAB_swigconstant(_yarp)
BOTTLE_TAG_VOCAB = _yarp.BOTTLE_TAG_VOCAB

_yarp.BOTTLE_TAG_DOUBLE_swigconstant(_yarp)
BOTTLE_TAG_DOUBLE = _yarp.BOTTLE_TAG_DOUBLE

_yarp.BOTTLE_TAG_STRING_swigconstant(_yarp)
BOTTLE_TAG_STRING = _yarp.BOTTLE_TAG_STRING

_yarp.BOTTLE_TAG_BLOB_swigconstant(_yarp)
BOTTLE_TAG_BLOB = _yarp.BOTTLE_TAG_BLOB

_yarp.BOTTLE_TAG_INT64_swigconstant(_yarp)
BOTTLE_TAG_INT64 = _yarp.BOTTLE_TAG_INT64

_yarp.BOTTLE_TAG_LIST_swigconstant(_yarp)
BOTTLE_TAG_LIST = _yarp.BOTTLE_TAG_LIST

_yarp.BOTTLE_TAG_DICT_swigconstant(_yarp)
BOTTLE_TAG_DICT = _yarp.BOTTLE_TAG_DICT
class Bottle(Portable, Searchable):
    """Proxy of C++ yarp::os::Bottle class."""

    __swig_setmethods__ = {}
    for _s in [Portable, Searchable]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Bottle, name, value)
    __swig_getmethods__ = {}
    for _s in [Portable, Searchable]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Bottle, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(yarp::os::Bottle self) -> Bottle
        __init__(yarp::os::Bottle self, yarp::os::ConstString const & text) -> Bottle
        __init__(yarp::os::Bottle self, Bottle bottle) -> Bottle
        """
        this = _yarp.new_Bottle(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _yarp.delete_Bottle
    __del__ = lambda self: None

    def clear(self):
        """clear(Bottle self)"""
        return _yarp.Bottle_clear(self)


    def addInt(self, x):
        """addInt(Bottle self, int x)"""
        return _yarp.Bottle_addInt(self, x)


    def addInt64(self, x):
        """addInt64(Bottle self, YARP_INT64 const & x)"""
        return _yarp.Bottle_addInt64(self, x)


    def addVocab(self, x):
        """addVocab(Bottle self, int x)"""
        return _yarp.Bottle_addVocab(self, x)


    def addDouble(self, x):
        """addDouble(Bottle self, double x)"""
        return _yarp.Bottle_addDouble(self, x)


    def addString(self, *args):
        """
        addString(Bottle self, char const * str)
        addString(Bottle self, yarp::os::ConstString const & str)
        """
        return _yarp.Bottle_addString(self, *args)


    def add(self, value):
        """add(Bottle self, Value value)"""
        return _yarp.Bottle_add(self, value)


    def addList(self):
        """addList(Bottle self) -> Bottle"""
        return _yarp.Bottle_addList(self)


    def addDict(self):
        """addDict(Bottle self) -> Property"""
        return _yarp.Bottle_addDict(self)


    def pop(self):
        """pop(Bottle self) -> Value"""
        return _yarp.Bottle_pop(self)


    def get(self, index):
        """get(Bottle self, int index) -> Value"""
        return _yarp.Bottle_get(self, index)


    def size(self):
        """size(Bottle self) -> int"""
        return _yarp.Bottle_size(self)


    def fromString(self, text):
        """fromString(Bottle self, yarp::os::ConstString const & text)"""
        return _yarp.Bottle_fromString(self, text)


    def fromBinary(self, buf, len):
        """fromBinary(Bottle self, char const * buf, int len)"""
        return _yarp.Bottle_fromBinary(self, buf, len)


    def toBinary(self, size=None):
        """
        toBinary(Bottle self, size_t * size=None) -> char const
        toBinary(Bottle self) -> char const *
        """
        return _yarp.Bottle_toBinary(self, size)


    def toString_c(self):
        """toString_c(Bottle self) -> yarp::os::ConstString"""
        return _yarp.Bottle_toString_c(self)


    def write(self, *args):
        """
        write(Bottle self, ConnectionWriter writer) -> bool
        write(Bottle self, PortReader reader, bool textMode=False) -> bool
        write(Bottle self, PortReader reader) -> bool
        """
        return _yarp.Bottle_write(self, *args)


    def read(self, *args):
        """
        read(Bottle self, ConnectionReader reader) -> bool
        read(Bottle self, PortWriter writer, bool textMode=False) -> bool
        read(Bottle self, PortWriter writer) -> bool
        """
        return _yarp.Bottle_read(self, *args)


    def onCommencement(self):
        """onCommencement(Bottle self)"""
        return _yarp.Bottle_onCommencement(self)


    def check(self, *args):
        """
        check(Bottle self, yarp::os::ConstString const & key) -> bool
        check(Bottle self, yarp::os::ConstString const & key, yarp::os::ConstString const & comment) -> bool
        check(Bottle self, yarp::os::ConstString const & key, Value fallback, yarp::os::ConstString const & comment) -> Value
        check(Bottle self, yarp::os::ConstString const & key, Value fallback) -> Value
        check(Bottle self, yarp::os::ConstString const & key) -> bool
        """
        return _yarp.Bottle_check(self, *args)


    def find(self, key):
        """find(Bottle self, yarp::os::ConstString const & key) -> Value"""
        return _yarp.Bottle_find(self, key)


    def findGroup(self, *args):
        """
        findGroup(Bottle self, yarp::os::ConstString const & key) -> Bottle
        findGroup(Bottle self, yarp::os::ConstString const & key, yarp::os::ConstString const & comment) -> Bottle
        findGroup(Bottle self, yarp::os::ConstString const & key) -> Bottle
        """
        return _yarp.Bottle_findGroup(self, *args)


    def isNull(self):
        """isNull(Bottle self) -> bool"""
        return _yarp.Bottle_isNull(self)


    def copy(self, alt, first=0, len=-1):
        """
        copy(Bottle self, Bottle alt, int first=0, int len=-1)
        copy(Bottle self, Bottle alt, int first=0)
        copy(Bottle self, Bottle alt)
        """
        return _yarp.Bottle_copy(self, alt, first, len)


    def getNullBottle():
        """getNullBottle() -> Bottle"""
        return _yarp.Bottle_getNullBottle()

    if _newclass:
        getNullBottle = staticmethod(getNullBottle)
    __swig_getmethods__["getNullBottle"] = lambda x: getNullBottle

    def isEqual(self, alt):
        """isEqual(Bottle self, Bottle alt) -> bool"""
        return _yarp.Bottle_isEqual(self, alt)


    def notEqual(self, alt):
        """notEqual(Bottle self, Bottle alt) -> bool"""
        return _yarp.Bottle_notEqual(self, alt)


    def append(self, alt):
        """append(Bottle self, Bottle alt)"""
        return _yarp.Bottle_append(self, alt)


    def tail(self):
        """tail(Bottle self) -> Bottle"""
        return _yarp.Bottle_tail(self)


    def hasChanged(self):
        """hasChanged(Bottle self)"""
        return _yarp.Bottle_hasChanged(self)


    def getSpecialization(self):
        """getSpecialization(Bottle self) -> int"""
        return _yarp.Bottle_getSpecialization(self)


    def describeBottleCode(code):
        """describeBottleCode(int code) -> yarp::os::ConstString"""
        return _yarp.Bottle_describeBottleCode(code)

    if _newclass:
        describeBottleCode = staticmethod(describeBottleCode)
    __swig_getmethods__["describeBottleCode"] = lambda x: describeBottleCode

    def toString(self, *args):
        """
        toString(Bottle self, int x) -> yarp::os::ConstString
        toString(Bottle self) -> std::string
        """
        return _yarp.Bottle_toString(self, *args)

Bottle_swigregister = _yarp.Bottle_swigregister
Bottle_swigregister(Bottle)

def Bottle_getNullBottle():
    """Bottle_getNullBottle() -> Bottle"""
    return _yarp.Bottle_getNullBottle()

def Bottle_describeBottleCode(code):
    """Bottle_describeBottleCode(int code) -> yarp::os::ConstString"""
    return _yarp.Bottle_describeBottleCode(code)

class PortWriterBufferManager(_object):
    """Proxy of C++ yarp::os::PortWriterBufferManager class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PortWriterBufferManager, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PortWriterBufferManager, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_PortWriterBufferManager
    __del__ = lambda self: None

    def onCompletion(self, tracker):
        """onCompletion(PortWriterBufferManager self, void * tracker)"""
        return _yarp.PortWriterBufferManager_onCompletion(self, tracker)

PortWriterBufferManager_swigregister = _yarp.PortWriterBufferManager_swigregister
PortWriterBufferManager_swigregister(PortWriterBufferManager)

class PortWriterWrapper(PortWriter):
    """Proxy of C++ yarp::os::PortWriterWrapper class."""

    __swig_setmethods__ = {}
    for _s in [PortWriter]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, PortWriterWrapper, name, value)
    __swig_getmethods__ = {}
    for _s in [PortWriter]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, PortWriterWrapper, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def getInternal(self):
        """getInternal(PortWriterWrapper self) -> PortWriter"""
        return _yarp.PortWriterWrapper_getInternal(self)

    __swig_destroy__ = _yarp.delete_PortWriterWrapper
    __del__ = lambda self: None
PortWriterWrapper_swigregister = _yarp.PortWriterWrapper_swigregister
PortWriterWrapper_swigregister(PortWriterWrapper)

class PortWriterBufferBase(_object):
    """Proxy of C++ yarp::os::PortWriterBufferBase class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PortWriterBufferBase, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PortWriterBufferBase, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_PortWriterBufferBase
    __del__ = lambda self: None

    def create(self, man, tracker):
        """create(PortWriterBufferBase self, PortWriterBufferManager man, void * tracker) -> PortWriterWrapper"""
        return _yarp.PortWriterBufferBase_create(self, man, tracker)


    def getContent(self):
        """getContent(PortWriterBufferBase self) -> void *"""
        return _yarp.PortWriterBufferBase_getContent(self)


    def releaseContent(self):
        """releaseContent(PortWriterBufferBase self) -> bool"""
        return _yarp.PortWriterBufferBase_releaseContent(self)


    def getCount(self):
        """getCount(PortWriterBufferBase self) -> int"""
        return _yarp.PortWriterBufferBase_getCount(self)


    def attach(self, port):
        """attach(PortWriterBufferBase self, Port port)"""
        return _yarp.PortWriterBufferBase_attach(self, port)


    def detach(self):
        """detach(PortWriterBufferBase self)"""
        return _yarp.PortWriterBufferBase_detach(self)


    def write(self, strict):
        """write(PortWriterBufferBase self, bool strict)"""
        return _yarp.PortWriterBufferBase_write(self, strict)


    def waitForWrite(self):
        """waitForWrite(PortWriterBufferBase self)"""
        return _yarp.PortWriterBufferBase_waitForWrite(self)

PortWriterBufferBase_swigregister = _yarp.PortWriterBufferBase_swigregister
PortWriterBufferBase_swigregister(PortWriterBufferBase)

class Random(_object):
    """Proxy of C++ yarp::os::Random class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Random, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Random, name)
    __repr__ = _swig_repr

    def seed_c(seed):
        """seed_c(int seed)"""
        return _yarp.Random_seed_c(seed)

    if _newclass:
        seed_c = staticmethod(seed_c)
    __swig_getmethods__["seed_c"] = lambda x: seed_c

    def normal(*args):
        """
        normal(double m, double s) -> double
        normal() -> double
        """
        return _yarp.Random_normal(*args)

    if _newclass:
        normal = staticmethod(normal)
    __swig_getmethods__["normal"] = lambda x: normal

    def uniform(*args):
        """
        uniform() -> double
        uniform(int min, int max) -> int
        """
        return _yarp.Random_uniform(*args)

    if _newclass:
        uniform = staticmethod(uniform)
    __swig_getmethods__["uniform"] = lambda x: uniform

    def __init__(self):
        """__init__(yarp::os::Random self) -> Random"""
        this = _yarp.new_Random()
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _yarp.delete_Random
    __del__ = lambda self: None
Random_swigregister = _yarp.Random_swigregister
Random_swigregister(Random)

def Random_seed_c(seed):
    """Random_seed_c(int seed)"""
    return _yarp.Random_seed_c(seed)

def Random_normal(*args):
    """
    normal(double m, double s) -> double
    Random_normal() -> double
    """
    return _yarp.Random_normal(*args)

def Random_uniform(*args):
    """
    uniform() -> double
    Random_uniform(int min, int max) -> int
    """
    return _yarp.Random_uniform(*args)

class Semaphore(_object):
    """Proxy of C++ yarp::os::Semaphore class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Semaphore, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Semaphore, name)
    __repr__ = _swig_repr

    def __init__(self, initialCount=1):
        """
        __init__(yarp::os::Semaphore self, unsigned int initialCount=1) -> Semaphore
        __init__(yarp::os::Semaphore self) -> Semaphore
        """
        this = _yarp.new_Semaphore(initialCount)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _yarp.delete_Semaphore
    __del__ = lambda self: None

    def wait(self):
        """wait(Semaphore self)"""
        return _yarp.Semaphore_wait(self)


    def waitWithTimeout(self, timeoutInSeconds):
        """waitWithTimeout(Semaphore self, double timeoutInSeconds) -> bool"""
        return _yarp.Semaphore_waitWithTimeout(self, timeoutInSeconds)


    def check(self):
        """check(Semaphore self) -> bool"""
        return _yarp.Semaphore_check(self)


    def post(self):
        """post(Semaphore self)"""
        return _yarp.Semaphore_post(self)

Semaphore_swigregister = _yarp.Semaphore_swigregister
Semaphore_swigregister(Semaphore)

class Thread(_object):
    """Proxy of C++ yarp::os::Thread class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Thread, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Thread, name)
    __repr__ = _swig_repr

    def __init__(self):
        """__init__(yarp::os::Thread self) -> Thread"""
        if self.__class__ == Thread:
            _self = None
        else:
            _self = self
        this = _yarp.new_Thread(_self, )
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _yarp.delete_Thread
    __del__ = lambda self: None

    def run(self):
        """run(Thread self)"""
        return _yarp.Thread_run(self)


    def onStop(self):
        """onStop(Thread self)"""
        return _yarp.Thread_onStop(self)


    def start(self):
        """start(Thread self) -> bool"""
        return _yarp.Thread_start(self)


    def stop(self):
        """stop(Thread self) -> bool"""
        return _yarp.Thread_stop(self)


    def beforeStart(self):
        """beforeStart(Thread self)"""
        return _yarp.Thread_beforeStart(self)


    def afterStart(self, success):
        """afterStart(Thread self, bool success)"""
        return _yarp.Thread_afterStart(self, success)


    def threadInit(self):
        """threadInit(Thread self) -> bool"""
        return _yarp.Thread_threadInit(self)


    def threadRelease(self):
        """threadRelease(Thread self)"""
        return _yarp.Thread_threadRelease(self)


    def isStopping(self):
        """isStopping(Thread self) -> bool"""
        return _yarp.Thread_isStopping(self)


    def isRunning(self):
        """isRunning(Thread self) -> bool"""
        return _yarp.Thread_isRunning(self)


    def setOptions(self, stackSize=0):
        """
        setOptions(Thread self, int stackSize=0)
        setOptions(Thread self)
        """
        return _yarp.Thread_setOptions(self, stackSize)


    def getCount():
        """getCount() -> int"""
        return _yarp.Thread_getCount()

    if _newclass:
        getCount = staticmethod(getCount)
    __swig_getmethods__["getCount"] = lambda x: getCount

    def getKey(self):
        """getKey(Thread self) -> long"""
        return _yarp.Thread_getKey(self)


    def getKeyOfCaller():
        """getKeyOfCaller() -> long"""
        return _yarp.Thread_getKeyOfCaller()

    if _newclass:
        getKeyOfCaller = staticmethod(getKeyOfCaller)
    __swig_getmethods__["getKeyOfCaller"] = lambda x: getKeyOfCaller

    def setPriority(self, priority, policy=-1):
        """
        setPriority(Thread self, int priority, int policy=-1) -> int
        setPriority(Thread self, int priority) -> int
        """
        return _yarp.Thread_setPriority(self, priority, policy)


    def getPriority(self):
        """getPriority(Thread self) -> int"""
        return _yarp.Thread_getPriority(self)


    def getPolicy(self):
        """getPolicy(Thread self) -> int"""
        return _yarp.Thread_getPolicy(self)


    def setDefaultStackSize(stackSize):
        """setDefaultStackSize(int stackSize)"""
        return _yarp.Thread_setDefaultStackSize(stackSize)

    if _newclass:
        setDefaultStackSize = staticmethod(setDefaultStackSize)
    __swig_getmethods__["setDefaultStackSize"] = lambda x: setDefaultStackSize

    def join(self, seconds=-1):
        """
        join(Thread self, double seconds=-1) -> bool
        join(Thread self) -> bool
        """
        return _yarp.Thread_join(self, seconds)


    def yield_c():
        """yield_c()"""
        return _yarp.Thread_yield_c()

    if _newclass:
        yield_c = staticmethod(yield_c)
    __swig_getmethods__["yield_c"] = lambda x: yield_c
    def __disown__(self):
        self.this.disown()
        _yarp.disown_Thread(self)
        return weakref_proxy(self)
Thread_swigregister = _yarp.Thread_swigregister
Thread_swigregister(Thread)

def Thread_getCount():
    """Thread_getCount() -> int"""
    return _yarp.Thread_getCount()

def Thread_getKeyOfCaller():
    """Thread_getKeyOfCaller() -> long"""
    return _yarp.Thread_getKeyOfCaller()

def Thread_setDefaultStackSize(stackSize):
    """Thread_setDefaultStackSize(int stackSize)"""
    return _yarp.Thread_setDefaultStackSize(stackSize)

def Thread_yield_c():
    """Thread_yield_c()"""
    return _yarp.Thread_yield_c()

class RateThread(_object):
    """Proxy of C++ yarp::os::RateThread class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, RateThread, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, RateThread, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_RateThread
    __del__ = lambda self: None

    def start(self):
        """start(RateThread self) -> bool"""
        return _yarp.RateThread_start(self)


    def step(self):
        """step(RateThread self) -> bool"""
        return _yarp.RateThread_step(self)


    def stop(self):
        """stop(RateThread self)"""
        return _yarp.RateThread_stop(self)


    def askToStop(self):
        """askToStop(RateThread self)"""
        return _yarp.RateThread_askToStop(self)


    def isRunning(self):
        """isRunning(RateThread self) -> bool"""
        return _yarp.RateThread_isRunning(self)


    def isSuspended(self):
        """isSuspended(RateThread self) -> bool"""
        return _yarp.RateThread_isSuspended(self)


    def setRate(self, period):
        """setRate(RateThread self, int period) -> bool"""
        return _yarp.RateThread_setRate(self, period)


    def getRate(self):
        """getRate(RateThread self) -> double"""
        return _yarp.RateThread_getRate(self)


    def suspend(self):
        """suspend(RateThread self)"""
        return _yarp.RateThread_suspend(self)


    def resume(self):
        """resume(RateThread self)"""
        return _yarp.RateThread_resume(self)


    def resetStat(self):
        """resetStat(RateThread self)"""
        return _yarp.RateThread_resetStat(self)


    def getEstPeriod(self, *args):
        """
        getEstPeriod(RateThread self) -> double
        getEstPeriod(RateThread self, double & av, double & std)
        """
        return _yarp.RateThread_getEstPeriod(self, *args)


    def getIterations(self):
        """getIterations(RateThread self) -> unsigned int"""
        return _yarp.RateThread_getIterations(self)


    def getEstUsed(self, *args):
        """
        getEstUsed(RateThread self) -> double
        getEstUsed(RateThread self, double & av, double & std)
        """
        return _yarp.RateThread_getEstUsed(self, *args)


    def setPriority(self, priority, policy=-1):
        """
        setPriority(RateThread self, int priority, int policy=-1) -> int
        setPriority(RateThread self, int priority) -> int
        """
        return _yarp.RateThread_setPriority(self, priority, policy)


    def getPriority(self):
        """getPriority(RateThread self) -> int"""
        return _yarp.RateThread_getPriority(self)


    def getPolicy(self):
        """getPolicy(RateThread self) -> int"""
        return _yarp.RateThread_getPolicy(self)

RateThread_swigregister = _yarp.RateThread_swigregister
RateThread_swigregister(RateThread)

class SystemRateThread(RateThread):
    """Proxy of C++ yarp::os::SystemRateThread class."""

    __swig_setmethods__ = {}
    for _s in [RateThread]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SystemRateThread, name, value)
    __swig_getmethods__ = {}
    for _s in [RateThread]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, SystemRateThread, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_SystemRateThread
    __del__ = lambda self: None

    def stepSystem(self):
        """stepSystem(SystemRateThread self) -> bool"""
        return _yarp.SystemRateThread_stepSystem(self)

SystemRateThread_swigregister = _yarp.SystemRateThread_swigregister
SystemRateThread_swigregister(SystemRateThread)

class RateThreadWrapper(RateThread):
    """Proxy of C++ yarp::os::RateThreadWrapper class."""

    __swig_setmethods__ = {}
    for _s in [RateThread]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, RateThreadWrapper, name, value)
    __swig_getmethods__ = {}
    for _s in [RateThread]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, RateThreadWrapper, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(yarp::os::RateThreadWrapper self) -> RateThreadWrapper
        __init__(yarp::os::RateThreadWrapper self, Runnable * helper) -> RateThreadWrapper
        __init__(yarp::os::RateThreadWrapper self, Runnable & helper) -> RateThreadWrapper
        """
        this = _yarp.new_RateThreadWrapper(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _yarp.delete_RateThreadWrapper
    __del__ = lambda self: None

    def detach(self):
        """detach(RateThreadWrapper self)"""
        return _yarp.RateThreadWrapper_detach(self)


    def attach(self, *args):
        """
        attach(RateThreadWrapper self, Runnable & helper) -> bool
        attach(RateThreadWrapper self, Runnable * helper) -> bool
        """
        return _yarp.RateThreadWrapper_attach(self, *args)


    def open(self, framerate=-1, polling=False):
        """
        open(RateThreadWrapper self, double framerate=-1, bool polling=False) -> bool
        open(RateThreadWrapper self, double framerate=-1) -> bool
        open(RateThreadWrapper self) -> bool
        """
        return _yarp.RateThreadWrapper_open(self, framerate, polling)


    def close(self):
        """close(RateThreadWrapper self)"""
        return _yarp.RateThreadWrapper_close(self)


    def stop(self):
        """stop(RateThreadWrapper self)"""
        return _yarp.RateThreadWrapper_stop(self)


    def run(self):
        """run(RateThreadWrapper self)"""
        return _yarp.RateThreadWrapper_run(self)


    def threadInit(self):
        """threadInit(RateThreadWrapper self) -> bool"""
        return _yarp.RateThreadWrapper_threadInit(self)


    def threadRelease(self):
        """threadRelease(RateThreadWrapper self)"""
        return _yarp.RateThreadWrapper_threadRelease(self)


    def afterStart(self, success):
        """afterStart(RateThreadWrapper self, bool success)"""
        return _yarp.RateThreadWrapper_afterStart(self, success)


    def beforeStart(self):
        """beforeStart(RateThreadWrapper self)"""
        return _yarp.RateThreadWrapper_beforeStart(self)


    def getAttachment(self):
        """getAttachment(RateThreadWrapper self) -> Runnable *"""
        return _yarp.RateThreadWrapper_getAttachment(self)

RateThreadWrapper_swigregister = _yarp.RateThreadWrapper_swigregister
RateThreadWrapper_swigregister(RateThreadWrapper)


_yarp.YARP_CLOCK_UNINITIALIZED_swigconstant(_yarp)
YARP_CLOCK_UNINITIALIZED = _yarp.YARP_CLOCK_UNINITIALIZED

_yarp.YARP_CLOCK_DEFAULT_swigconstant(_yarp)
YARP_CLOCK_DEFAULT = _yarp.YARP_CLOCK_DEFAULT

_yarp.YARP_CLOCK_SYSTEM_swigconstant(_yarp)
YARP_CLOCK_SYSTEM = _yarp.YARP_CLOCK_SYSTEM

_yarp.YARP_CLOCK_NETWORK_swigconstant(_yarp)
YARP_CLOCK_NETWORK = _yarp.YARP_CLOCK_NETWORK

_yarp.YARP_CLOCK_CUSTOM_swigconstant(_yarp)
YARP_CLOCK_CUSTOM = _yarp.YARP_CLOCK_CUSTOM
class Time(_object):
    """Proxy of C++ yarp::os::Time class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Time, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Time, name)
    __repr__ = _swig_repr

    def delay(seconds):
        """delay(double seconds)"""
        return _yarp.Time_delay(seconds)

    if _newclass:
        delay = staticmethod(delay)
    __swig_getmethods__["delay"] = lambda x: delay

    def now():
        """now() -> double"""
        return _yarp.Time_now()

    if _newclass:
        now = staticmethod(now)
    __swig_getmethods__["now"] = lambda x: now

    def yield_c():
        """yield_c()"""
        return _yarp.Time_yield_c()

    if _newclass:
        yield_c = staticmethod(yield_c)
    __swig_getmethods__["yield_c"] = lambda x: yield_c

    def turboBoost():
        """turboBoost()"""
        return _yarp.Time_turboBoost()

    if _newclass:
        turboBoost = staticmethod(turboBoost)
    __swig_getmethods__["turboBoost"] = lambda x: turboBoost

    def useSystemClock():
        """useSystemClock()"""
        return _yarp.Time_useSystemClock()

    if _newclass:
        useSystemClock = staticmethod(useSystemClock)
    __swig_getmethods__["useSystemClock"] = lambda x: useSystemClock

    def useNetworkClock(*args):
        """
        useNetworkClock(yarp::os::ConstString const & clock, yarp::os::ConstString localPortName)
        useNetworkClock(yarp::os::ConstString const & clock)
        """
        return _yarp.Time_useNetworkClock(*args)

    if _newclass:
        useNetworkClock = staticmethod(useNetworkClock)
    __swig_getmethods__["useNetworkClock"] = lambda x: useNetworkClock

    def useCustomClock(clock):
        """useCustomClock(Clock * clock)"""
        return _yarp.Time_useCustomClock(clock)

    if _newclass:
        useCustomClock = staticmethod(useCustomClock)
    __swig_getmethods__["useCustomClock"] = lambda x: useCustomClock

    def isSystemClock():
        """isSystemClock() -> bool"""
        return _yarp.Time_isSystemClock()

    if _newclass:
        isSystemClock = staticmethod(isSystemClock)
    __swig_getmethods__["isSystemClock"] = lambda x: isSystemClock

    def isNetworkClock():
        """isNetworkClock() -> bool"""
        return _yarp.Time_isNetworkClock()

    if _newclass:
        isNetworkClock = staticmethod(isNetworkClock)
    __swig_getmethods__["isNetworkClock"] = lambda x: isNetworkClock

    def isCustomClock():
        """isCustomClock() -> bool"""
        return _yarp.Time_isCustomClock()

    if _newclass:
        isCustomClock = staticmethod(isCustomClock)
    __swig_getmethods__["isCustomClock"] = lambda x: isCustomClock

    def getClockType():
        """getClockType() -> yarp::os::yarpClockType"""
        return _yarp.Time_getClockType()

    if _newclass:
        getClockType = staticmethod(getClockType)
    __swig_getmethods__["getClockType"] = lambda x: getClockType

    def clockTypeToString(type):
        """clockTypeToString(yarp::os::yarpClockType type) -> yarp::os::ConstString"""
        return _yarp.Time_clockTypeToString(type)

    if _newclass:
        clockTypeToString = staticmethod(clockTypeToString)
    __swig_getmethods__["clockTypeToString"] = lambda x: clockTypeToString

    def isValid():
        """isValid() -> bool"""
        return _yarp.Time_isValid()

    if _newclass:
        isValid = staticmethod(isValid)
    __swig_getmethods__["isValid"] = lambda x: isValid

    def __init__(self):
        """__init__(yarp::os::Time self) -> Time"""
        this = _yarp.new_Time()
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _yarp.delete_Time
    __del__ = lambda self: None
Time_swigregister = _yarp.Time_swigregister
Time_swigregister(Time)

def Time_delay(seconds):
    """Time_delay(double seconds)"""
    return _yarp.Time_delay(seconds)

def Time_now():
    """Time_now() -> double"""
    return _yarp.Time_now()

def Time_yield_c():
    """Time_yield_c()"""
    return _yarp.Time_yield_c()

def Time_turboBoost():
    """Time_turboBoost()"""
    return _yarp.Time_turboBoost()

def Time_useSystemClock():
    """Time_useSystemClock()"""
    return _yarp.Time_useSystemClock()

def Time_useNetworkClock(*args):
    """
    useNetworkClock(yarp::os::ConstString const & clock, yarp::os::ConstString localPortName)
    Time_useNetworkClock(yarp::os::ConstString const & clock)
    """
    return _yarp.Time_useNetworkClock(*args)

def Time_useCustomClock(clock):
    """Time_useCustomClock(Clock * clock)"""
    return _yarp.Time_useCustomClock(clock)

def Time_isSystemClock():
    """Time_isSystemClock() -> bool"""
    return _yarp.Time_isSystemClock()

def Time_isNetworkClock():
    """Time_isNetworkClock() -> bool"""
    return _yarp.Time_isNetworkClock()

def Time_isCustomClock():
    """Time_isCustomClock() -> bool"""
    return _yarp.Time_isCustomClock()

def Time_getClockType():
    """Time_getClockType() -> yarp::os::yarpClockType"""
    return _yarp.Time_getClockType()

def Time_clockTypeToString(type):
    """Time_clockTypeToString(yarp::os::yarpClockType type) -> yarp::os::ConstString"""
    return _yarp.Time_clockTypeToString(type)

def Time_isValid():
    """Time_isValid() -> bool"""
    return _yarp.Time_isValid()

class RFModule(_object):
    """Proxy of C++ yarp::os::RFModule class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, RFModule, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, RFModule, name)
    __repr__ = _swig_repr

    def __init__(self):
        """__init__(yarp::os::RFModule self) -> RFModule"""
        if self.__class__ == RFModule:
            _self = None
        else:
            _self = self
        this = _yarp.new_RFModule(_self, )
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _yarp.delete_RFModule
    __del__ = lambda self: None

    def getPeriod(self):
        """getPeriod(RFModule self) -> double"""
        return _yarp.RFModule_getPeriod(self)


    def updateModule(self):
        """updateModule(RFModule self) -> bool"""
        return _yarp.RFModule_updateModule(self)


    def runModule(self, *args):
        """
        runModule(RFModule self) -> int
        runModule(RFModule self, ResourceFinder rf) -> int
        """
        return _yarp.RFModule_runModule(self, *args)


    def runModuleThreaded(self, *args):
        """
        runModuleThreaded(RFModule self) -> int
        runModuleThreaded(RFModule self, ResourceFinder rf) -> int
        """
        return _yarp.RFModule_runModuleThreaded(self, *args)


    def configure(self, rf):
        """configure(RFModule self, ResourceFinder rf) -> bool"""
        return _yarp.RFModule_configure(self, rf)


    def respond(self, command, reply):
        """respond(RFModule self, Bottle command, Bottle reply) -> bool"""
        return _yarp.RFModule_respond(self, command, reply)


    def attach(self, source):
        """attach(RFModule self, Port source) -> bool"""
        return _yarp.RFModule_attach(self, source)


    def attach_rpc_server(self, source):
        """attach_rpc_server(RFModule self, RpcServer source) -> bool"""
        return _yarp.RFModule_attach_rpc_server(self, source)


    def attachTerminal(self):
        """attachTerminal(RFModule self) -> bool"""
        return _yarp.RFModule_attachTerminal(self)


    def detachTerminal(self):
        """detachTerminal(RFModule self) -> bool"""
        return _yarp.RFModule_detachTerminal(self)


    def interruptModule(self):
        """interruptModule(RFModule self) -> bool"""
        return _yarp.RFModule_interruptModule(self)


    def close(self):
        """close(RFModule self) -> bool"""
        return _yarp.RFModule_close(self)


    def stopModule(self, wait=False):
        """
        stopModule(RFModule self, bool wait=False)
        stopModule(RFModule self)
        """
        return _yarp.RFModule_stopModule(self, wait)


    def isStopping(self):
        """isStopping(RFModule self) -> bool"""
        return _yarp.RFModule_isStopping(self)


    def joinModule(self, seconds=-1):
        """
        joinModule(RFModule self, double seconds=-1) -> bool
        joinModule(RFModule self) -> bool
        """
        return _yarp.RFModule_joinModule(self, seconds)


    def getName(self, *args):
        """
        getName(RFModule self, yarp::os::ConstString const & subName) -> yarp::os::ConstString
        getName(RFModule self) -> yarp::os::ConstString
        """
        return _yarp.RFModule_getName(self, *args)


    def setName(self, name):
        """setName(RFModule self, char const * name)"""
        return _yarp.RFModule_setName(self, name)


    def safeRespond(self, command, reply):
        """safeRespond(RFModule self, Bottle command, Bottle reply) -> bool"""
        return _yarp.RFModule_safeRespond(self, command, reply)

    def __disown__(self):
        self.this.disown()
        _yarp.disown_RFModule(self)
        return weakref_proxy(self)
RFModule_swigregister = _yarp.RFModule_swigregister
RFModule_swigregister(RFModule)

class Stamp(Portable):
    """Proxy of C++ yarp::os::Stamp class."""

    __swig_setmethods__ = {}
    for _s in [Portable]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Stamp, name, value)
    __swig_getmethods__ = {}
    for _s in [Portable]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Stamp, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(yarp::os::Stamp self) -> Stamp
        __init__(yarp::os::Stamp self, int count, double time) -> Stamp
        """
        this = _yarp.new_Stamp(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def getCount(self):
        """getCount(Stamp self) -> int"""
        return _yarp.Stamp_getCount(self)


    def getTime(self):
        """getTime(Stamp self) -> double"""
        return _yarp.Stamp_getTime(self)


    def isValid(self):
        """isValid(Stamp self) -> bool"""
        return _yarp.Stamp_isValid(self)


    def getMaxCount(self):
        """getMaxCount(Stamp self) -> int"""
        return _yarp.Stamp_getMaxCount(self)


    def update(self, *args):
        """
        update(Stamp self)
        update(Stamp self, double time)
        """
        return _yarp.Stamp_update(self, *args)


    def read(self, connection):
        """read(Stamp self, ConnectionReader connection) -> bool"""
        return _yarp.Stamp_read(self, connection)


    def write(self, connection):
        """write(Stamp self, ConnectionWriter connection) -> bool"""
        return _yarp.Stamp_write(self, connection)

    __swig_destroy__ = _yarp.delete_Stamp
    __del__ = lambda self: None
Stamp_swigregister = _yarp.Stamp_swigregister
Stamp_swigregister(Stamp)

class Stamped(_object):
    """Proxy of C++ yarp::os::Stamped class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Stamped, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Stamped, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_Stamped
    __del__ = lambda self: None

    def getStamp(self):
        """getStamp(Stamped self) -> Stamp"""
        return _yarp.Stamped_getStamp(self)

Stamped_swigregister = _yarp.Stamped_swigregister
Stamped_swigregister(Stamped)

class NameStore(_object):
    """Proxy of C++ yarp::os::NameStore class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, NameStore, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, NameStore, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_NameStore
    __del__ = lambda self: None

    def query(self, name):
        """query(NameStore self, yarp::os::ConstString const & name) -> Contact"""
        return _yarp.NameStore_query(self, name)


    def announce(self, name, activity):
        """announce(NameStore self, yarp::os::ConstString const & name, int activity) -> bool"""
        return _yarp.NameStore_announce(self, name, activity)


    def process(self, arg2, out, source):
        """process(NameStore self, PortWriter arg2, PortReader out, Contact source) -> bool"""
        return _yarp.NameStore_process(self, arg2, out, source)

NameStore_swigregister = _yarp.NameStore_swigregister
NameStore_swigregister(NameStore)

class ContactStyle(_object):
    """Proxy of C++ yarp::os::ContactStyle class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ContactStyle, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ContactStyle, name)
    __repr__ = _swig_repr
    __swig_setmethods__["admin"] = _yarp.ContactStyle_admin_set
    __swig_getmethods__["admin"] = _yarp.ContactStyle_admin_get
    if _newclass:
        admin = _swig_property(_yarp.ContactStyle_admin_get, _yarp.ContactStyle_admin_set)
    __swig_setmethods__["quiet"] = _yarp.ContactStyle_quiet_set
    __swig_getmethods__["quiet"] = _yarp.ContactStyle_quiet_get
    if _newclass:
        quiet = _swig_property(_yarp.ContactStyle_quiet_get, _yarp.ContactStyle_quiet_set)
    __swig_setmethods__["verboseOnSuccess"] = _yarp.ContactStyle_verboseOnSuccess_set
    __swig_getmethods__["verboseOnSuccess"] = _yarp.ContactStyle_verboseOnSuccess_get
    if _newclass:
        verboseOnSuccess = _swig_property(_yarp.ContactStyle_verboseOnSuccess_get, _yarp.ContactStyle_verboseOnSuccess_set)
    __swig_setmethods__["timeout"] = _yarp.ContactStyle_timeout_set
    __swig_getmethods__["timeout"] = _yarp.ContactStyle_timeout_get
    if _newclass:
        timeout = _swig_property(_yarp.ContactStyle_timeout_get, _yarp.ContactStyle_timeout_set)
    __swig_setmethods__["carrier"] = _yarp.ContactStyle_carrier_set
    __swig_getmethods__["carrier"] = _yarp.ContactStyle_carrier_get
    if _newclass:
        carrier = _swig_property(_yarp.ContactStyle_carrier_get, _yarp.ContactStyle_carrier_set)
    __swig_setmethods__["expectReply"] = _yarp.ContactStyle_expectReply_set
    __swig_getmethods__["expectReply"] = _yarp.ContactStyle_expectReply_get
    if _newclass:
        expectReply = _swig_property(_yarp.ContactStyle_expectReply_get, _yarp.ContactStyle_expectReply_set)
    __swig_setmethods__["persistent"] = _yarp.ContactStyle_persistent_set
    __swig_getmethods__["persistent"] = _yarp.ContactStyle_persistent_get
    if _newclass:
        persistent = _swig_property(_yarp.ContactStyle_persistent_get, _yarp.ContactStyle_persistent_set)
    OPENENDED = _yarp.ContactStyle_OPENENDED
    END_WITH_FROM_PORT = _yarp.ContactStyle_END_WITH_FROM_PORT
    END_WITH_TO_PORT = _yarp.ContactStyle_END_WITH_TO_PORT
    NO_PERSISTENCE = _yarp.ContactStyle_NO_PERSISTENCE
    __swig_setmethods__["persistenceType"] = _yarp.ContactStyle_persistenceType_set
    __swig_getmethods__["persistenceType"] = _yarp.ContactStyle_persistenceType_get
    if _newclass:
        persistenceType = _swig_property(_yarp.ContactStyle_persistenceType_get, _yarp.ContactStyle_persistenceType_set)

    def __init__(self):
        """__init__(yarp::os::ContactStyle self) -> ContactStyle"""
        this = _yarp.new_ContactStyle()
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _yarp.delete_ContactStyle
    __del__ = lambda self: None
ContactStyle_swigregister = _yarp.ContactStyle_swigregister
ContactStyle_swigregister(ContactStyle)

class ResourceFinder(Searchable):
    """Proxy of C++ yarp::os::ResourceFinder class."""

    __swig_setmethods__ = {}
    for _s in [Searchable]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ResourceFinder, name, value)
    __swig_getmethods__ = {}
    for _s in [Searchable]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ResourceFinder, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(yarp::os::ResourceFinder self) -> ResourceFinder
        __init__(yarp::os::ResourceFinder self, ResourceFinder alt) -> ResourceFinder
        """
        this = _yarp.new_ResourceFinder(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _yarp.delete_ResourceFinder
    __del__ = lambda self: None

    def setVerbose(self, verbose=True):
        """
        setVerbose(ResourceFinder self, bool verbose=True) -> bool
        setVerbose(ResourceFinder self) -> bool
        """
        return _yarp.ResourceFinder_setVerbose(self, verbose)


    def setQuiet(self, quiet=True):
        """
        setQuiet(ResourceFinder self, bool quiet=True) -> bool
        setQuiet(ResourceFinder self) -> bool
        """
        return _yarp.ResourceFinder_setQuiet(self, quiet)


    def configure(self, argc, skipFirstArgument=True):
        """
        configure(ResourceFinder self, int argc, bool skipFirstArgument=True) -> bool
        configure(ResourceFinder self, int argc) -> bool
        """
        return _yarp.ResourceFinder_configure(self, argc, skipFirstArgument)


    def setDefaultContext(self, *args):
        """
        setDefaultContext(ResourceFinder self, char const * contextName) -> bool
        setDefaultContext(ResourceFinder self, yarp::os::ConstString const & contextName) -> bool
        """
        return _yarp.ResourceFinder_setDefaultContext(self, *args)


    def setContext(self, contextName):
        """setContext(ResourceFinder self, char const * contextName) -> bool"""
        return _yarp.ResourceFinder_setContext(self, contextName)


    def setDefault(self, *args):
        """
        setDefault(ResourceFinder self, char const * key, yarp::os::ConstString const & val) -> bool
        setDefault(ResourceFinder self, char const * key, Value val) -> bool
        """
        return _yarp.ResourceFinder_setDefault(self, *args)


    def setDefaultConfigFile(self, fname):
        """setDefaultConfigFile(ResourceFinder self, char const * fname) -> bool"""
        return _yarp.ResourceFinder_setDefaultConfigFile(self, fname)


    def getContext(self):
        """getContext(ResourceFinder self) -> yarp::os::ConstString"""
        return _yarp.ResourceFinder_getContext(self)


    def getContexts(self):
        """getContexts(ResourceFinder self) -> Bottle"""
        return _yarp.ResourceFinder_getContexts(self)


    def find(self, key):
        """find(ResourceFinder self, yarp::os::ConstString const & key) -> Value"""
        return _yarp.ResourceFinder_find(self, key)


    def isNull(self):
        """isNull(ResourceFinder self) -> bool"""
        return _yarp.ResourceFinder_isNull(self)


    def toString_c(self):
        """toString_c(ResourceFinder self) -> yarp::os::ConstString"""
        return _yarp.ResourceFinder_toString_c(self)


    def findNestedResourceFinder(self, key):
        """findNestedResourceFinder(ResourceFinder self, char const * key) -> ResourceFinder"""
        return _yarp.ResourceFinder_findNestedResourceFinder(self, key)


    def isConfigured(self):
        """isConfigured(ResourceFinder self) -> bool"""
        return _yarp.ResourceFinder_isConfigured(self)


    def getResourceFinderSingleton():
        """getResourceFinderSingleton() -> ResourceFinder"""
        return _yarp.ResourceFinder_getResourceFinderSingleton()

    if _newclass:
        getResourceFinderSingleton = staticmethod(getResourceFinderSingleton)
    __swig_getmethods__["getResourceFinderSingleton"] = lambda x: getResourceFinderSingleton

    def check(self, *args):
        """
        check(ResourceFinder self, yarp::os::ConstString const & key) -> bool
        check(ResourceFinder self, yarp::os::ConstString const & key, yarp::os::ConstString const & comment) -> bool
        check(ResourceFinder self, yarp::os::ConstString const & key, Value fallback, yarp::os::ConstString const & comment) -> Value
        check(ResourceFinder self, yarp::os::ConstString const & key, Value fallback) -> Value
        """
        return _yarp.ResourceFinder_check(self, *args)


    def findGroup(self, *args):
        """
        findGroup(ResourceFinder self, yarp::os::ConstString const & key) -> Bottle
        findGroup(ResourceFinder self, yarp::os::ConstString const & key, yarp::os::ConstString const & comment) -> Bottle
        """
        return _yarp.ResourceFinder_findGroup(self, *args)


    def getDataHome():
        """getDataHome() -> yarp::os::ConstString"""
        return _yarp.ResourceFinder_getDataHome()

    if _newclass:
        getDataHome = staticmethod(getDataHome)
    __swig_getmethods__["getDataHome"] = lambda x: getDataHome

    def getDataHomeNoCreate():
        """getDataHomeNoCreate() -> yarp::os::ConstString"""
        return _yarp.ResourceFinder_getDataHomeNoCreate()

    if _newclass:
        getDataHomeNoCreate = staticmethod(getDataHomeNoCreate)
    __swig_getmethods__["getDataHomeNoCreate"] = lambda x: getDataHomeNoCreate

    def getConfigHome():
        """getConfigHome() -> yarp::os::ConstString"""
        return _yarp.ResourceFinder_getConfigHome()

    if _newclass:
        getConfigHome = staticmethod(getConfigHome)
    __swig_getmethods__["getConfigHome"] = lambda x: getConfigHome

    def getConfigHomeNoCreate():
        """getConfigHomeNoCreate() -> yarp::os::ConstString"""
        return _yarp.ResourceFinder_getConfigHomeNoCreate()

    if _newclass:
        getConfigHomeNoCreate = staticmethod(getConfigHomeNoCreate)
    __swig_getmethods__["getConfigHomeNoCreate"] = lambda x: getConfigHomeNoCreate

    def getHomeContextPath(self):
        """getHomeContextPath(ResourceFinder self) -> yarp::os::ConstString"""
        return _yarp.ResourceFinder_getHomeContextPath(self)


    def getHomeRobotPath(self):
        """getHomeRobotPath(ResourceFinder self) -> yarp::os::ConstString"""
        return _yarp.ResourceFinder_getHomeRobotPath(self)


    def getDataDirs():
        """getDataDirs() -> Bottle"""
        return _yarp.ResourceFinder_getDataDirs()

    if _newclass:
        getDataDirs = staticmethod(getDataDirs)
    __swig_getmethods__["getDataDirs"] = lambda x: getDataDirs

    def getConfigDirs():
        """getConfigDirs() -> Bottle"""
        return _yarp.ResourceFinder_getConfigDirs()

    if _newclass:
        getConfigDirs = staticmethod(getConfigDirs)
    __swig_getmethods__["getConfigDirs"] = lambda x: getConfigDirs

    def findPaths(self, *args):
        """
        findPaths(ResourceFinder self, yarp::os::ConstString const & name) -> Bottle
        findPaths(ResourceFinder self, yarp::os::ConstString const & name, ResourceFinderOptions const & options) -> Bottle
        """
        return _yarp.ResourceFinder_findPaths(self, *args)


    def findPath(self, *args):
        """
        findPath(ResourceFinder self, yarp::os::ConstString const & name) -> yarp::os::ConstString
        findPath(ResourceFinder self) -> yarp::os::ConstString
        findPath(ResourceFinder self, yarp::os::ConstString const & name, ResourceFinderOptions const & options) -> yarp::os::ConstString
        """
        return _yarp.ResourceFinder_findPath(self, *args)


    def findFile(self, *args):
        """
        findFile(ResourceFinder self, yarp::os::ConstString const & name) -> yarp::os::ConstString
        findFile(ResourceFinder self, yarp::os::ConstString const & name, ResourceFinderOptions const & options) -> yarp::os::ConstString
        """
        return _yarp.ResourceFinder_findFile(self, *args)


    def findFileByName(self, *args):
        """
        findFileByName(ResourceFinder self, yarp::os::ConstString const & name) -> yarp::os::ConstString
        findFileByName(ResourceFinder self, yarp::os::ConstString const & name, ResourceFinderOptions const & options) -> yarp::os::ConstString
        """
        return _yarp.ResourceFinder_findFileByName(self, *args)


    def readConfig(self, config, key, options):
        """readConfig(ResourceFinder self, Property config, yarp::os::ConstString const & key, ResourceFinderOptions const & options) -> bool"""
        return _yarp.ResourceFinder_readConfig(self, config, key, options)

ResourceFinder_swigregister = _yarp.ResourceFinder_swigregister
ResourceFinder_swigregister(ResourceFinder)

def ResourceFinder_getResourceFinderSingleton():
    """ResourceFinder_getResourceFinderSingleton() -> ResourceFinder"""
    return _yarp.ResourceFinder_getResourceFinderSingleton()

def ResourceFinder_getDataHome():
    """ResourceFinder_getDataHome() -> yarp::os::ConstString"""
    return _yarp.ResourceFinder_getDataHome()

def ResourceFinder_getDataHomeNoCreate():
    """ResourceFinder_getDataHomeNoCreate() -> yarp::os::ConstString"""
    return _yarp.ResourceFinder_getDataHomeNoCreate()

def ResourceFinder_getConfigHome():
    """ResourceFinder_getConfigHome() -> yarp::os::ConstString"""
    return _yarp.ResourceFinder_getConfigHome()

def ResourceFinder_getConfigHomeNoCreate():
    """ResourceFinder_getConfigHomeNoCreate() -> yarp::os::ConstString"""
    return _yarp.ResourceFinder_getConfigHomeNoCreate()

def ResourceFinder_getDataDirs():
    """ResourceFinder_getDataDirs() -> Bottle"""
    return _yarp.ResourceFinder_getDataDirs()

def ResourceFinder_getConfigDirs():
    """ResourceFinder_getConfigDirs() -> Bottle"""
    return _yarp.ResourceFinder_getConfigDirs()

class RpcServer(AbstractContactable):
    """Proxy of C++ yarp::os::RpcServer class."""

    __swig_setmethods__ = {}
    for _s in [AbstractContactable]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, RpcServer, name, value)
    __swig_getmethods__ = {}
    for _s in [AbstractContactable]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, RpcServer, name)
    __repr__ = _swig_repr

    def open(self, *args):
        """
        open(RpcServer self) -> bool
        open(RpcServer self, yarp::os::ConstString const & name) -> bool
        open(RpcServer self, Contact contact, bool registerName=True) -> bool
        open(RpcServer self, Contact contact) -> bool
        """
        return _yarp.RpcServer_open(self, *args)


    def __init__(self):
        """__init__(yarp::os::RpcServer self) -> RpcServer"""
        this = _yarp.new_RpcServer()
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _yarp.delete_RpcServer
    __del__ = lambda self: None

    def write(self, *args):
        """
        write(RpcServer self, PortWriter writer, PortWriter callback=None) -> bool
        write(RpcServer self, PortWriter writer) -> bool
        write(RpcServer self, PortWriter writer, PortReader reader, PortWriter callback=None) -> bool
        write(RpcServer self, PortWriter writer, PortReader reader) -> bool
        """
        return _yarp.RpcServer_write(self, *args)


    def read(self, reader, willReply=True):
        """
        read(RpcServer self, PortReader reader, bool willReply=True) -> bool
        read(RpcServer self, PortReader reader) -> bool
        """
        return _yarp.RpcServer_read(self, reader, willReply)


    def setInputMode(self, expectInput):
        """setInputMode(RpcServer self, bool expectInput)"""
        return _yarp.RpcServer_setInputMode(self, expectInput)


    def setOutputMode(self, expectOutput):
        """setOutputMode(RpcServer self, bool expectOutput)"""
        return _yarp.RpcServer_setOutputMode(self, expectOutput)


    def setRpcMode(self, expectRpc):
        """setRpcMode(RpcServer self, bool expectRpc)"""
        return _yarp.RpcServer_setRpcMode(self, expectRpc)


    def asPort(self, *args):
        """
        asPort(RpcServer self) -> Port
        asPort(RpcServer self) -> Port
        """
        return _yarp.RpcServer_asPort(self, *args)

RpcServer_swigregister = _yarp.RpcServer_swigregister
RpcServer_swigregister(RpcServer)

class RpcClient(AbstractContactable):
    """Proxy of C++ yarp::os::RpcClient class."""

    __swig_setmethods__ = {}
    for _s in [AbstractContactable]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, RpcClient, name, value)
    __swig_getmethods__ = {}
    for _s in [AbstractContactable]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, RpcClient, name)
    __repr__ = _swig_repr

    def __init__(self):
        """__init__(yarp::os::RpcClient self) -> RpcClient"""
        this = _yarp.new_RpcClient()
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _yarp.delete_RpcClient
    __del__ = lambda self: None

    def read(self, reader, willReply=False):
        """
        read(RpcClient self, PortReader reader, bool willReply=False) -> bool
        read(RpcClient self, PortReader reader) -> bool
        """
        return _yarp.RpcClient_read(self, reader, willReply)


    def reply(self, writer):
        """reply(RpcClient self, PortWriter writer) -> bool"""
        return _yarp.RpcClient_reply(self, writer)


    def replyAndDrop(self, writer):
        """replyAndDrop(RpcClient self, PortWriter writer) -> bool"""
        return _yarp.RpcClient_replyAndDrop(self, writer)


    def setInputMode(self, expectInput):
        """setInputMode(RpcClient self, bool expectInput)"""
        return _yarp.RpcClient_setInputMode(self, expectInput)


    def setOutputMode(self, expectOutput):
        """setOutputMode(RpcClient self, bool expectOutput)"""
        return _yarp.RpcClient_setOutputMode(self, expectOutput)


    def setRpcMode(self, expectRpc):
        """setRpcMode(RpcClient self, bool expectRpc)"""
        return _yarp.RpcClient_setRpcMode(self, expectRpc)


    def asPort(self, *args):
        """
        asPort(RpcClient self) -> Port
        asPort(RpcClient self) -> Port
        """
        return _yarp.RpcClient_asPort(self, *args)


    def write(self, data1, data2):
        """write(RpcClient self, Bottle data1, Bottle data2) -> bool"""
        return _yarp.RpcClient_write(self, data1, data2)

RpcClient_swigregister = _yarp.RpcClient_swigregister
RpcClient_swigregister(RpcClient)

class DummyConnector(_object):
    """Proxy of C++ yarp::os::DummyConnector class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, DummyConnector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, DummyConnector, name)
    __repr__ = _swig_repr

    def __init__(self):
        """__init__(yarp::os::DummyConnector self) -> DummyConnector"""
        this = _yarp.new_DummyConnector()
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _yarp.delete_DummyConnector
    __del__ = lambda self: None

    def setTextMode(self, textmode):
        """setTextMode(DummyConnector self, bool textmode)"""
        return _yarp.DummyConnector_setTextMode(self, textmode)


    def getCleanWriter(self):
        """getCleanWriter(DummyConnector self) -> ConnectionWriter"""
        return _yarp.DummyConnector_getCleanWriter(self)


    def getWriter(self):
        """getWriter(DummyConnector self) -> ConnectionWriter"""
        return _yarp.DummyConnector_getWriter(self)


    def getReader(self):
        """getReader(DummyConnector self) -> ConnectionReader"""
        return _yarp.DummyConnector_getReader(self)


    def reset(self):
        """reset(DummyConnector self)"""
        return _yarp.DummyConnector_reset(self)

DummyConnector_swigregister = _yarp.DummyConnector_swigregister
DummyConnector_swigregister(DummyConnector)

class Things(_object):
    """Proxy of C++ yarp::os::Things class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Things, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Things, name)
    __repr__ = _swig_repr

    def __init__(self):
        """__init__(yarp::os::Things self) -> Things"""
        this = _yarp.new_Things()
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _yarp.delete_Things
    __del__ = lambda self: None

    def setPortWriter(self, writer):
        """setPortWriter(Things self, PortWriter writer)"""
        return _yarp.Things_setPortWriter(self, writer)


    def getPortWriter(self):
        """getPortWriter(Things self) -> PortWriter"""
        return _yarp.Things_getPortWriter(self)


    def setPortReader(self, reader):
        """setPortReader(Things self, PortReader reader)"""
        return _yarp.Things_setPortReader(self, reader)


    def getPortReader(self):
        """getPortReader(Things self) -> PortReader"""
        return _yarp.Things_getPortReader(self)


    def setConnectionReader(self, reader):
        """setConnectionReader(Things self, ConnectionReader reader) -> bool"""
        return _yarp.Things_setConnectionReader(self, reader)


    def write(self, connection):
        """write(Things self, ConnectionWriter connection) -> bool"""
        return _yarp.Things_write(self, connection)


    def reset(self):
        """reset(Things self)"""
        return _yarp.Things_reset(self)


    def hasBeenRead(self):
        """hasBeenRead(Things self) -> bool"""
        return _yarp.Things_hasBeenRead(self)


    def asValue(self):
        """asValue(Things self) -> Value"""
        return _yarp.Things_asValue(self)


    def asBottle(self):
        """asBottle(Things self) -> Bottle"""
        return _yarp.Things_asBottle(self)


    def asProperty(self):
        """asProperty(Things self) -> Property"""
        return _yarp.Things_asProperty(self)


    def asVector(self):
        """asVector(Things self) -> Vector"""
        return _yarp.Things_asVector(self)


    def asMatrix(self):
        """asMatrix(Things self) -> Matrix"""
        return _yarp.Things_asMatrix(self)


    def asImage(self):
        """asImage(Things self) -> Image"""
        return _yarp.Things_asImage(self)


    def asImageOfPixelRgb(self):
        """asImageOfPixelRgb(Things self) -> ImageRgb"""
        return _yarp.Things_asImageOfPixelRgb(self)


    def asImageOfPixelBgr(self):
        """asImageOfPixelBgr(Things self) -> yarp::sig::ImageOf< yarp::sig::PixelBgr > *"""
        return _yarp.Things_asImageOfPixelBgr(self)


    def asImageOfPixelMono(self):
        """asImageOfPixelMono(Things self) -> ImageMono"""
        return _yarp.Things_asImageOfPixelMono(self)

Things_swigregister = _yarp.Things_swigregister
Things_swigregister(Things)

class QosStyle(_object):
    """Proxy of C++ yarp::os::QosStyle class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, QosStyle, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, QosStyle, name)
    __repr__ = _swig_repr
    PacketPriorityInvalid = _yarp.QosStyle_PacketPriorityInvalid
    PacketPriorityNormal = _yarp.QosStyle_PacketPriorityNormal
    PacketPriorityLow = _yarp.QosStyle_PacketPriorityLow
    PacketPriorityHigh = _yarp.QosStyle_PacketPriorityHigh
    PacketPriorityCritical = _yarp.QosStyle_PacketPriorityCritical
    PacketPriorityUndefined = _yarp.QosStyle_PacketPriorityUndefined
    DSCP_Invalid = _yarp.QosStyle_DSCP_Invalid
    DSCP_CS0 = _yarp.QosStyle_DSCP_CS0
    DSCP_CS1 = _yarp.QosStyle_DSCP_CS1
    DSCP_CS2 = _yarp.QosStyle_DSCP_CS2
    DSCP_CS3 = _yarp.QosStyle_DSCP_CS3
    DSCP_CS4 = _yarp.QosStyle_DSCP_CS4
    DSCP_CS5 = _yarp.QosStyle_DSCP_CS5
    DSCP_CS6 = _yarp.QosStyle_DSCP_CS6
    DSCP_CS7 = _yarp.QosStyle_DSCP_CS7
    DSCP_AF11 = _yarp.QosStyle_DSCP_AF11
    DSCP_AF12 = _yarp.QosStyle_DSCP_AF12
    DSCP_AF13 = _yarp.QosStyle_DSCP_AF13
    DSCP_AF21 = _yarp.QosStyle_DSCP_AF21
    DSCP_AF22 = _yarp.QosStyle_DSCP_AF22
    DSCP_AF23 = _yarp.QosStyle_DSCP_AF23
    DSCP_AF31 = _yarp.QosStyle_DSCP_AF31
    DSCP_AF32 = _yarp.QosStyle_DSCP_AF32
    DSCP_AF33 = _yarp.QosStyle_DSCP_AF33
    DSCP_AF41 = _yarp.QosStyle_DSCP_AF41
    DSCP_AF42 = _yarp.QosStyle_DSCP_AF42
    DSCP_AF43 = _yarp.QosStyle_DSCP_AF43
    DSCP_VA = _yarp.QosStyle_DSCP_VA
    DSCP_EF = _yarp.QosStyle_DSCP_EF
    DSCP_Undefined = _yarp.QosStyle_DSCP_Undefined

    def __init__(self):
        """__init__(yarp::os::QosStyle self) -> QosStyle"""
        this = _yarp.new_QosStyle()
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def setPacketPriorityByDscp(self, dscp):
        """setPacketPriorityByDscp(QosStyle self, yarp::os::QosStyle::PacketPriorityDSCP dscp)"""
        return _yarp.QosStyle_setPacketPriorityByDscp(self, dscp)


    def setPacketPriorityByLevel(self, level):
        """setPacketPriorityByLevel(QosStyle self, yarp::os::QosStyle::PacketPriorityLevel level)"""
        return _yarp.QosStyle_setPacketPriorityByLevel(self, level)


    def setPacketPrioritybyTOS(self, tos):
        """setPacketPrioritybyTOS(QosStyle self, int tos)"""
        return _yarp.QosStyle_setPacketPrioritybyTOS(self, tos)


    def setPacketPriority(self, priority):
        """setPacketPriority(QosStyle self, yarp::os::ConstString const & priority) -> bool"""
        return _yarp.QosStyle_setPacketPriority(self, priority)


    def setThreadPriority(self, priority):
        """setThreadPriority(QosStyle self, int priority)"""
        return _yarp.QosStyle_setThreadPriority(self, priority)


    def setThreadPolicy(self, policy):
        """setThreadPolicy(QosStyle self, int policy)"""
        return _yarp.QosStyle_setThreadPolicy(self, policy)


    def getPacketPriorityAsTOS(self):
        """getPacketPriorityAsTOS(QosStyle self) -> int"""
        return _yarp.QosStyle_getPacketPriorityAsTOS(self)


    def getPacketPriorityAsDSCP(self):
        """getPacketPriorityAsDSCP(QosStyle self) -> yarp::os::QosStyle::PacketPriorityDSCP"""
        return _yarp.QosStyle_getPacketPriorityAsDSCP(self)


    def getPacketPriorityAsLevel(self):
        """getPacketPriorityAsLevel(QosStyle self) -> yarp::os::QosStyle::PacketPriorityLevel"""
        return _yarp.QosStyle_getPacketPriorityAsLevel(self)


    def getThreadPriority(self):
        """getThreadPriority(QosStyle self) -> int"""
        return _yarp.QosStyle_getThreadPriority(self)


    def getThreadPolicy(self):
        """getThreadPolicy(QosStyle self) -> int"""
        return _yarp.QosStyle_getThreadPolicy(self)


    def getDSCPByVocab(vocab):
        """getDSCPByVocab(int vocab) -> yarp::os::QosStyle::PacketPriorityDSCP"""
        return _yarp.QosStyle_getDSCPByVocab(vocab)

    if _newclass:
        getDSCPByVocab = staticmethod(getDSCPByVocab)
    __swig_getmethods__["getDSCPByVocab"] = lambda x: getDSCPByVocab

    def getLevelByVocab(vocab):
        """getLevelByVocab(int vocab) -> yarp::os::QosStyle::PacketPriorityLevel"""
        return _yarp.QosStyle_getLevelByVocab(vocab)

    if _newclass:
        getLevelByVocab = staticmethod(getLevelByVocab)
    __swig_getmethods__["getLevelByVocab"] = lambda x: getLevelByVocab
    __swig_destroy__ = _yarp.delete_QosStyle
    __del__ = lambda self: None
QosStyle_swigregister = _yarp.QosStyle_swigregister
QosStyle_swigregister(QosStyle)

def QosStyle_getDSCPByVocab(vocab):
    """QosStyle_getDSCPByVocab(int vocab) -> yarp::os::QosStyle::PacketPriorityDSCP"""
    return _yarp.QosStyle_getDSCPByVocab(vocab)

def QosStyle_getLevelByVocab(vocab):
    """QosStyle_getLevelByVocab(int vocab) -> yarp::os::QosStyle::PacketPriorityLevel"""
    return _yarp.QosStyle_getLevelByVocab(vocab)

class Log(_object):
    """Proxy of C++ yarp::os::Log class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Log, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Log, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(yarp::os::Log self, char const * file, unsigned int const line, char const * func) -> Log
        __init__(yarp::os::Log self) -> Log
        """
        this = _yarp.new_Log(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _yarp.delete_Log
    __del__ = lambda self: None
    TraceType = _yarp.Log_TraceType
    DebugType = _yarp.Log_DebugType
    InfoType = _yarp.Log_InfoType
    WarningType = _yarp.Log_WarningType
    ErrorType = _yarp.Log_ErrorType
    FatalType = _yarp.Log_FatalType

    def trace(self, *args):
        """
        trace(Log self, char const * msg)
        trace(Log self) -> LogStream
        """
        return _yarp.Log_trace(self, *args)


    def debug(self, *args):
        """
        debug(Log self, char const * msg)
        debug(Log self) -> LogStream
        """
        return _yarp.Log_debug(self, *args)


    def info(self, *args):
        """
        info(Log self, char const * msg)
        info(Log self) -> LogStream
        """
        return _yarp.Log_info(self, *args)


    def warning(self, *args):
        """
        warning(Log self, char const * msg)
        warning(Log self) -> LogStream
        """
        return _yarp.Log_warning(self, *args)


    def error(self, *args):
        """
        error(Log self, char const * msg)
        error(Log self) -> LogStream
        """
        return _yarp.Log_error(self, *args)


    def fatal(self, *args):
        """
        fatal(Log self, char const * msg)
        fatal(Log self) -> LogStream
        """
        return _yarp.Log_fatal(self, *args)


    def setLogCallback(arg1):
        """setLogCallback(yarp::os::Log::LogCallback arg1)"""
        return _yarp.Log_setLogCallback(arg1)

    if _newclass:
        setLogCallback = staticmethod(setLogCallback)
    __swig_getmethods__["setLogCallback"] = lambda x: setLogCallback
Log_swigregister = _yarp.Log_swigregister
Log_swigregister(Log)

def Log_setLogCallback(arg2):
    """Log_setLogCallback(yarp::os::Log::LogCallback arg2)"""
    return _yarp.Log_setLogCallback(arg2)


def yarp_print_trace(out, file, line):
    """yarp_print_trace(FILE * out, char const * file, int line)"""
    return _yarp.yarp_print_trace(out, file, line)
class LogStream(_object):
    """Proxy of C++ yarp::os::LogStream class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, LogStream, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, LogStream, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(yarp::os::LogStream self, yarp::os::Log::LogType type, char const * file, unsigned int line, char const * func) -> LogStream
        __init__(yarp::os::LogStream self, LogStream o) -> LogStream
        """
        this = _yarp.new_LogStream(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _yarp.delete_LogStream
    __del__ = lambda self: None

    def __lshift__(self, *args):
        """
        __lshift__(LogStream self, bool t) -> LogStream
        __lshift__(LogStream self, char t) -> LogStream
        __lshift__(LogStream self, short t) -> LogStream
        __lshift__(LogStream self, unsigned short t) -> LogStream
        __lshift__(LogStream self, int t) -> LogStream
        __lshift__(LogStream self, unsigned int t) -> LogStream
        __lshift__(LogStream self, long t) -> LogStream
        __lshift__(LogStream self, unsigned long t) -> LogStream
        __lshift__(LogStream self, long long t) -> LogStream
        __lshift__(LogStream self, unsigned long long t) -> LogStream
        __lshift__(LogStream self, float t) -> LogStream
        __lshift__(LogStream self, double t) -> LogStream
        __lshift__(LogStream self, char const * t) -> LogStream
        __lshift__(LogStream self, void const * t) -> LogStream
        __lshift__(LogStream self, yarp::os::ConstString const & t) -> LogStream
        """
        return _yarp.LogStream___lshift__(self, *args)

LogStream_swigregister = _yarp.LogStream_swigregister
LogStream_swigregister(LogStream)

class TypedReaderProperty(_object):
    """Proxy of C++ yarp::os::TypedReader<(Property)> class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, TypedReaderProperty, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, TypedReaderProperty, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def setStrict(self, strict=True):
        """
        setStrict(TypedReaderProperty self, bool strict=True)
        setStrict(TypedReaderProperty self)
        """
        return _yarp.TypedReaderProperty_setStrict(self, strict)


    def read(self, shouldWait=True):
        """
        read(TypedReaderProperty self, bool shouldWait=True) -> Property
        read(TypedReaderProperty self) -> Property
        """
        return _yarp.TypedReaderProperty_read(self, shouldWait)


    def interrupt(self):
        """interrupt(TypedReaderProperty self)"""
        return _yarp.TypedReaderProperty_interrupt(self)


    def lastRead(self):
        """lastRead(TypedReaderProperty self) -> Property"""
        return _yarp.TypedReaderProperty_lastRead(self)


    def isClosed(self):
        """isClosed(TypedReaderProperty self) -> bool"""
        return _yarp.TypedReaderProperty_isClosed(self)


    def useCallback(self, callback):
        """useCallback(TypedReaderProperty self, PropertyCallback callback)"""
        return _yarp.TypedReaderProperty_useCallback(self, callback)


    def disableCallback(self):
        """disableCallback(TypedReaderProperty self)"""
        return _yarp.TypedReaderProperty_disableCallback(self)


    def getPendingReads(self):
        """getPendingReads(TypedReaderProperty self) -> int"""
        return _yarp.TypedReaderProperty_getPendingReads(self)

    __swig_destroy__ = _yarp.delete_TypedReaderProperty
    __del__ = lambda self: None

    def getName(self):
        """getName(TypedReaderProperty self) -> yarp::os::ConstString"""
        return _yarp.TypedReaderProperty_getName(self)


    def setReplier(self, reader):
        """setReplier(TypedReaderProperty self, PortReader reader)"""
        return _yarp.TypedReaderProperty_setReplier(self, reader)


    def acquire(self):
        """acquire(TypedReaderProperty self) -> void *"""
        return _yarp.TypedReaderProperty_acquire(self)


    def release(self, handle):
        """release(TypedReaderProperty self, void * handle)"""
        return _yarp.TypedReaderProperty_release(self, handle)


    def setTargetPeriod(self, period):
        """setTargetPeriod(TypedReaderProperty self, double period)"""
        return _yarp.TypedReaderProperty_setTargetPeriod(self, period)

TypedReaderProperty_swigregister = _yarp.TypedReaderProperty_swigregister
TypedReaderProperty_swigregister(TypedReaderProperty)

class PropertyCallback(_object):
    """Proxy of C++ yarp::os::TypedReaderCallback<(Property)> class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PropertyCallback, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PropertyCallback, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_PropertyCallback
    __del__ = lambda self: None

    def onRead(self, *args):
        """
        onRead(PropertyCallback self, Property datum)
        onRead(PropertyCallback self, Property datum, TypedReaderProperty reader)
        """
        return _yarp.PropertyCallback_onRead(self, *args)


    def __init__(self):
        """__init__(yarp::os::TypedReaderCallback<(Property)> self) -> PropertyCallback"""
        if self.__class__ == PropertyCallback:
            _self = None
        else:
            _self = self
        this = _yarp.new_PropertyCallback(_self, )
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    def __disown__(self):
        self.this.disown()
        _yarp.disown_PropertyCallback(self)
        return weakref_proxy(self)
PropertyCallback_swigregister = _yarp.PropertyCallback_swigregister
PropertyCallback_swigregister(PropertyCallback)

class BufferedPortProperty(Contactable, TypedReaderProperty, PropertyCallback):
    """Proxy of C++ yarp::os::BufferedPort<(Property)> class."""

    __swig_setmethods__ = {}
    for _s in [Contactable, TypedReaderProperty, PropertyCallback]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, BufferedPortProperty, name, value)
    __swig_getmethods__ = {}
    for _s in [Contactable, TypedReaderProperty, PropertyCallback]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, BufferedPortProperty, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(yarp::os::BufferedPort<(Property)> self) -> BufferedPortProperty
        __init__(yarp::os::BufferedPort<(Property)> self, Port port) -> BufferedPortProperty
        """
        this = _yarp.new_BufferedPortProperty(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _yarp.delete_BufferedPortProperty
    __del__ = lambda self: None

    def addOutput(self, *args):
        """
        addOutput(BufferedPortProperty self, yarp::os::ConstString const & name) -> bool
        addOutput(BufferedPortProperty self, yarp::os::ConstString const & name, yarp::os::ConstString const & carrier) -> bool
        addOutput(BufferedPortProperty self, Contact contact) -> bool
        """
        return _yarp.BufferedPortProperty_addOutput(self, *args)


    def close(self):
        """close(BufferedPortProperty self)"""
        return _yarp.BufferedPortProperty_close(self)


    def interrupt(self):
        """interrupt(BufferedPortProperty self)"""
        return _yarp.BufferedPortProperty_interrupt(self)


    def resume(self):
        """resume(BufferedPortProperty self)"""
        return _yarp.BufferedPortProperty_resume(self)


    def getPendingReads(self):
        """getPendingReads(BufferedPortProperty self) -> int"""
        return _yarp.BufferedPortProperty_getPendingReads(self)


    def where(self):
        """where(BufferedPortProperty self) -> Contact"""
        return _yarp.BufferedPortProperty_where(self)


    def getName(self):
        """getName(BufferedPortProperty self) -> yarp::os::ConstString"""
        return _yarp.BufferedPortProperty_getName(self)


    def prepare(self):
        """prepare(BufferedPortProperty self) -> Property"""
        return _yarp.BufferedPortProperty_prepare(self)


    def unprepare(self):
        """unprepare(BufferedPortProperty self) -> bool"""
        return _yarp.BufferedPortProperty_unprepare(self)


    def write(self, forceStrict=False):
        """
        write(BufferedPortProperty self, bool forceStrict=False)
        write(BufferedPortProperty self)
        """
        return _yarp.BufferedPortProperty_write(self, forceStrict)


    def writeStrict(self):
        """writeStrict(BufferedPortProperty self)"""
        return _yarp.BufferedPortProperty_writeStrict(self)


    def waitForWrite(self):
        """waitForWrite(BufferedPortProperty self)"""
        return _yarp.BufferedPortProperty_waitForWrite(self)


    def setStrict(self, strict=True):
        """
        setStrict(BufferedPortProperty self, bool strict=True)
        setStrict(BufferedPortProperty self)
        """
        return _yarp.BufferedPortProperty_setStrict(self, strict)


    def read(self, shouldWait=True):
        """
        read(BufferedPortProperty self, bool shouldWait=True) -> Property
        read(BufferedPortProperty self) -> Property
        """
        return _yarp.BufferedPortProperty_read(self, shouldWait)


    def lastRead(self):
        """lastRead(BufferedPortProperty self) -> Property"""
        return _yarp.BufferedPortProperty_lastRead(self)


    def isClosed(self):
        """isClosed(BufferedPortProperty self) -> bool"""
        return _yarp.BufferedPortProperty_isClosed(self)


    def setReplier(self, reader):
        """setReplier(BufferedPortProperty self, PortReader reader)"""
        return _yarp.BufferedPortProperty_setReplier(self, reader)


    def setReader(self, reader):
        """setReader(BufferedPortProperty self, PortReader reader)"""
        return _yarp.BufferedPortProperty_setReader(self, reader)


    def setAdminReader(self, reader):
        """setAdminReader(BufferedPortProperty self, PortReader reader)"""
        return _yarp.BufferedPortProperty_setAdminReader(self, reader)


    def onRead(self, *args):
        """
        onRead(BufferedPortProperty self, Property datum, TypedReaderProperty reader)
        onRead(BufferedPortProperty self, Property datum)
        """
        return _yarp.BufferedPortProperty_onRead(self, *args)


    def useCallback(self, *args):
        """
        useCallback(BufferedPortProperty self, PropertyCallback callback)
        useCallback(BufferedPortProperty self)
        """
        return _yarp.BufferedPortProperty_useCallback(self, *args)


    def disableCallback(self):
        """disableCallback(BufferedPortProperty self)"""
        return _yarp.BufferedPortProperty_disableCallback(self)


    def setEnvelope(self, envelope):
        """setEnvelope(BufferedPortProperty self, PortWriter envelope) -> bool"""
        return _yarp.BufferedPortProperty_setEnvelope(self, envelope)


    def getEnvelope(self, envelope):
        """getEnvelope(BufferedPortProperty self, PortReader envelope) -> bool"""
        return _yarp.BufferedPortProperty_getEnvelope(self, envelope)


    def getInputCount(self):
        """getInputCount(BufferedPortProperty self) -> int"""
        return _yarp.BufferedPortProperty_getInputCount(self)


    def getOutputCount(self):
        """getOutputCount(BufferedPortProperty self) -> int"""
        return _yarp.BufferedPortProperty_getOutputCount(self)


    def isWriting(self):
        """isWriting(BufferedPortProperty self) -> bool"""
        return _yarp.BufferedPortProperty_isWriting(self)


    def getReport(self, reporter):
        """getReport(BufferedPortProperty self, PortReport reporter)"""
        return _yarp.BufferedPortProperty_getReport(self, reporter)


    def setReporter(self, reporter):
        """setReporter(BufferedPortProperty self, PortReport reporter)"""
        return _yarp.BufferedPortProperty_setReporter(self, reporter)


    def resetReporter(self):
        """resetReporter(BufferedPortProperty self)"""
        return _yarp.BufferedPortProperty_resetReporter(self)


    def acquire(self):
        """acquire(BufferedPortProperty self) -> void *"""
        return _yarp.BufferedPortProperty_acquire(self)


    def release(self, handle):
        """release(BufferedPortProperty self, void * handle)"""
        return _yarp.BufferedPortProperty_release(self, handle)


    def setTargetPeriod(self, period):
        """setTargetPeriod(BufferedPortProperty self, double period)"""
        return _yarp.BufferedPortProperty_setTargetPeriod(self, period)


    def getType(self):
        """getType(BufferedPortProperty self) -> Type"""
        return _yarp.BufferedPortProperty_getType(self)


    def promiseType(self, typ):
        """promiseType(BufferedPortProperty self, Type const & typ)"""
        return _yarp.BufferedPortProperty_promiseType(self, typ)


    def setInputMode(self, expectInput):
        """setInputMode(BufferedPortProperty self, bool expectInput)"""
        return _yarp.BufferedPortProperty_setInputMode(self, expectInput)


    def setOutputMode(self, expectOutput):
        """setOutputMode(BufferedPortProperty self, bool expectOutput)"""
        return _yarp.BufferedPortProperty_setOutputMode(self, expectOutput)


    def setRpcMode(self, expectRpc):
        """setRpcMode(BufferedPortProperty self, bool expectRpc)"""
        return _yarp.BufferedPortProperty_setRpcMode(self, expectRpc)


    def acquireProperties(self, readOnly):
        """acquireProperties(BufferedPortProperty self, bool readOnly) -> Property"""
        return _yarp.BufferedPortProperty_acquireProperties(self, readOnly)


    def releaseProperties(self, prop):
        """releaseProperties(BufferedPortProperty self, Property prop)"""
        return _yarp.BufferedPortProperty_releaseProperties(self, prop)


    def includeNodeInName(self, flag):
        """includeNodeInName(BufferedPortProperty self, bool flag)"""
        return _yarp.BufferedPortProperty_includeNodeInName(self, flag)


    def setCallbackLock(self, mutex):
        """setCallbackLock(BufferedPortProperty self, yarp::os::Mutex * mutex) -> bool"""
        return _yarp.BufferedPortProperty_setCallbackLock(self, mutex)


    def removeCallbackLock(self):
        """removeCallbackLock(BufferedPortProperty self) -> bool"""
        return _yarp.BufferedPortProperty_removeCallbackLock(self)


    def lockCallback(self):
        """lockCallback(BufferedPortProperty self) -> bool"""
        return _yarp.BufferedPortProperty_lockCallback(self)


    def tryLockCallback(self):
        """tryLockCallback(BufferedPortProperty self) -> bool"""
        return _yarp.BufferedPortProperty_tryLockCallback(self)


    def unlockCallback(self):
        """unlockCallback(BufferedPortProperty self)"""
        return _yarp.BufferedPortProperty_unlockCallback(self)

BufferedPortProperty_swigregister = _yarp.BufferedPortProperty_swigregister
BufferedPortProperty_swigregister(BufferedPortProperty)

class TypedReaderBottle(_object):
    """Proxy of C++ yarp::os::TypedReader<(Bottle)> class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, TypedReaderBottle, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, TypedReaderBottle, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def setStrict(self, strict=True):
        """
        setStrict(TypedReaderBottle self, bool strict=True)
        setStrict(TypedReaderBottle self)
        """
        return _yarp.TypedReaderBottle_setStrict(self, strict)


    def read(self, shouldWait=True):
        """
        read(TypedReaderBottle self, bool shouldWait=True) -> Bottle
        read(TypedReaderBottle self) -> Bottle
        """
        return _yarp.TypedReaderBottle_read(self, shouldWait)


    def interrupt(self):
        """interrupt(TypedReaderBottle self)"""
        return _yarp.TypedReaderBottle_interrupt(self)


    def lastRead(self):
        """lastRead(TypedReaderBottle self) -> Bottle"""
        return _yarp.TypedReaderBottle_lastRead(self)


    def isClosed(self):
        """isClosed(TypedReaderBottle self) -> bool"""
        return _yarp.TypedReaderBottle_isClosed(self)


    def useCallback(self, callback):
        """useCallback(TypedReaderBottle self, BottleCallback callback)"""
        return _yarp.TypedReaderBottle_useCallback(self, callback)


    def disableCallback(self):
        """disableCallback(TypedReaderBottle self)"""
        return _yarp.TypedReaderBottle_disableCallback(self)


    def getPendingReads(self):
        """getPendingReads(TypedReaderBottle self) -> int"""
        return _yarp.TypedReaderBottle_getPendingReads(self)

    __swig_destroy__ = _yarp.delete_TypedReaderBottle
    __del__ = lambda self: None

    def getName(self):
        """getName(TypedReaderBottle self) -> yarp::os::ConstString"""
        return _yarp.TypedReaderBottle_getName(self)


    def setReplier(self, reader):
        """setReplier(TypedReaderBottle self, PortReader reader)"""
        return _yarp.TypedReaderBottle_setReplier(self, reader)


    def acquire(self):
        """acquire(TypedReaderBottle self) -> void *"""
        return _yarp.TypedReaderBottle_acquire(self)


    def release(self, handle):
        """release(TypedReaderBottle self, void * handle)"""
        return _yarp.TypedReaderBottle_release(self, handle)


    def setTargetPeriod(self, period):
        """setTargetPeriod(TypedReaderBottle self, double period)"""
        return _yarp.TypedReaderBottle_setTargetPeriod(self, period)

TypedReaderBottle_swigregister = _yarp.TypedReaderBottle_swigregister
TypedReaderBottle_swigregister(TypedReaderBottle)

class BottleCallback(_object):
    """Proxy of C++ yarp::os::TypedReaderCallback<(Bottle)> class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, BottleCallback, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, BottleCallback, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_BottleCallback
    __del__ = lambda self: None

    def onRead(self, *args):
        """
        onRead(BottleCallback self, Bottle datum)
        onRead(BottleCallback self, Bottle datum, TypedReaderBottle reader)
        """
        return _yarp.BottleCallback_onRead(self, *args)


    def __init__(self):
        """__init__(yarp::os::TypedReaderCallback<(Bottle)> self) -> BottleCallback"""
        if self.__class__ == BottleCallback:
            _self = None
        else:
            _self = self
        this = _yarp.new_BottleCallback(_self, )
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    def __disown__(self):
        self.this.disown()
        _yarp.disown_BottleCallback(self)
        return weakref_proxy(self)
BottleCallback_swigregister = _yarp.BottleCallback_swigregister
BottleCallback_swigregister(BottleCallback)

class BufferedPortBottle(Contactable, TypedReaderBottle, BottleCallback):
    """Proxy of C++ yarp::os::BufferedPort<(Bottle)> class."""

    __swig_setmethods__ = {}
    for _s in [Contactable, TypedReaderBottle, BottleCallback]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, BufferedPortBottle, name, value)
    __swig_getmethods__ = {}
    for _s in [Contactable, TypedReaderBottle, BottleCallback]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, BufferedPortBottle, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(yarp::os::BufferedPort<(Bottle)> self) -> BufferedPortBottle
        __init__(yarp::os::BufferedPort<(Bottle)> self, Port port) -> BufferedPortBottle
        """
        this = _yarp.new_BufferedPortBottle(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _yarp.delete_BufferedPortBottle
    __del__ = lambda self: None

    def addOutput(self, *args):
        """
        addOutput(BufferedPortBottle self, yarp::os::ConstString const & name) -> bool
        addOutput(BufferedPortBottle self, yarp::os::ConstString const & name, yarp::os::ConstString const & carrier) -> bool
        addOutput(BufferedPortBottle self, Contact contact) -> bool
        """
        return _yarp.BufferedPortBottle_addOutput(self, *args)


    def close(self):
        """close(BufferedPortBottle self)"""
        return _yarp.BufferedPortBottle_close(self)


    def interrupt(self):
        """interrupt(BufferedPortBottle self)"""
        return _yarp.BufferedPortBottle_interrupt(self)


    def resume(self):
        """resume(BufferedPortBottle self)"""
        return _yarp.BufferedPortBottle_resume(self)


    def getPendingReads(self):
        """getPendingReads(BufferedPortBottle self) -> int"""
        return _yarp.BufferedPortBottle_getPendingReads(self)


    def where(self):
        """where(BufferedPortBottle self) -> Contact"""
        return _yarp.BufferedPortBottle_where(self)


    def getName(self):
        """getName(BufferedPortBottle self) -> yarp::os::ConstString"""
        return _yarp.BufferedPortBottle_getName(self)


    def prepare(self):
        """prepare(BufferedPortBottle self) -> Bottle"""
        return _yarp.BufferedPortBottle_prepare(self)


    def unprepare(self):
        """unprepare(BufferedPortBottle self) -> bool"""
        return _yarp.BufferedPortBottle_unprepare(self)


    def write(self, forceStrict=False):
        """
        write(BufferedPortBottle self, bool forceStrict=False)
        write(BufferedPortBottle self)
        """
        return _yarp.BufferedPortBottle_write(self, forceStrict)


    def writeStrict(self):
        """writeStrict(BufferedPortBottle self)"""
        return _yarp.BufferedPortBottle_writeStrict(self)


    def waitForWrite(self):
        """waitForWrite(BufferedPortBottle self)"""
        return _yarp.BufferedPortBottle_waitForWrite(self)


    def setStrict(self, strict=True):
        """
        setStrict(BufferedPortBottle self, bool strict=True)
        setStrict(BufferedPortBottle self)
        """
        return _yarp.BufferedPortBottle_setStrict(self, strict)


    def read(self, shouldWait=True):
        """
        read(BufferedPortBottle self, bool shouldWait=True) -> Bottle
        read(BufferedPortBottle self) -> Bottle
        """
        return _yarp.BufferedPortBottle_read(self, shouldWait)


    def lastRead(self):
        """lastRead(BufferedPortBottle self) -> Bottle"""
        return _yarp.BufferedPortBottle_lastRead(self)


    def isClosed(self):
        """isClosed(BufferedPortBottle self) -> bool"""
        return _yarp.BufferedPortBottle_isClosed(self)


    def setReplier(self, reader):
        """setReplier(BufferedPortBottle self, PortReader reader)"""
        return _yarp.BufferedPortBottle_setReplier(self, reader)


    def setReader(self, reader):
        """setReader(BufferedPortBottle self, PortReader reader)"""
        return _yarp.BufferedPortBottle_setReader(self, reader)


    def setAdminReader(self, reader):
        """setAdminReader(BufferedPortBottle self, PortReader reader)"""
        return _yarp.BufferedPortBottle_setAdminReader(self, reader)


    def onRead(self, *args):
        """
        onRead(BufferedPortBottle self, Bottle datum, TypedReaderBottle reader)
        onRead(BufferedPortBottle self, Bottle datum)
        """
        return _yarp.BufferedPortBottle_onRead(self, *args)


    def useCallback(self, *args):
        """
        useCallback(BufferedPortBottle self, BottleCallback callback)
        useCallback(BufferedPortBottle self)
        """
        return _yarp.BufferedPortBottle_useCallback(self, *args)


    def disableCallback(self):
        """disableCallback(BufferedPortBottle self)"""
        return _yarp.BufferedPortBottle_disableCallback(self)


    def setEnvelope(self, envelope):
        """setEnvelope(BufferedPortBottle self, PortWriter envelope) -> bool"""
        return _yarp.BufferedPortBottle_setEnvelope(self, envelope)


    def getEnvelope(self, envelope):
        """getEnvelope(BufferedPortBottle self, PortReader envelope) -> bool"""
        return _yarp.BufferedPortBottle_getEnvelope(self, envelope)


    def getInputCount(self):
        """getInputCount(BufferedPortBottle self) -> int"""
        return _yarp.BufferedPortBottle_getInputCount(self)


    def getOutputCount(self):
        """getOutputCount(BufferedPortBottle self) -> int"""
        return _yarp.BufferedPortBottle_getOutputCount(self)


    def isWriting(self):
        """isWriting(BufferedPortBottle self) -> bool"""
        return _yarp.BufferedPortBottle_isWriting(self)


    def getReport(self, reporter):
        """getReport(BufferedPortBottle self, PortReport reporter)"""
        return _yarp.BufferedPortBottle_getReport(self, reporter)


    def setReporter(self, reporter):
        """setReporter(BufferedPortBottle self, PortReport reporter)"""
        return _yarp.BufferedPortBottle_setReporter(self, reporter)


    def resetReporter(self):
        """resetReporter(BufferedPortBottle self)"""
        return _yarp.BufferedPortBottle_resetReporter(self)


    def acquire(self):
        """acquire(BufferedPortBottle self) -> void *"""
        return _yarp.BufferedPortBottle_acquire(self)


    def release(self, handle):
        """release(BufferedPortBottle self, void * handle)"""
        return _yarp.BufferedPortBottle_release(self, handle)


    def setTargetPeriod(self, period):
        """setTargetPeriod(BufferedPortBottle self, double period)"""
        return _yarp.BufferedPortBottle_setTargetPeriod(self, period)


    def getType(self):
        """getType(BufferedPortBottle self) -> Type"""
        return _yarp.BufferedPortBottle_getType(self)


    def promiseType(self, typ):
        """promiseType(BufferedPortBottle self, Type const & typ)"""
        return _yarp.BufferedPortBottle_promiseType(self, typ)


    def setInputMode(self, expectInput):
        """setInputMode(BufferedPortBottle self, bool expectInput)"""
        return _yarp.BufferedPortBottle_setInputMode(self, expectInput)


    def setOutputMode(self, expectOutput):
        """setOutputMode(BufferedPortBottle self, bool expectOutput)"""
        return _yarp.BufferedPortBottle_setOutputMode(self, expectOutput)


    def setRpcMode(self, expectRpc):
        """setRpcMode(BufferedPortBottle self, bool expectRpc)"""
        return _yarp.BufferedPortBottle_setRpcMode(self, expectRpc)


    def acquireProperties(self, readOnly):
        """acquireProperties(BufferedPortBottle self, bool readOnly) -> Property"""
        return _yarp.BufferedPortBottle_acquireProperties(self, readOnly)


    def releaseProperties(self, prop):
        """releaseProperties(BufferedPortBottle self, Property prop)"""
        return _yarp.BufferedPortBottle_releaseProperties(self, prop)


    def includeNodeInName(self, flag):
        """includeNodeInName(BufferedPortBottle self, bool flag)"""
        return _yarp.BufferedPortBottle_includeNodeInName(self, flag)


    def setCallbackLock(self, mutex):
        """setCallbackLock(BufferedPortBottle self, yarp::os::Mutex * mutex) -> bool"""
        return _yarp.BufferedPortBottle_setCallbackLock(self, mutex)


    def removeCallbackLock(self):
        """removeCallbackLock(BufferedPortBottle self) -> bool"""
        return _yarp.BufferedPortBottle_removeCallbackLock(self)


    def lockCallback(self):
        """lockCallback(BufferedPortBottle self) -> bool"""
        return _yarp.BufferedPortBottle_lockCallback(self)


    def tryLockCallback(self):
        """tryLockCallback(BufferedPortBottle self) -> bool"""
        return _yarp.BufferedPortBottle_tryLockCallback(self)


    def unlockCallback(self):
        """unlockCallback(BufferedPortBottle self)"""
        return _yarp.BufferedPortBottle_unlockCallback(self)

BufferedPortBottle_swigregister = _yarp.BufferedPortBottle_swigregister
BufferedPortBottle_swigregister(BufferedPortBottle)


def PAD_BYTES(len, pad):
    """PAD_BYTES(int len, int pad) -> int"""
    return _yarp.PAD_BYTES(len, pad)

_yarp.VOCAB_PIXEL_INVALID_swigconstant(_yarp)
VOCAB_PIXEL_INVALID = _yarp.VOCAB_PIXEL_INVALID

_yarp.VOCAB_PIXEL_MONO_swigconstant(_yarp)
VOCAB_PIXEL_MONO = _yarp.VOCAB_PIXEL_MONO

_yarp.VOCAB_PIXEL_MONO16_swigconstant(_yarp)
VOCAB_PIXEL_MONO16 = _yarp.VOCAB_PIXEL_MONO16

_yarp.VOCAB_PIXEL_RGB_swigconstant(_yarp)
VOCAB_PIXEL_RGB = _yarp.VOCAB_PIXEL_RGB

_yarp.VOCAB_PIXEL_RGBA_swigconstant(_yarp)
VOCAB_PIXEL_RGBA = _yarp.VOCAB_PIXEL_RGBA

_yarp.VOCAB_PIXEL_BGRA_swigconstant(_yarp)
VOCAB_PIXEL_BGRA = _yarp.VOCAB_PIXEL_BGRA

_yarp.VOCAB_PIXEL_INT_swigconstant(_yarp)
VOCAB_PIXEL_INT = _yarp.VOCAB_PIXEL_INT

_yarp.VOCAB_PIXEL_HSV_swigconstant(_yarp)
VOCAB_PIXEL_HSV = _yarp.VOCAB_PIXEL_HSV

_yarp.VOCAB_PIXEL_BGR_swigconstant(_yarp)
VOCAB_PIXEL_BGR = _yarp.VOCAB_PIXEL_BGR

_yarp.VOCAB_PIXEL_MONO_SIGNED_swigconstant(_yarp)
VOCAB_PIXEL_MONO_SIGNED = _yarp.VOCAB_PIXEL_MONO_SIGNED

_yarp.VOCAB_PIXEL_RGB_SIGNED_swigconstant(_yarp)
VOCAB_PIXEL_RGB_SIGNED = _yarp.VOCAB_PIXEL_RGB_SIGNED

_yarp.VOCAB_PIXEL_RGB_INT_swigconstant(_yarp)
VOCAB_PIXEL_RGB_INT = _yarp.VOCAB_PIXEL_RGB_INT

_yarp.VOCAB_PIXEL_MONO_FLOAT_swigconstant(_yarp)
VOCAB_PIXEL_MONO_FLOAT = _yarp.VOCAB_PIXEL_MONO_FLOAT

_yarp.VOCAB_PIXEL_RGB_FLOAT_swigconstant(_yarp)
VOCAB_PIXEL_RGB_FLOAT = _yarp.VOCAB_PIXEL_RGB_FLOAT

_yarp.VOCAB_PIXEL_HSV_FLOAT_swigconstant(_yarp)
VOCAB_PIXEL_HSV_FLOAT = _yarp.VOCAB_PIXEL_HSV_FLOAT

_yarp.VOCAB_PIXEL_ENCODING_BAYER_GRBG8_swigconstant(_yarp)
VOCAB_PIXEL_ENCODING_BAYER_GRBG8 = _yarp.VOCAB_PIXEL_ENCODING_BAYER_GRBG8

_yarp.VOCAB_PIXEL_ENCODING_BAYER_GRBG16_swigconstant(_yarp)
VOCAB_PIXEL_ENCODING_BAYER_GRBG16 = _yarp.VOCAB_PIXEL_ENCODING_BAYER_GRBG16

_yarp.VOCAB_PIXEL_ENCODING_BAYER_BGGR8_swigconstant(_yarp)
VOCAB_PIXEL_ENCODING_BAYER_BGGR8 = _yarp.VOCAB_PIXEL_ENCODING_BAYER_BGGR8

_yarp.VOCAB_PIXEL_ENCODING_BAYER_BGGR16_swigconstant(_yarp)
VOCAB_PIXEL_ENCODING_BAYER_BGGR16 = _yarp.VOCAB_PIXEL_ENCODING_BAYER_BGGR16

_yarp.VOCAB_PIXEL_ENCODING_BAYER_GBRG8_swigconstant(_yarp)
VOCAB_PIXEL_ENCODING_BAYER_GBRG8 = _yarp.VOCAB_PIXEL_ENCODING_BAYER_GBRG8

_yarp.VOCAB_PIXEL_ENCODING_BAYER_GBRG16_swigconstant(_yarp)
VOCAB_PIXEL_ENCODING_BAYER_GBRG16 = _yarp.VOCAB_PIXEL_ENCODING_BAYER_GBRG16

_yarp.VOCAB_PIXEL_ENCODING_BAYER_RGGB8_swigconstant(_yarp)
VOCAB_PIXEL_ENCODING_BAYER_RGGB8 = _yarp.VOCAB_PIXEL_ENCODING_BAYER_RGGB8

_yarp.VOCAB_PIXEL_ENCODING_BAYER_RGGB16_swigconstant(_yarp)
VOCAB_PIXEL_ENCODING_BAYER_RGGB16 = _yarp.VOCAB_PIXEL_ENCODING_BAYER_RGGB16

_yarp.VOCAB_PIXEL_YUV_420_swigconstant(_yarp)
VOCAB_PIXEL_YUV_420 = _yarp.VOCAB_PIXEL_YUV_420

_yarp.VOCAB_PIXEL_YUV_444_swigconstant(_yarp)
VOCAB_PIXEL_YUV_444 = _yarp.VOCAB_PIXEL_YUV_444

_yarp.VOCAB_PIXEL_YUV_422_swigconstant(_yarp)
VOCAB_PIXEL_YUV_422 = _yarp.VOCAB_PIXEL_YUV_422

_yarp.VOCAB_PIXEL_YUV_411_swigconstant(_yarp)
VOCAB_PIXEL_YUV_411 = _yarp.VOCAB_PIXEL_YUV_411
class Image(Portable):
    """Proxy of C++ yarp::sig::Image class."""

    __swig_setmethods__ = {}
    for _s in [Portable]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Image, name, value)
    __swig_getmethods__ = {}
    for _s in [Portable]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Image, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(yarp::sig::Image self) -> Image
        __init__(yarp::sig::Image self, Image alt) -> Image
        """
        this = _yarp.new_Image(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _yarp.delete_Image
    __del__ = lambda self: None

    def copy(self, *args):
        """
        copy(Image self, Image alt) -> bool
        copy(Image self, Image alt, int w, int h) -> bool
        """
        return _yarp.Image_copy(self, *args)


    def width(self):
        """width(Image self) -> int"""
        return _yarp.Image_width(self)


    def height(self):
        """height(Image self) -> int"""
        return _yarp.Image_height(self)


    def getPixelSize(self):
        """getPixelSize(Image self) -> int"""
        return _yarp.Image_getPixelSize(self)


    def getPixelCode(self):
        """getPixelCode(Image self) -> int"""
        return _yarp.Image_getPixelCode(self)


    def getRowSize(self):
        """getRowSize(Image self) -> int"""
        return _yarp.Image_getRowSize(self)


    def getQuantum(self):
        """getQuantum(Image self) -> int"""
        return _yarp.Image_getQuantum(self)


    def getPadding(self):
        """getPadding(Image self) -> int"""
        return _yarp.Image_getPadding(self)


    def getRow(self, r):
        """getRow(Image self, int r) -> unsigned char *"""
        return _yarp.Image_getRow(self, r)


    def getPixelAddress(self, x, y):
        """getPixelAddress(Image self, int x, int y) -> unsigned char *"""
        return _yarp.Image_getPixelAddress(self, x, y)


    def isPixel(self, x, y):
        """isPixel(Image self, int x, int y) -> bool"""
        return _yarp.Image_isPixel(self, x, y)


    def zero(self):
        """zero(Image self)"""
        return _yarp.Image_zero(self)


    def resize(self, *args):
        """
        resize(Image self, int imgWidth, int imgHeight)
        resize(Image self, Image alt)
        """
        return _yarp.Image_resize(self, *args)


    def getRawImage(self):
        """getRawImage(Image self) -> unsigned char *"""
        return _yarp.Image_getRawImage(self)


    def getRawImageSize(self):
        """getRawImageSize(Image self) -> int"""
        return _yarp.Image_getRawImageSize(self)


    def getIplImage(self):
        """getIplImage(Image self) -> void *"""
        return _yarp.Image_getIplImage(self)


    def wrapIplImage(self, iplImage):
        """wrapIplImage(Image self, void * iplImage)"""
        return _yarp.Image_wrapIplImage(self, iplImage)


    def read(self, connection):
        """read(Image self, ConnectionReader connection) -> bool"""
        return _yarp.Image_read(self, connection)


    def write(self, connection):
        """write(Image self, ConnectionWriter connection) -> bool"""
        return _yarp.Image_write(self, connection)


    def setQuantum(self, imgQuantum):
        """setQuantum(Image self, int imgQuantum)"""
        return _yarp.Image_setQuantum(self, imgQuantum)


    def topIsLowIndex(self):
        """topIsLowIndex(Image self) -> bool"""
        return _yarp.Image_topIsLowIndex(self)


    def setTopIsLowIndex(self, flag):
        """setTopIsLowIndex(Image self, bool flag)"""
        return _yarp.Image_setTopIsLowIndex(self, flag)


    def getRowArray(self):
        """getRowArray(Image self) -> char **"""
        return _yarp.Image_getRowArray(self)


    def setExternal(self, *args):
        """
        setExternal(Image self, void const * data, int imgWidth, int imgHeight)
        setExternal(Image self, PyObject * mem, int w, int h)
        """
        return _yarp.Image_setExternal(self, *args)


    def setExternal2(self, mem, w, h):
        """setExternal2(Image self, PyObject * mem, int w, int h)"""
        return _yarp.Image_setExternal2(self, mem, w, h)


    def tostring(self):
        """tostring(Image self) -> std::string"""
        return _yarp.Image_tostring(self)


    def fromstring(self, str, w, h):
        """fromstring(Image self, std::string const & str, int w, int h)"""
        return _yarp.Image_fromstring(self, str, w, h)

Image_swigregister = _yarp.Image_swigregister
Image_swigregister(Image)

class FlexImage(Image):
    """Proxy of C++ yarp::sig::FlexImage class."""

    __swig_setmethods__ = {}
    for _s in [Image]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, FlexImage, name, value)
    __swig_getmethods__ = {}
    for _s in [Image]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, FlexImage, name)
    __repr__ = _swig_repr

    def setPixelCode(self, imgPixelCode):
        """setPixelCode(FlexImage self, int imgPixelCode)"""
        return _yarp.FlexImage_setPixelCode(self, imgPixelCode)


    def setPixelSize(self, imgPixelSize):
        """setPixelSize(FlexImage self, int imgPixelSize)"""
        return _yarp.FlexImage_setPixelSize(self, imgPixelSize)


    def setQuantum(self, imgQuantum):
        """setQuantum(FlexImage self, int imgQuantum)"""
        return _yarp.FlexImage_setQuantum(self, imgQuantum)


    def __init__(self):
        """__init__(yarp::sig::FlexImage self) -> FlexImage"""
        this = _yarp.new_FlexImage()
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _yarp.delete_FlexImage
    __del__ = lambda self: None
FlexImage_swigregister = _yarp.FlexImage_swigregister
FlexImage_swigregister(FlexImage)

class PixelRgb(_object):
    """Proxy of C++ yarp::sig::PixelRgb class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PixelRgb, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PixelRgb, name)
    __repr__ = _swig_repr
    __swig_setmethods__["r"] = _yarp.PixelRgb_r_set
    __swig_getmethods__["r"] = _yarp.PixelRgb_r_get
    if _newclass:
        r = _swig_property(_yarp.PixelRgb_r_get, _yarp.PixelRgb_r_set)
    __swig_setmethods__["g"] = _yarp.PixelRgb_g_set
    __swig_getmethods__["g"] = _yarp.PixelRgb_g_get
    if _newclass:
        g = _swig_property(_yarp.PixelRgb_g_get, _yarp.PixelRgb_g_set)
    __swig_setmethods__["b"] = _yarp.PixelRgb_b_set
    __swig_getmethods__["b"] = _yarp.PixelRgb_b_get
    if _newclass:
        b = _swig_property(_yarp.PixelRgb_b_get, _yarp.PixelRgb_b_set)

    def __init__(self, *args):
        """
        __init__(yarp::sig::PixelRgb self) -> PixelRgb
        __init__(yarp::sig::PixelRgb self, unsigned char n_r, unsigned char n_g, unsigned char n_b) -> PixelRgb
        """
        this = _yarp.new_PixelRgb(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _yarp.delete_PixelRgb
    __del__ = lambda self: None
PixelRgb_swigregister = _yarp.PixelRgb_swigregister
PixelRgb_swigregister(PixelRgb)

class PixelRgba(_object):
    """Proxy of C++ yarp::sig::PixelRgba class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PixelRgba, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PixelRgba, name)
    __repr__ = _swig_repr
    __swig_setmethods__["r"] = _yarp.PixelRgba_r_set
    __swig_getmethods__["r"] = _yarp.PixelRgba_r_get
    if _newclass:
        r = _swig_property(_yarp.PixelRgba_r_get, _yarp.PixelRgba_r_set)
    __swig_setmethods__["g"] = _yarp.PixelRgba_g_set
    __swig_getmethods__["g"] = _yarp.PixelRgba_g_get
    if _newclass:
        g = _swig_property(_yarp.PixelRgba_g_get, _yarp.PixelRgba_g_set)
    __swig_setmethods__["b"] = _yarp.PixelRgba_b_set
    __swig_getmethods__["b"] = _yarp.PixelRgba_b_get
    if _newclass:
        b = _swig_property(_yarp.PixelRgba_b_get, _yarp.PixelRgba_b_set)
    __swig_setmethods__["a"] = _yarp.PixelRgba_a_set
    __swig_getmethods__["a"] = _yarp.PixelRgba_a_get
    if _newclass:
        a = _swig_property(_yarp.PixelRgba_a_get, _yarp.PixelRgba_a_set)

    def __init__(self, *args):
        """
        __init__(yarp::sig::PixelRgba self) -> PixelRgba
        __init__(yarp::sig::PixelRgba self, unsigned char n_r, unsigned char n_g, unsigned char n_b, unsigned char n_a) -> PixelRgba
        """
        this = _yarp.new_PixelRgba(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _yarp.delete_PixelRgba
    __del__ = lambda self: None
PixelRgba_swigregister = _yarp.PixelRgba_swigregister
PixelRgba_swigregister(PixelRgba)

class PixelBgra(_object):
    """Proxy of C++ yarp::sig::PixelBgra class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PixelBgra, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PixelBgra, name)
    __repr__ = _swig_repr
    __swig_setmethods__["b"] = _yarp.PixelBgra_b_set
    __swig_getmethods__["b"] = _yarp.PixelBgra_b_get
    if _newclass:
        b = _swig_property(_yarp.PixelBgra_b_get, _yarp.PixelBgra_b_set)
    __swig_setmethods__["g"] = _yarp.PixelBgra_g_set
    __swig_getmethods__["g"] = _yarp.PixelBgra_g_get
    if _newclass:
        g = _swig_property(_yarp.PixelBgra_g_get, _yarp.PixelBgra_g_set)
    __swig_setmethods__["r"] = _yarp.PixelBgra_r_set
    __swig_getmethods__["r"] = _yarp.PixelBgra_r_get
    if _newclass:
        r = _swig_property(_yarp.PixelBgra_r_get, _yarp.PixelBgra_r_set)
    __swig_setmethods__["a"] = _yarp.PixelBgra_a_set
    __swig_getmethods__["a"] = _yarp.PixelBgra_a_get
    if _newclass:
        a = _swig_property(_yarp.PixelBgra_a_get, _yarp.PixelBgra_a_set)

    def __init__(self, *args):
        """
        __init__(yarp::sig::PixelBgra self) -> PixelBgra
        __init__(yarp::sig::PixelBgra self, unsigned char n_r, unsigned char n_g, unsigned char n_b, unsigned char n_a) -> PixelBgra
        """
        this = _yarp.new_PixelBgra(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _yarp.delete_PixelBgra
    __del__ = lambda self: None
PixelBgra_swigregister = _yarp.PixelBgra_swigregister
PixelBgra_swigregister(PixelBgra)

class PixelBgr(_object):
    """Proxy of C++ yarp::sig::PixelBgr class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PixelBgr, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PixelBgr, name)
    __repr__ = _swig_repr
    __swig_setmethods__["b"] = _yarp.PixelBgr_b_set
    __swig_getmethods__["b"] = _yarp.PixelBgr_b_get
    if _newclass:
        b = _swig_property(_yarp.PixelBgr_b_get, _yarp.PixelBgr_b_set)
    __swig_setmethods__["g"] = _yarp.PixelBgr_g_set
    __swig_getmethods__["g"] = _yarp.PixelBgr_g_get
    if _newclass:
        g = _swig_property(_yarp.PixelBgr_g_get, _yarp.PixelBgr_g_set)
    __swig_setmethods__["r"] = _yarp.PixelBgr_r_set
    __swig_getmethods__["r"] = _yarp.PixelBgr_r_get
    if _newclass:
        r = _swig_property(_yarp.PixelBgr_r_get, _yarp.PixelBgr_r_set)

    def __init__(self, *args):
        """
        __init__(yarp::sig::PixelBgr self) -> PixelBgr
        __init__(yarp::sig::PixelBgr self, unsigned char n_r, unsigned char n_g, unsigned char n_b) -> PixelBgr
        """
        this = _yarp.new_PixelBgr(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _yarp.delete_PixelBgr
    __del__ = lambda self: None
PixelBgr_swigregister = _yarp.PixelBgr_swigregister
PixelBgr_swigregister(PixelBgr)

class PixelHsv(_object):
    """Proxy of C++ yarp::sig::PixelHsv class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PixelHsv, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PixelHsv, name)
    __repr__ = _swig_repr
    __swig_setmethods__["h"] = _yarp.PixelHsv_h_set
    __swig_getmethods__["h"] = _yarp.PixelHsv_h_get
    if _newclass:
        h = _swig_property(_yarp.PixelHsv_h_get, _yarp.PixelHsv_h_set)
    __swig_setmethods__["s"] = _yarp.PixelHsv_s_set
    __swig_getmethods__["s"] = _yarp.PixelHsv_s_get
    if _newclass:
        s = _swig_property(_yarp.PixelHsv_s_get, _yarp.PixelHsv_s_set)
    __swig_setmethods__["v"] = _yarp.PixelHsv_v_set
    __swig_getmethods__["v"] = _yarp.PixelHsv_v_get
    if _newclass:
        v = _swig_property(_yarp.PixelHsv_v_get, _yarp.PixelHsv_v_set)

    def __init__(self):
        """__init__(yarp::sig::PixelHsv self) -> PixelHsv"""
        this = _yarp.new_PixelHsv()
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _yarp.delete_PixelHsv
    __del__ = lambda self: None
PixelHsv_swigregister = _yarp.PixelHsv_swigregister
PixelHsv_swigregister(PixelHsv)

class PixelRgbSigned(_object):
    """Proxy of C++ yarp::sig::PixelRgbSigned class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PixelRgbSigned, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PixelRgbSigned, name)
    __repr__ = _swig_repr
    __swig_setmethods__["r"] = _yarp.PixelRgbSigned_r_set
    __swig_getmethods__["r"] = _yarp.PixelRgbSigned_r_get
    if _newclass:
        r = _swig_property(_yarp.PixelRgbSigned_r_get, _yarp.PixelRgbSigned_r_set)
    __swig_setmethods__["g"] = _yarp.PixelRgbSigned_g_set
    __swig_getmethods__["g"] = _yarp.PixelRgbSigned_g_get
    if _newclass:
        g = _swig_property(_yarp.PixelRgbSigned_g_get, _yarp.PixelRgbSigned_g_set)
    __swig_setmethods__["b"] = _yarp.PixelRgbSigned_b_set
    __swig_getmethods__["b"] = _yarp.PixelRgbSigned_b_get
    if _newclass:
        b = _swig_property(_yarp.PixelRgbSigned_b_get, _yarp.PixelRgbSigned_b_set)

    def __init__(self):
        """__init__(yarp::sig::PixelRgbSigned self) -> PixelRgbSigned"""
        this = _yarp.new_PixelRgbSigned()
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _yarp.delete_PixelRgbSigned
    __del__ = lambda self: None
PixelRgbSigned_swigregister = _yarp.PixelRgbSigned_swigregister
PixelRgbSigned_swigregister(PixelRgbSigned)

class PixelRgbFloat(_object):
    """Proxy of C++ yarp::sig::PixelRgbFloat class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PixelRgbFloat, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PixelRgbFloat, name)
    __repr__ = _swig_repr
    __swig_setmethods__["r"] = _yarp.PixelRgbFloat_r_set
    __swig_getmethods__["r"] = _yarp.PixelRgbFloat_r_get
    if _newclass:
        r = _swig_property(_yarp.PixelRgbFloat_r_get, _yarp.PixelRgbFloat_r_set)
    __swig_setmethods__["g"] = _yarp.PixelRgbFloat_g_set
    __swig_getmethods__["g"] = _yarp.PixelRgbFloat_g_get
    if _newclass:
        g = _swig_property(_yarp.PixelRgbFloat_g_get, _yarp.PixelRgbFloat_g_set)
    __swig_setmethods__["b"] = _yarp.PixelRgbFloat_b_set
    __swig_getmethods__["b"] = _yarp.PixelRgbFloat_b_get
    if _newclass:
        b = _swig_property(_yarp.PixelRgbFloat_b_get, _yarp.PixelRgbFloat_b_set)

    def __init__(self, *args):
        """
        __init__(yarp::sig::PixelRgbFloat self) -> PixelRgbFloat
        __init__(yarp::sig::PixelRgbFloat self, float n_r, float n_g, float n_b) -> PixelRgbFloat
        """
        this = _yarp.new_PixelRgbFloat(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _yarp.delete_PixelRgbFloat
    __del__ = lambda self: None
PixelRgbFloat_swigregister = _yarp.PixelRgbFloat_swigregister
PixelRgbFloat_swigregister(PixelRgbFloat)

class PixelRgbInt(_object):
    """Proxy of C++ yarp::sig::PixelRgbInt class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PixelRgbInt, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PixelRgbInt, name)
    __repr__ = _swig_repr
    __swig_setmethods__["r"] = _yarp.PixelRgbInt_r_set
    __swig_getmethods__["r"] = _yarp.PixelRgbInt_r_get
    if _newclass:
        r = _swig_property(_yarp.PixelRgbInt_r_get, _yarp.PixelRgbInt_r_set)
    __swig_setmethods__["g"] = _yarp.PixelRgbInt_g_set
    __swig_getmethods__["g"] = _yarp.PixelRgbInt_g_get
    if _newclass:
        g = _swig_property(_yarp.PixelRgbInt_g_get, _yarp.PixelRgbInt_g_set)
    __swig_setmethods__["b"] = _yarp.PixelRgbInt_b_set
    __swig_getmethods__["b"] = _yarp.PixelRgbInt_b_get
    if _newclass:
        b = _swig_property(_yarp.PixelRgbInt_b_get, _yarp.PixelRgbInt_b_set)

    def __init__(self, *args):
        """
        __init__(yarp::sig::PixelRgbInt self) -> PixelRgbInt
        __init__(yarp::sig::PixelRgbInt self, int n_r, int n_g, int n_b) -> PixelRgbInt
        """
        this = _yarp.new_PixelRgbInt(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _yarp.delete_PixelRgbInt
    __del__ = lambda self: None
PixelRgbInt_swigregister = _yarp.PixelRgbInt_swigregister
PixelRgbInt_swigregister(PixelRgbInt)

class PixelHsvFloat(_object):
    """Proxy of C++ yarp::sig::PixelHsvFloat class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PixelHsvFloat, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PixelHsvFloat, name)
    __repr__ = _swig_repr
    __swig_setmethods__["h"] = _yarp.PixelHsvFloat_h_set
    __swig_getmethods__["h"] = _yarp.PixelHsvFloat_h_get
    if _newclass:
        h = _swig_property(_yarp.PixelHsvFloat_h_get, _yarp.PixelHsvFloat_h_set)
    __swig_setmethods__["s"] = _yarp.PixelHsvFloat_s_set
    __swig_getmethods__["s"] = _yarp.PixelHsvFloat_s_get
    if _newclass:
        s = _swig_property(_yarp.PixelHsvFloat_s_get, _yarp.PixelHsvFloat_s_set)
    __swig_setmethods__["v"] = _yarp.PixelHsvFloat_v_set
    __swig_getmethods__["v"] = _yarp.PixelHsvFloat_v_get
    if _newclass:
        v = _swig_property(_yarp.PixelHsvFloat_v_get, _yarp.PixelHsvFloat_v_set)

    def __init__(self):
        """__init__(yarp::sig::PixelHsvFloat self) -> PixelHsvFloat"""
        this = _yarp.new_PixelHsvFloat()
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _yarp.delete_PixelHsvFloat
    __del__ = lambda self: None
PixelHsvFloat_swigregister = _yarp.PixelHsvFloat_swigregister
PixelHsvFloat_swigregister(PixelHsvFloat)


_yarp.FORMAT_NULL_swigconstant(_yarp)
FORMAT_NULL = _yarp.FORMAT_NULL

_yarp.FORMAT_ANY_swigconstant(_yarp)
FORMAT_ANY = _yarp.FORMAT_ANY

_yarp.FORMAT_PGM_swigconstant(_yarp)
FORMAT_PGM = _yarp.FORMAT_PGM

_yarp.FORMAT_PPM_swigconstant(_yarp)
FORMAT_PPM = _yarp.FORMAT_PPM

_yarp.FORMAT_NUMERIC_swigconstant(_yarp)
FORMAT_NUMERIC = _yarp.FORMAT_NUMERIC

def read(*args):
    """
    read(ImageRgb dest, yarp::os::ConstString const & src) -> bool
    read(yarp::sig::ImageOf< yarp::sig::PixelBgr > & dest, yarp::os::ConstString const & src) -> bool
    read(ImageRgba dest, yarp::os::ConstString const & src) -> bool
    read(ImageMono dest, yarp::os::ConstString const & src) -> bool
    read(ImageFloat dest, yarp::os::ConstString const & src) -> bool
    """
    return _yarp.read(*args)

def write(*args):
    """
    write(ImageRgb src, yarp::os::ConstString const & dest) -> bool
    write(yarp::sig::ImageOf< yarp::sig::PixelBgr > const & src, yarp::os::ConstString const & dest) -> bool
    write(ImageRgba src, yarp::os::ConstString const & dest) -> bool
    write(ImageMono src, yarp::os::ConstString const & dest) -> bool
    write(ImageFloat src, yarp::os::ConstString const & dest) -> bool
    write(Image src, yarp::os::ConstString const & dest) -> bool
    """
    return _yarp.write(*args)
class Sound(Portable):
    """Proxy of C++ yarp::sig::Sound class."""

    __swig_setmethods__ = {}
    for _s in [Portable]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Sound, name, value)
    __swig_getmethods__ = {}
    for _s in [Portable]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Sound, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(yarp::sig::Sound self, int bytesPerSample=2) -> Sound
        __init__(yarp::sig::Sound self) -> Sound
        __init__(yarp::sig::Sound self, Sound alt) -> Sound
        """
        this = _yarp.new_Sound(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _yarp.delete_Sound
    __del__ = lambda self: None

    def __iadd__(self, alt):
        """__iadd__(Sound self, Sound alt) -> Sound"""
        return _yarp.Sound___iadd__(self, alt)


    def subSound(self, first_sample, last_sample):
        """subSound(Sound self, int first_sample, int last_sample) -> Sound"""
        return _yarp.Sound_subSound(self, first_sample, last_sample)


    def resize(self, samples, channels=1):
        """
        resize(Sound self, int samples, int channels=1)
        resize(Sound self, int samples)
        """
        return _yarp.Sound_resize(self, samples, channels)


    def get(self, sample, channel=0):
        """
        get(Sound self, int sample, int channel=0) -> int
        get(Sound self, int sample) -> int
        """
        return _yarp.Sound_get(self, sample, channel)


    def set(self, value, sample, channel=0):
        """
        set(Sound self, int value, int sample, int channel=0)
        set(Sound self, int value, int sample)
        """
        return _yarp.Sound_set(self, value, sample, channel)


    def getSafe(self, sample, channel=0):
        """
        getSafe(Sound self, int sample, int channel=0) -> int
        getSafe(Sound self, int sample) -> int
        """
        return _yarp.Sound_getSafe(self, sample, channel)


    def setSafe(self, value, sample, channel=0):
        """
        setSafe(Sound self, int value, int sample, int channel=0)
        setSafe(Sound self, int value, int sample)
        """
        return _yarp.Sound_setSafe(self, value, sample, channel)


    def isSample(self, sample, channel=0):
        """
        isSample(Sound self, int sample, int channel=0) -> bool
        isSample(Sound self, int sample) -> bool
        """
        return _yarp.Sound_isSample(self, sample, channel)


    def clear(self):
        """clear(Sound self)"""
        return _yarp.Sound_clear(self)


    def getFrequency(self):
        """getFrequency(Sound self) -> int"""
        return _yarp.Sound_getFrequency(self)


    def setFrequency(self, freq):
        """setFrequency(Sound self, int freq)"""
        return _yarp.Sound_setFrequency(self, freq)


    def getBytesPerSample(self):
        """getBytesPerSample(Sound self) -> int"""
        return _yarp.Sound_getBytesPerSample(self)


    def getSamples(self):
        """getSamples(Sound self) -> int"""
        return _yarp.Sound_getSamples(self)


    def getChannels(self):
        """getChannels(Sound self) -> int"""
        return _yarp.Sound_getChannels(self)


    def read(self, connection):
        """read(Sound self, ConnectionReader connection) -> bool"""
        return _yarp.Sound_read(self, connection)


    def write(self, connection):
        """write(Sound self, ConnectionWriter connection) -> bool"""
        return _yarp.Sound_write(self, connection)


    def getRawData(self):
        """getRawData(Sound self) -> unsigned char *"""
        return _yarp.Sound_getRawData(self)


    def getRawDataSize(self):
        """getRawDataSize(Sound self) -> int"""
        return _yarp.Sound_getRawDataSize(self)

Sound_swigregister = _yarp.Sound_swigregister
Sound_swigregister(Sound)


def submatrix(arg1, out, r1, r2, c1, c2):
    """submatrix(Matrix arg1, Matrix out, int r1, int r2, int c1, int c2) -> bool"""
    return _yarp.submatrix(arg1, out, r1, r2, c1, c2)

def removeCols(arg1, out, first_col, how_many):
    """removeCols(Matrix arg1, Matrix out, int first_col, int how_many) -> bool"""
    return _yarp.removeCols(arg1, out, first_col, how_many)

def removeRows(arg1, out, first_row, how_many):
    """removeRows(Matrix arg1, Matrix out, int first_row, int how_many) -> bool"""
    return _yarp.removeRows(arg1, out, first_row, how_many)
class Matrix(Portable):
    """Proxy of C++ yarp::sig::Matrix class."""

    __swig_setmethods__ = {}
    for _s in [Portable]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Matrix, name, value)
    __swig_getmethods__ = {}
    for _s in [Portable]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Matrix, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(yarp::sig::Matrix self) -> Matrix
        __init__(yarp::sig::Matrix self, int r, int c) -> Matrix
        __init__(yarp::sig::Matrix self, Matrix m) -> Matrix
        """
        this = _yarp.new_Matrix(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _yarp.delete_Matrix
    __del__ = lambda self: None

    def rows(self):
        """rows(Matrix self) -> int"""
        return _yarp.Matrix_rows(self)


    def cols(self):
        """cols(Matrix self) -> int"""
        return _yarp.Matrix_cols(self)


    def resize(self, r, c):
        """resize(Matrix self, int r, int c)"""
        return _yarp.Matrix_resize(self, r, c)


    def access(self, *args):
        """
        access(Matrix self, int r, int c) -> double const
        access(Matrix self, int r, int c) -> double &
        """
        return _yarp.Matrix_access(self, *args)


    def zero(self):
        """zero(Matrix self)"""
        return _yarp.Matrix_zero(self)


    def setRow(self, row, r):
        """setRow(Matrix self, int row, Vector const & r) -> bool"""
        return _yarp.Matrix_setRow(self, row, r)


    def setCol(self, col, c):
        """setCol(Matrix self, int col, Vector const & c) -> bool"""
        return _yarp.Matrix_setCol(self, col, c)


    def transposed(self):
        """transposed(Matrix self) -> Matrix"""
        return _yarp.Matrix_transposed(self)


    def eye(self):
        """eye(Matrix self) -> Matrix"""
        return _yarp.Matrix_eye(self)


    def diagonal(self, d):
        """diagonal(Matrix self, Vector const & d) -> Matrix"""
        return _yarp.Matrix_diagonal(self, d)


    def submatrix(self, r1, r2, c1, c2):
        """submatrix(Matrix self, int r1, int r2, int c1, int c2) -> Matrix"""
        return _yarp.Matrix_submatrix(self, r1, r2, c1, c2)


    def setSubmatrix(self, m, r, c):
        """setSubmatrix(Matrix self, Matrix m, int r, int c) -> bool"""
        return _yarp.Matrix_setSubmatrix(self, m, r, c)


    def setSubrow(self, v, r, c):
        """setSubrow(Matrix self, Vector const & v, int r, int c) -> bool"""
        return _yarp.Matrix_setSubrow(self, v, r, c)


    def setSubcol(self, v, r, c):
        """setSubcol(Matrix self, Vector const & v, int r, int c) -> bool"""
        return _yarp.Matrix_setSubcol(self, v, r, c)


    def getRow(self, r):
        """getRow(Matrix self, int r) -> Vector"""
        return _yarp.Matrix_getRow(self, r)


    def getCol(self, c):
        """getCol(Matrix self, int c) -> Vector"""
        return _yarp.Matrix_getCol(self, c)


    def removeCols(self, first_col, how_many):
        """removeCols(Matrix self, int first_col, int how_many) -> Matrix"""
        return _yarp.Matrix_removeCols(self, first_col, how_many)


    def removeRows(self, first_row, how_many):
        """removeRows(Matrix self, int first_row, int how_many) -> Matrix"""
        return _yarp.Matrix_removeRows(self, first_row, how_many)


    def subrow(self, r, c, size):
        """subrow(Matrix self, int r, int c, int size) -> Vector"""
        return _yarp.Matrix_subrow(self, r, c, size)


    def subcol(self, r, c, size):
        """subcol(Matrix self, int r, int c, int size) -> Vector"""
        return _yarp.Matrix_subcol(self, r, c, size)


    def toString(self, *args):
        """
        toString(Matrix self, int precision=-1, int width=-1, char const * endRowStr) -> yarp::os::ConstString
        toString(Matrix self, int precision=-1, int width=-1) -> yarp::os::ConstString
        toString(Matrix self, int precision=-1) -> yarp::os::ConstString
        """
        return _yarp.Matrix_toString(self, *args)


    def toString_c(self, *args):
        """toString_c(Matrix self) -> yarp::os::ConstString"""
        return _yarp.Matrix_toString_c(self, *args)


    def data(self, *args):
        """
        data(Matrix self) -> double
        data(Matrix self) -> double const *
        """
        return _yarp.Matrix_data(self, *args)


    def isEqual(self, r):
        """isEqual(Matrix self, Matrix r) -> bool"""
        return _yarp.Matrix_isEqual(self, r)


    def read(self, connection):
        """read(Matrix self, ConnectionReader connection) -> bool"""
        return _yarp.Matrix_read(self, connection)


    def write(self, connection):
        """write(Matrix self, ConnectionWriter connection) -> bool"""
        return _yarp.Matrix_write(self, connection)


    def get(self, i, j):
        """get(Matrix self, int i, int j) -> double"""
        return _yarp.Matrix_get(self, i, j)


    def set(self, i, j, v):
        """set(Matrix self, int i, int j, double v)"""
        return _yarp.Matrix_set(self, i, j, v)


    def __setitem__(self, matrix_i_row, value):
        """__setitem__(Matrix self, int matrix_i_row, double value)"""
        return _yarp.Matrix___setitem__(self, matrix_i_row, value)


    def __getitem__(self, matrix_i_row):
        """__getitem__(Matrix self, int matrix_i_row) -> double"""
        return _yarp.Matrix___getitem__(self, matrix_i_row)

Matrix_swigregister = _yarp.Matrix_swigregister
Matrix_swigregister(Matrix)

class VectorBase(Portable):
    """Proxy of C++ yarp::sig::VectorBase class."""

    __swig_setmethods__ = {}
    for _s in [Portable]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, VectorBase, name, value)
    __swig_getmethods__ = {}
    for _s in [Portable]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, VectorBase, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def getElementSize(self):
        """getElementSize(VectorBase self) -> int"""
        return _yarp.VectorBase_getElementSize(self)


    def getBottleTag(self):
        """getBottleTag(VectorBase self) -> int"""
        return _yarp.VectorBase_getBottleTag(self)


    def getListSize(self):
        """getListSize(VectorBase self) -> size_t"""
        return _yarp.VectorBase_getListSize(self)


    def getMemoryBlock(self):
        """getMemoryBlock(VectorBase self) -> char const *"""
        return _yarp.VectorBase_getMemoryBlock(self)


    def resize(self, size):
        """resize(VectorBase self, size_t size)"""
        return _yarp.VectorBase_resize(self, size)


    def read(self, connection):
        """read(VectorBase self, ConnectionReader connection) -> bool"""
        return _yarp.VectorBase_read(self, connection)


    def write(self, connection):
        """write(VectorBase self, ConnectionWriter connection) -> bool"""
        return _yarp.VectorBase_write(self, connection)

    __swig_destroy__ = _yarp.delete_VectorBase
    __del__ = lambda self: None
VectorBase_swigregister = _yarp.VectorBase_swigregister
VectorBase_swigregister(VectorBase)

class Vector(Portable):
    """Proxy of C++ yarp::sig::Vector class."""

    __swig_setmethods__ = {}
    for _s in [Portable]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Vector, name, value)
    __swig_getmethods__ = {}
    for _s in [Portable]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Vector, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_Vector
    __del__ = lambda self: None

    def __init__(self, *args):
        """
        __init__(yarp::sig::Vector self) -> Vector
        __init__(yarp::sig::Vector self, size_t s) -> Vector
        __init__(yarp::sig::Vector self, size_t s, double const & arg3) -> Vector
        __init__(yarp::sig::Vector self, size_t s, double const * p) -> Vector
        __init__(yarp::sig::Vector self, Vector r) -> Vector
        """
        this = _yarp.new_Vector(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def resize(self, *args):
        """
        resize(Vector self, size_t s)
        resize(Vector self, size_t size, double const & arg3)
        """
        return _yarp.Vector_resize(self, *args)


    def size(self):
        """size(Vector self) -> size_t"""
        return _yarp.Vector_size(self)


    def length(self):
        """length(Vector self) -> size_t"""
        return _yarp.Vector_length(self)


    def zero(self):
        """zero(Vector self)"""
        return _yarp.Vector_zero(self)


    def toString(self, precision=-1, width=-1):
        """
        toString(Vector self, int precision=-1, int width=-1) -> yarp::os::ConstString
        toString(Vector self, int precision=-1) -> yarp::os::ConstString
        """
        return _yarp.Vector_toString(self, precision, width)


    def toString_c(self, precision=-1, width=-1):
        """toString_c(Vector self) -> yarp::os::ConstString"""
        return _yarp.Vector_toString_c(self, precision, width)


    def subVector(self, first, last):
        """subVector(Vector self, unsigned int first, unsigned int last) -> Vector"""
        return _yarp.Vector_subVector(self, first, last)


    def setSubvector(self, position, v):
        """setSubvector(Vector self, int position, Vector v) -> bool"""
        return _yarp.Vector_setSubvector(self, position, v)


    def data(self, *args):
        """
        data(Vector self) -> double
        data(Vector self) -> double const *
        """
        return _yarp.Vector_data(self, *args)


    def isEqual(self, r):
        """isEqual(Vector self, Vector r) -> bool"""
        return _yarp.Vector_isEqual(self, r)


    def push_back(self, elem):
        """push_back(Vector self, double const & elem)"""
        return _yarp.Vector_push_back(self, elem)


    def pop_back(self):
        """pop_back(Vector self)"""
        return _yarp.Vector_pop_back(self)


    def access(self, *args):
        """
        access(Vector self, size_t i) -> double
        access(Vector self, size_t i) -> double const &
        """
        return _yarp.Vector_access(self, *args)


    def clear(self):
        """clear(Vector self)"""
        return _yarp.Vector_clear(self)


    def read(self, connection):
        """read(Vector self, ConnectionReader connection) -> bool"""
        return _yarp.Vector_read(self, connection)


    def write(self, connection):
        """write(Vector self, ConnectionWriter connection) -> bool"""
        return _yarp.Vector_write(self, connection)


    def get(self, j):
        """get(Vector self, int j) -> double"""
        return _yarp.Vector_get(self, j)


    def set(self, j, v):
        """set(Vector self, int j, double v)"""
        return _yarp.Vector_set(self, j, v)


    def __setitem__(self, key, value):
        """__setitem__(Vector self, int key, double value)"""
        return _yarp.Vector___setitem__(self, key, value)


    def __getitem__(self, key):
        """__getitem__(Vector self, int key) -> double"""
        return _yarp.Vector___getitem__(self, key)


    def __len__(self):
        """__len__(Vector self) -> double"""
        return _yarp.Vector___len__(self)

Vector_swigregister = _yarp.Vector_swigregister
Vector_swigregister(Vector)

class IConfig(_object):
    """Proxy of C++ yarp::os::IConfig class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IConfig, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IConfig, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_IConfig
    __del__ = lambda self: None

    def open(self, config):
        """open(IConfig self, Searchable config) -> bool"""
        return _yarp.IConfig_open(self, config)


    def close(self):
        """close(IConfig self) -> bool"""
        return _yarp.IConfig_close(self)


    def configure(self, config):
        """configure(IConfig self, Searchable config) -> bool"""
        return _yarp.IConfig_configure(self, config)


    def __init__(self):
        """__init__(yarp::os::IConfig self) -> IConfig"""
        this = _yarp.new_IConfig()
        try:
            self.this.append(this)
        except Exception:
            self.this = this
IConfig_swigregister = _yarp.IConfig_swigregister
IConfig_swigregister(IConfig)

class DeviceDriver(IConfig):
    """Proxy of C++ yarp::dev::DeviceDriver class."""

    __swig_setmethods__ = {}
    for _s in [IConfig]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, DeviceDriver, name, value)
    __swig_getmethods__ = {}
    for _s in [IConfig]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, DeviceDriver, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_DeviceDriver
    __del__ = lambda self: None

    def open(self, config):
        """open(DeviceDriver self, Searchable config) -> bool"""
        return _yarp.DeviceDriver_open(self, config)


    def close(self):
        """close(DeviceDriver self) -> bool"""
        return _yarp.DeviceDriver_close(self)


    def getImplementation(self):
        """getImplementation(DeviceDriver self) -> DeviceDriver"""
        return _yarp.DeviceDriver_getImplementation(self)


    def __init__(self):
        """__init__(yarp::dev::DeviceDriver self) -> DeviceDriver"""
        this = _yarp.new_DeviceDriver()
        try:
            self.this.append(this)
        except Exception:
            self.this = this
DeviceDriver_swigregister = _yarp.DeviceDriver_swigregister
DeviceDriver_swigregister(DeviceDriver)

class DeprecatedDeviceDriver(DeviceDriver):
    """Proxy of C++ yarp::dev::DeprecatedDeviceDriver class."""

    __swig_setmethods__ = {}
    for _s in [DeviceDriver]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, DeprecatedDeviceDriver, name, value)
    __swig_getmethods__ = {}
    for _s in [DeviceDriver]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, DeprecatedDeviceDriver, name)
    __repr__ = _swig_repr

    def __init__(self):
        """__init__(yarp::dev::DeprecatedDeviceDriver self) -> DeprecatedDeviceDriver"""
        this = _yarp.new_DeprecatedDeviceDriver()
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _yarp.delete_DeprecatedDeviceDriver
    __del__ = lambda self: None
DeprecatedDeviceDriver_swigregister = _yarp.DeprecatedDeviceDriver_swigregister
DeprecatedDeviceDriver_swigregister(DeprecatedDeviceDriver)

class DeviceResponder(PortReader, BottleCallback):
    """Proxy of C++ yarp::dev::DeviceResponder class."""

    __swig_setmethods__ = {}
    for _s in [PortReader, BottleCallback]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, DeviceResponder, name, value)
    __swig_getmethods__ = {}
    for _s in [PortReader, BottleCallback]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, DeviceResponder, name)
    __repr__ = _swig_repr

    def __init__(self):
        """__init__(yarp::dev::DeviceResponder self) -> DeviceResponder"""
        this = _yarp.new_DeviceResponder()
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def addUsage(self, *args):
        """
        addUsage(DeviceResponder self, char const * txt, char const * explain=None)
        addUsage(DeviceResponder self, char const * txt)
        addUsage(DeviceResponder self, Bottle bot, char const * explain=None)
        addUsage(DeviceResponder self, Bottle bot)
        """
        return _yarp.DeviceResponder_addUsage(self, *args)


    def respond(self, command, reply):
        """respond(DeviceResponder self, Bottle command, Bottle reply) -> bool"""
        return _yarp.DeviceResponder_respond(self, command, reply)


    def read(self, connection):
        """read(DeviceResponder self, ConnectionReader connection) -> bool"""
        return _yarp.DeviceResponder_read(self, connection)


    def onRead(self, *args):
        """
        onRead(DeviceResponder self, Bottle datum, TypedReaderBottle reader)
        onRead(DeviceResponder self, Bottle v)
        """
        return _yarp.DeviceResponder_onRead(self, *args)


    def makeUsage(self):
        """makeUsage(DeviceResponder self)"""
        return _yarp.DeviceResponder_makeUsage(self)


    def attach(self, source):
        """attach(DeviceResponder self, TypedReaderBottle source)"""
        return _yarp.DeviceResponder_attach(self, source)

    __swig_destroy__ = _yarp.delete_DeviceResponder
    __del__ = lambda self: None
DeviceResponder_swigregister = _yarp.DeviceResponder_swigregister
DeviceResponder_swigregister(DeviceResponder)

class PolyDriver(DeviceDriver):
    """Proxy of C++ yarp::dev::PolyDriver class."""

    __swig_setmethods__ = {}
    for _s in [DeviceDriver]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, PolyDriver, name, value)
    __swig_getmethods__ = {}
    for _s in [DeviceDriver]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, PolyDriver, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(yarp::dev::PolyDriver self) -> PolyDriver
        __init__(yarp::dev::PolyDriver self, yarp::os::ConstString const & txt) -> PolyDriver
        __init__(yarp::dev::PolyDriver self, Searchable config) -> PolyDriver
        """
        this = _yarp.new_PolyDriver(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def open_str(self, txt):
        """open_str(PolyDriver self, yarp::os::ConstString const & txt) -> bool"""
        return _yarp.PolyDriver_open_str(self, txt)


    def open(self, config):
        """open(PolyDriver self, Searchable config) -> bool"""
        return _yarp.PolyDriver_open(self, config)


    def link(self, alt):
        """link(PolyDriver self, PolyDriver alt) -> bool"""
        return _yarp.PolyDriver_link(self, alt)


    def take(self):
        """take(PolyDriver self) -> DeviceDriver"""
        return _yarp.PolyDriver_take(self)


    def give(self, dd, own):
        """give(PolyDriver self, DeviceDriver dd, bool own) -> bool"""
        return _yarp.PolyDriver_give(self, dd, own)

    __swig_destroy__ = _yarp.delete_PolyDriver
    __del__ = lambda self: None

    def close(self):
        """close(PolyDriver self) -> bool"""
        return _yarp.PolyDriver_close(self)


    def isValid(self):
        """isValid(PolyDriver self) -> bool"""
        return _yarp.PolyDriver_isValid(self)


    def getOptions(self):
        """getOptions(PolyDriver self) -> Bottle"""
        return _yarp.PolyDriver_getOptions(self)


    def getComment(self, option):
        """getComment(PolyDriver self, char const * option) -> yarp::os::ConstString"""
        return _yarp.PolyDriver_getComment(self, option)


    def getDefaultValue(self, option):
        """getDefaultValue(PolyDriver self, char const * option) -> Value"""
        return _yarp.PolyDriver_getDefaultValue(self, option)


    def getValue(self, option):
        """getValue(PolyDriver self, char const * option) -> Value"""
        return _yarp.PolyDriver_getValue(self, option)


    def getImplementation(self):
        """getImplementation(PolyDriver self) -> DeviceDriver"""
        return _yarp.PolyDriver_getImplementation(self)


    def viewFrameGrabberImage(self):
        """viewFrameGrabberImage(PolyDriver self) -> IFrameGrabberImage"""
        return _yarp.PolyDriver_viewFrameGrabberImage(self)


    def viewIPositionControl(self):
        """viewIPositionControl(PolyDriver self) -> IPositionControl"""
        return _yarp.PolyDriver_viewIPositionControl(self)


    def viewIVelocityControl(self):
        """viewIVelocityControl(PolyDriver self) -> IVelocityControl"""
        return _yarp.PolyDriver_viewIVelocityControl(self)


    def viewIEncoders(self):
        """viewIEncoders(PolyDriver self) -> IEncoders"""
        return _yarp.PolyDriver_viewIEncoders(self)


    def viewIPidControl(self):
        """viewIPidControl(PolyDriver self) -> IPidControl"""
        return _yarp.PolyDriver_viewIPidControl(self)


    def viewIAmplifierControl(self):
        """viewIAmplifierControl(PolyDriver self) -> IAmplifierControl"""
        return _yarp.PolyDriver_viewIAmplifierControl(self)


    def viewIControlLimits(self):
        """viewIControlLimits(PolyDriver self) -> IControlLimits"""
        return _yarp.PolyDriver_viewIControlLimits(self)


    def viewICartesianControl(self):
        """viewICartesianControl(PolyDriver self) -> ICartesianControl"""
        return _yarp.PolyDriver_viewICartesianControl(self)


    def viewIGazeControl(self):
        """viewIGazeControl(PolyDriver self) -> IGazeControl"""
        return _yarp.PolyDriver_viewIGazeControl(self)


    def viewIImpedanceControl(self):
        """viewIImpedanceControl(PolyDriver self) -> IImpedanceControl"""
        return _yarp.PolyDriver_viewIImpedanceControl(self)


    def viewITorqueControl(self):
        """viewITorqueControl(PolyDriver self) -> ITorqueControl"""
        return _yarp.PolyDriver_viewITorqueControl(self)


    def viewIControlMode(self):
        """viewIControlMode(PolyDriver self) -> IControlMode"""
        return _yarp.PolyDriver_viewIControlMode(self)


    def viewIControlMode2(self):
        """viewIControlMode2(PolyDriver self) -> IControlMode2"""
        return _yarp.PolyDriver_viewIControlMode2(self)


    def viewIPWMControl(self):
        """viewIPWMControl(PolyDriver self) -> IPWMControl"""
        return _yarp.PolyDriver_viewIPWMControl(self)


    def viewICurrentControl(self):
        """viewICurrentControl(PolyDriver self) -> ICurrentControl"""
        return _yarp.PolyDriver_viewICurrentControl(self)


    def viewIAnalogSensor(self):
        """viewIAnalogSensor(PolyDriver self) -> IAnalogSensor"""
        return _yarp.PolyDriver_viewIAnalogSensor(self)


    def viewIFrameGrabberControls2(self):
        """viewIFrameGrabberControls2(PolyDriver self) -> IFrameGrabberControls2"""
        return _yarp.PolyDriver_viewIFrameGrabberControls2(self)


    def viewIPositionDirect(self):
        """viewIPositionDirect(PolyDriver self) -> IPositionDirect"""
        return _yarp.PolyDriver_viewIPositionDirect(self)

PolyDriver_swigregister = _yarp.PolyDriver_swigregister
PolyDriver_swigregister(PolyDriver)

class DriverCreator(_object):
    """Proxy of C++ yarp::dev::DriverCreator class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, DriverCreator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, DriverCreator, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_DriverCreator
    __del__ = lambda self: None

    def toString(self):
        """toString(DriverCreator self) -> yarp::os::ConstString"""
        return _yarp.DriverCreator_toString(self)


    def create(self):
        """create(DriverCreator self) -> DeviceDriver"""
        return _yarp.DriverCreator_create(self)


    def getName(self):
        """getName(DriverCreator self) -> yarp::os::ConstString"""
        return _yarp.DriverCreator_getName(self)


    def getWrapper(self):
        """getWrapper(DriverCreator self) -> yarp::os::ConstString"""
        return _yarp.DriverCreator_getWrapper(self)


    def getCode(self):
        """getCode(DriverCreator self) -> yarp::os::ConstString"""
        return _yarp.DriverCreator_getCode(self)


    def owner(self):
        """owner(DriverCreator self) -> PolyDriver"""
        return _yarp.DriverCreator_owner(self)

DriverCreator_swigregister = _yarp.DriverCreator_swigregister
DriverCreator_swigregister(DriverCreator)

class StubDriverCreator(DriverCreator):
    """Proxy of C++ yarp::dev::StubDriverCreator class."""

    __swig_setmethods__ = {}
    for _s in [DriverCreator]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, StubDriverCreator, name, value)
    __swig_getmethods__ = {}
    for _s in [DriverCreator]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, StubDriverCreator, name)
    __repr__ = _swig_repr

    def __init__(self, name, wrap, code, libname, fnname):
        """__init__(yarp::dev::StubDriverCreator self, char const * name, char const * wrap, char const * code, char const * libname, char const * fnname) -> StubDriverCreator"""
        this = _yarp.new_StubDriverCreator(name, wrap, code, libname, fnname)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def toString(self):
        """toString(StubDriverCreator self) -> yarp::os::ConstString"""
        return _yarp.StubDriverCreator_toString(self)


    def getName(self):
        """getName(StubDriverCreator self) -> yarp::os::ConstString"""
        return _yarp.StubDriverCreator_getName(self)


    def getWrapper(self):
        """getWrapper(StubDriverCreator self) -> yarp::os::ConstString"""
        return _yarp.StubDriverCreator_getWrapper(self)


    def getCode(self):
        """getCode(StubDriverCreator self) -> yarp::os::ConstString"""
        return _yarp.StubDriverCreator_getCode(self)


    def create(self):
        """create(StubDriverCreator self) -> DeviceDriver"""
        return _yarp.StubDriverCreator_create(self)

    __swig_destroy__ = _yarp.delete_StubDriverCreator
    __del__ = lambda self: None
StubDriverCreator_swigregister = _yarp.StubDriverCreator_swigregister
StubDriverCreator_swigregister(StubDriverCreator)

class Drivers(_object):
    """Proxy of C++ yarp::dev::Drivers class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Drivers, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Drivers, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def factory():
        """factory() -> Drivers"""
        return _yarp.Drivers_factory()

    if _newclass:
        factory = staticmethod(factory)
    __swig_getmethods__["factory"] = lambda x: factory

    def open(self, *args):
        """
        open(Drivers self, char const * device) -> DeviceDriver
        open(Drivers self, Searchable config) -> DeviceDriver
        """
        return _yarp.Drivers_open(self, *args)


    def toString(self):
        """toString(Drivers self) -> yarp::os::ConstString"""
        return _yarp.Drivers_toString(self)

    __swig_destroy__ = _yarp.delete_Drivers
    __del__ = lambda self: None

    def add(self, creator):
        """add(Drivers self, DriverCreator creator)"""
        return _yarp.Drivers_add(self, creator)


    def find(self, name):
        """find(Drivers self, char const * name) -> DriverCreator"""
        return _yarp.Drivers_find(self, name)


    def remove(self, name):
        """remove(Drivers self, char const * name) -> bool"""
        return _yarp.Drivers_remove(self, name)


    def yarpdev(argc):
        """yarpdev(int argc) -> int"""
        return _yarp.Drivers_yarpdev(argc)

    if _newclass:
        yarpdev = staticmethod(yarpdev)
    __swig_getmethods__["yarpdev"] = lambda x: yarpdev
Drivers_swigregister = _yarp.Drivers_swigregister
Drivers_swigregister(Drivers)

def Drivers_factory():
    """Drivers_factory() -> Drivers"""
    return _yarp.Drivers_factory()

def Drivers_yarpdev(argc):
    """Drivers_yarpdev(int argc) -> int"""
    return _yarp.Drivers_yarpdev(argc)


_yarp.YARP_CROP_RECT_swigconstant(_yarp)
YARP_CROP_RECT = _yarp.YARP_CROP_RECT

_yarp.YARP_CROP_LIST_swigconstant(_yarp)
YARP_CROP_LIST = _yarp.YARP_CROP_LIST

_yarp.YARP_FEATURE_BRIGHTNESS_swigconstant(_yarp)
YARP_FEATURE_BRIGHTNESS = _yarp.YARP_FEATURE_BRIGHTNESS

_yarp.YARP_FEATURE_EXPOSURE_swigconstant(_yarp)
YARP_FEATURE_EXPOSURE = _yarp.YARP_FEATURE_EXPOSURE

_yarp.YARP_FEATURE_SHARPNESS_swigconstant(_yarp)
YARP_FEATURE_SHARPNESS = _yarp.YARP_FEATURE_SHARPNESS

_yarp.YARP_FEATURE_WHITE_BALANCE_swigconstant(_yarp)
YARP_FEATURE_WHITE_BALANCE = _yarp.YARP_FEATURE_WHITE_BALANCE

_yarp.YARP_FEATURE_HUE_swigconstant(_yarp)
YARP_FEATURE_HUE = _yarp.YARP_FEATURE_HUE

_yarp.YARP_FEATURE_SATURATION_swigconstant(_yarp)
YARP_FEATURE_SATURATION = _yarp.YARP_FEATURE_SATURATION

_yarp.YARP_FEATURE_GAMMA_swigconstant(_yarp)
YARP_FEATURE_GAMMA = _yarp.YARP_FEATURE_GAMMA

_yarp.YARP_FEATURE_SHUTTER_swigconstant(_yarp)
YARP_FEATURE_SHUTTER = _yarp.YARP_FEATURE_SHUTTER

_yarp.YARP_FEATURE_GAIN_swigconstant(_yarp)
YARP_FEATURE_GAIN = _yarp.YARP_FEATURE_GAIN

_yarp.YARP_FEATURE_IRIS_swigconstant(_yarp)
YARP_FEATURE_IRIS = _yarp.YARP_FEATURE_IRIS

_yarp.YARP_FEATURE_FOCUS_swigconstant(_yarp)
YARP_FEATURE_FOCUS = _yarp.YARP_FEATURE_FOCUS

_yarp.YARP_FEATURE_TEMPERATURE_swigconstant(_yarp)
YARP_FEATURE_TEMPERATURE = _yarp.YARP_FEATURE_TEMPERATURE

_yarp.YARP_FEATURE_TRIGGER_swigconstant(_yarp)
YARP_FEATURE_TRIGGER = _yarp.YARP_FEATURE_TRIGGER

_yarp.YARP_FEATURE_TRIGGER_DELAY_swigconstant(_yarp)
YARP_FEATURE_TRIGGER_DELAY = _yarp.YARP_FEATURE_TRIGGER_DELAY

_yarp.YARP_FEATURE_WHITE_SHADING_swigconstant(_yarp)
YARP_FEATURE_WHITE_SHADING = _yarp.YARP_FEATURE_WHITE_SHADING

_yarp.YARP_FEATURE_FRAME_RATE_swigconstant(_yarp)
YARP_FEATURE_FRAME_RATE = _yarp.YARP_FEATURE_FRAME_RATE

_yarp.YARP_FEATURE_ZOOM_swigconstant(_yarp)
YARP_FEATURE_ZOOM = _yarp.YARP_FEATURE_ZOOM

_yarp.YARP_FEATURE_PAN_swigconstant(_yarp)
YARP_FEATURE_PAN = _yarp.YARP_FEATURE_PAN

_yarp.YARP_FEATURE_TILT_swigconstant(_yarp)
YARP_FEATURE_TILT = _yarp.YARP_FEATURE_TILT

_yarp.YARP_FEATURE_OPTICAL_FILTER_swigconstant(_yarp)
YARP_FEATURE_OPTICAL_FILTER = _yarp.YARP_FEATURE_OPTICAL_FILTER

_yarp.YARP_FEATURE_CAPTURE_SIZE_swigconstant(_yarp)
YARP_FEATURE_CAPTURE_SIZE = _yarp.YARP_FEATURE_CAPTURE_SIZE

_yarp.YARP_FEATURE_CAPTURE_QUALITY_swigconstant(_yarp)
YARP_FEATURE_CAPTURE_QUALITY = _yarp.YARP_FEATURE_CAPTURE_QUALITY

_yarp.YARP_FEATURE_MIRROR_swigconstant(_yarp)
YARP_FEATURE_MIRROR = _yarp.YARP_FEATURE_MIRROR

_yarp.YARP_FEATURE_NUMBER_OF_swigconstant(_yarp)
YARP_FEATURE_NUMBER_OF = _yarp.YARP_FEATURE_NUMBER_OF
class IFrameGrabber(_object):
    """Proxy of C++ yarp::dev::IFrameGrabber class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IFrameGrabber, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IFrameGrabber, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_IFrameGrabber
    __del__ = lambda self: None

    def getRawBuffer(self, buffer):
        """getRawBuffer(IFrameGrabber self, unsigned char * buffer) -> bool"""
        return _yarp.IFrameGrabber_getRawBuffer(self, buffer)


    def getRawBufferSize(self):
        """getRawBufferSize(IFrameGrabber self) -> int"""
        return _yarp.IFrameGrabber_getRawBufferSize(self)


    def height(self):
        """height(IFrameGrabber self) -> int"""
        return _yarp.IFrameGrabber_height(self)


    def width(self):
        """width(IFrameGrabber self) -> int"""
        return _yarp.IFrameGrabber_width(self)

IFrameGrabber_swigregister = _yarp.IFrameGrabber_swigregister
IFrameGrabber_swigregister(IFrameGrabber)

class IFrameGrabberRgb(_object):
    """Proxy of C++ yarp::dev::IFrameGrabberRgb class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IFrameGrabberRgb, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IFrameGrabberRgb, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_IFrameGrabberRgb
    __del__ = lambda self: None

    def getRgbBuffer(self, buffer):
        """getRgbBuffer(IFrameGrabberRgb self, unsigned char * buffer) -> bool"""
        return _yarp.IFrameGrabberRgb_getRgbBuffer(self, buffer)


    def height(self):
        """height(IFrameGrabberRgb self) -> int"""
        return _yarp.IFrameGrabberRgb_height(self)


    def width(self):
        """width(IFrameGrabberRgb self) -> int"""
        return _yarp.IFrameGrabberRgb_width(self)

IFrameGrabberRgb_swigregister = _yarp.IFrameGrabberRgb_swigregister
IFrameGrabberRgb_swigregister(IFrameGrabberRgb)

class IFrameGrabberImage(_object):
    """Proxy of C++ yarp::dev::IFrameGrabberImage class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IFrameGrabberImage, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IFrameGrabberImage, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_IFrameGrabberImage
    __del__ = lambda self: None

    def getImage(self, image):
        """getImage(IFrameGrabberImage self, ImageRgb image) -> bool"""
        return _yarp.IFrameGrabberImage_getImage(self, image)


    def getImageCrop(self, cropType, vertices, image):
        """getImageCrop(IFrameGrabberImage self, cropType_id_t cropType, yarp::sig::VectorOf< std::pair< int,int > > vertices, ImageRgb image) -> bool"""
        return _yarp.IFrameGrabberImage_getImageCrop(self, cropType, vertices, image)


    def height(self):
        """height(IFrameGrabberImage self) -> int"""
        return _yarp.IFrameGrabberImage_height(self)


    def width(self):
        """width(IFrameGrabberImage self) -> int"""
        return _yarp.IFrameGrabberImage_width(self)

IFrameGrabberImage_swigregister = _yarp.IFrameGrabberImage_swigregister
IFrameGrabberImage_swigregister(IFrameGrabberImage)

class IFrameGrabberImageRaw(_object):
    """Proxy of C++ yarp::dev::IFrameGrabberImageRaw class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IFrameGrabberImageRaw, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IFrameGrabberImageRaw, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_IFrameGrabberImageRaw
    __del__ = lambda self: None

    def getImage(self, image):
        """getImage(IFrameGrabberImageRaw self, ImageMono image) -> bool"""
        return _yarp.IFrameGrabberImageRaw_getImage(self, image)


    def getImageCrop(self, cropType, vertices, image):
        """getImageCrop(IFrameGrabberImageRaw self, cropType_id_t cropType, yarp::sig::VectorOf< std::pair< int,int > > vertices, ImageMono image) -> bool"""
        return _yarp.IFrameGrabberImageRaw_getImageCrop(self, cropType, vertices, image)


    def height(self):
        """height(IFrameGrabberImageRaw self) -> int"""
        return _yarp.IFrameGrabberImageRaw_height(self)


    def width(self):
        """width(IFrameGrabberImageRaw self) -> int"""
        return _yarp.IFrameGrabberImageRaw_width(self)

IFrameGrabberImageRaw_swigregister = _yarp.IFrameGrabberImageRaw_swigregister
IFrameGrabberImageRaw_swigregister(IFrameGrabberImageRaw)

class IFrameWriterImage(_object):
    """Proxy of C++ yarp::dev::IFrameWriterImage class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IFrameWriterImage, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IFrameWriterImage, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_IFrameWriterImage
    __del__ = lambda self: None

    def putImage(self, image):
        """putImage(IFrameWriterImage self, ImageRgb image) -> bool"""
        return _yarp.IFrameWriterImage_putImage(self, image)

IFrameWriterImage_swigregister = _yarp.IFrameWriterImage_swigregister
IFrameWriterImage_swigregister(IFrameWriterImage)

class IFrameGrabberControls(_object):
    """Proxy of C++ yarp::dev::IFrameGrabberControls class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IFrameGrabberControls, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IFrameGrabberControls, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_IFrameGrabberControls
    __del__ = lambda self: None

    def setBrightness(self, v):
        """setBrightness(IFrameGrabberControls self, double v) -> bool"""
        return _yarp.IFrameGrabberControls_setBrightness(self, v)


    def setExposure(self, v):
        """setExposure(IFrameGrabberControls self, double v) -> bool"""
        return _yarp.IFrameGrabberControls_setExposure(self, v)


    def setSharpness(self, v):
        """setSharpness(IFrameGrabberControls self, double v) -> bool"""
        return _yarp.IFrameGrabberControls_setSharpness(self, v)


    def setWhiteBalance(self, blue, red):
        """setWhiteBalance(IFrameGrabberControls self, double blue, double red) -> bool"""
        return _yarp.IFrameGrabberControls_setWhiteBalance(self, blue, red)


    def setHue(self, v):
        """setHue(IFrameGrabberControls self, double v) -> bool"""
        return _yarp.IFrameGrabberControls_setHue(self, v)


    def setSaturation(self, v):
        """setSaturation(IFrameGrabberControls self, double v) -> bool"""
        return _yarp.IFrameGrabberControls_setSaturation(self, v)


    def setGamma(self, v):
        """setGamma(IFrameGrabberControls self, double v) -> bool"""
        return _yarp.IFrameGrabberControls_setGamma(self, v)


    def setShutter(self, v):
        """setShutter(IFrameGrabberControls self, double v) -> bool"""
        return _yarp.IFrameGrabberControls_setShutter(self, v)


    def setGain(self, v):
        """setGain(IFrameGrabberControls self, double v) -> bool"""
        return _yarp.IFrameGrabberControls_setGain(self, v)


    def setIris(self, v):
        """setIris(IFrameGrabberControls self, double v) -> bool"""
        return _yarp.IFrameGrabberControls_setIris(self, v)


    def getBrightness(self):
        """getBrightness(IFrameGrabberControls self) -> double"""
        return _yarp.IFrameGrabberControls_getBrightness(self)


    def getExposure(self):
        """getExposure(IFrameGrabberControls self) -> double"""
        return _yarp.IFrameGrabberControls_getExposure(self)


    def getSharpness(self):
        """getSharpness(IFrameGrabberControls self) -> double"""
        return _yarp.IFrameGrabberControls_getSharpness(self)


    def getWhiteBalance(self, blue, red):
        """getWhiteBalance(IFrameGrabberControls self, double & blue, double & red) -> bool"""
        return _yarp.IFrameGrabberControls_getWhiteBalance(self, blue, red)


    def getHue(self):
        """getHue(IFrameGrabberControls self) -> double"""
        return _yarp.IFrameGrabberControls_getHue(self)


    def getSaturation(self):
        """getSaturation(IFrameGrabberControls self) -> double"""
        return _yarp.IFrameGrabberControls_getSaturation(self)


    def getGamma(self):
        """getGamma(IFrameGrabberControls self) -> double"""
        return _yarp.IFrameGrabberControls_getGamma(self)


    def getShutter(self):
        """getShutter(IFrameGrabberControls self) -> double"""
        return _yarp.IFrameGrabberControls_getShutter(self)


    def getGain(self):
        """getGain(IFrameGrabberControls self) -> double"""
        return _yarp.IFrameGrabberControls_getGain(self)


    def getIris(self):
        """getIris(IFrameGrabberControls self) -> double"""
        return _yarp.IFrameGrabberControls_getIris(self)

IFrameGrabberControls_swigregister = _yarp.IFrameGrabberControls_swigregister
IFrameGrabberControls_swigregister(IFrameGrabberControls)

class IFrameGrabberControlsDC1394(IFrameGrabberControls):
    """Proxy of C++ yarp::dev::IFrameGrabberControlsDC1394 class."""

    __swig_setmethods__ = {}
    for _s in [IFrameGrabberControls]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IFrameGrabberControlsDC1394, name, value)
    __swig_getmethods__ = {}
    for _s in [IFrameGrabberControls]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IFrameGrabberControlsDC1394, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def hasFeatureDC1394(self, feature):
        """hasFeatureDC1394(IFrameGrabberControlsDC1394 self, int feature) -> bool"""
        return _yarp.IFrameGrabberControlsDC1394_hasFeatureDC1394(self, feature)


    def setFeatureDC1394(self, feature, value):
        """setFeatureDC1394(IFrameGrabberControlsDC1394 self, int feature, double value) -> bool"""
        return _yarp.IFrameGrabberControlsDC1394_setFeatureDC1394(self, feature, value)


    def getFeatureDC1394(self, feature):
        """getFeatureDC1394(IFrameGrabberControlsDC1394 self, int feature) -> double"""
        return _yarp.IFrameGrabberControlsDC1394_getFeatureDC1394(self, feature)


    def hasOnOffDC1394(self, feature):
        """hasOnOffDC1394(IFrameGrabberControlsDC1394 self, int feature) -> bool"""
        return _yarp.IFrameGrabberControlsDC1394_hasOnOffDC1394(self, feature)


    def setActiveDC1394(self, feature, onoff):
        """setActiveDC1394(IFrameGrabberControlsDC1394 self, int feature, bool onoff) -> bool"""
        return _yarp.IFrameGrabberControlsDC1394_setActiveDC1394(self, feature, onoff)


    def getActiveDC1394(self, feature):
        """getActiveDC1394(IFrameGrabberControlsDC1394 self, int feature) -> bool"""
        return _yarp.IFrameGrabberControlsDC1394_getActiveDC1394(self, feature)


    def hasAutoDC1394(self, feature):
        """hasAutoDC1394(IFrameGrabberControlsDC1394 self, int feature) -> bool"""
        return _yarp.IFrameGrabberControlsDC1394_hasAutoDC1394(self, feature)


    def hasManualDC1394(self, feature):
        """hasManualDC1394(IFrameGrabberControlsDC1394 self, int feature) -> bool"""
        return _yarp.IFrameGrabberControlsDC1394_hasManualDC1394(self, feature)


    def hasOnePushDC1394(self, feature):
        """hasOnePushDC1394(IFrameGrabberControlsDC1394 self, int feature) -> bool"""
        return _yarp.IFrameGrabberControlsDC1394_hasOnePushDC1394(self, feature)


    def setModeDC1394(self, feature, auto_onoff):
        """setModeDC1394(IFrameGrabberControlsDC1394 self, int feature, bool auto_onoff) -> bool"""
        return _yarp.IFrameGrabberControlsDC1394_setModeDC1394(self, feature, auto_onoff)


    def getModeDC1394(self, feature):
        """getModeDC1394(IFrameGrabberControlsDC1394 self, int feature) -> bool"""
        return _yarp.IFrameGrabberControlsDC1394_getModeDC1394(self, feature)


    def setOnePushDC1394(self, feature):
        """setOnePushDC1394(IFrameGrabberControlsDC1394 self, int feature) -> bool"""
        return _yarp.IFrameGrabberControlsDC1394_setOnePushDC1394(self, feature)


    def getVideoModeMaskDC1394(self):
        """getVideoModeMaskDC1394(IFrameGrabberControlsDC1394 self) -> unsigned int"""
        return _yarp.IFrameGrabberControlsDC1394_getVideoModeMaskDC1394(self)


    def getVideoModeDC1394(self):
        """getVideoModeDC1394(IFrameGrabberControlsDC1394 self) -> unsigned int"""
        return _yarp.IFrameGrabberControlsDC1394_getVideoModeDC1394(self)


    def setVideoModeDC1394(self, video_mode):
        """setVideoModeDC1394(IFrameGrabberControlsDC1394 self, int video_mode) -> bool"""
        return _yarp.IFrameGrabberControlsDC1394_setVideoModeDC1394(self, video_mode)


    def getFPSMaskDC1394(self):
        """getFPSMaskDC1394(IFrameGrabberControlsDC1394 self) -> unsigned int"""
        return _yarp.IFrameGrabberControlsDC1394_getFPSMaskDC1394(self)


    def getFPSDC1394(self):
        """getFPSDC1394(IFrameGrabberControlsDC1394 self) -> unsigned int"""
        return _yarp.IFrameGrabberControlsDC1394_getFPSDC1394(self)


    def setFPSDC1394(self, fps):
        """setFPSDC1394(IFrameGrabberControlsDC1394 self, int fps) -> bool"""
        return _yarp.IFrameGrabberControlsDC1394_setFPSDC1394(self, fps)


    def getISOSpeedDC1394(self):
        """getISOSpeedDC1394(IFrameGrabberControlsDC1394 self) -> unsigned int"""
        return _yarp.IFrameGrabberControlsDC1394_getISOSpeedDC1394(self)


    def setISOSpeedDC1394(self, speed):
        """setISOSpeedDC1394(IFrameGrabberControlsDC1394 self, int speed) -> bool"""
        return _yarp.IFrameGrabberControlsDC1394_setISOSpeedDC1394(self, speed)


    def getColorCodingMaskDC1394(self, video_mode):
        """getColorCodingMaskDC1394(IFrameGrabberControlsDC1394 self, unsigned int video_mode) -> unsigned int"""
        return _yarp.IFrameGrabberControlsDC1394_getColorCodingMaskDC1394(self, video_mode)


    def getColorCodingDC1394(self):
        """getColorCodingDC1394(IFrameGrabberControlsDC1394 self) -> unsigned int"""
        return _yarp.IFrameGrabberControlsDC1394_getColorCodingDC1394(self)


    def setColorCodingDC1394(self, coding):
        """setColorCodingDC1394(IFrameGrabberControlsDC1394 self, int coding) -> bool"""
        return _yarp.IFrameGrabberControlsDC1394_setColorCodingDC1394(self, coding)


    def setWhiteBalanceDC1394(self, b, r):
        """setWhiteBalanceDC1394(IFrameGrabberControlsDC1394 self, double b, double r) -> bool"""
        return _yarp.IFrameGrabberControlsDC1394_setWhiteBalanceDC1394(self, b, r)


    def getWhiteBalanceDC1394(self, b, r):
        """getWhiteBalanceDC1394(IFrameGrabberControlsDC1394 self, double & b, double & r) -> bool"""
        return _yarp.IFrameGrabberControlsDC1394_getWhiteBalanceDC1394(self, b, r)


    def getFormat7MaxWindowDC1394(self, xdim, ydim, xstep, ystep, xoffstep, yoffstep):
        """getFormat7MaxWindowDC1394(IFrameGrabberControlsDC1394 self, unsigned int & xdim, unsigned int & ydim, unsigned int & xstep, unsigned int & ystep, unsigned int & xoffstep, unsigned int & yoffstep) -> bool"""
        return _yarp.IFrameGrabberControlsDC1394_getFormat7MaxWindowDC1394(self, xdim, ydim, xstep, ystep, xoffstep, yoffstep)


    def getFormat7WindowDC1394(self, xdim, ydim, x0, y0):
        """getFormat7WindowDC1394(IFrameGrabberControlsDC1394 self, unsigned int & xdim, unsigned int & ydim, int & x0, int & y0) -> bool"""
        return _yarp.IFrameGrabberControlsDC1394_getFormat7WindowDC1394(self, xdim, ydim, x0, y0)


    def setFormat7WindowDC1394(self, xdim, ydim, x0, y0):
        """setFormat7WindowDC1394(IFrameGrabberControlsDC1394 self, unsigned int xdim, unsigned int ydim, int x0, int y0) -> bool"""
        return _yarp.IFrameGrabberControlsDC1394_setFormat7WindowDC1394(self, xdim, ydim, x0, y0)


    def setOperationModeDC1394(self, b1394b):
        """setOperationModeDC1394(IFrameGrabberControlsDC1394 self, bool b1394b) -> bool"""
        return _yarp.IFrameGrabberControlsDC1394_setOperationModeDC1394(self, b1394b)


    def getOperationModeDC1394(self):
        """getOperationModeDC1394(IFrameGrabberControlsDC1394 self) -> bool"""
        return _yarp.IFrameGrabberControlsDC1394_getOperationModeDC1394(self)


    def setTransmissionDC1394(self, bTxON):
        """setTransmissionDC1394(IFrameGrabberControlsDC1394 self, bool bTxON) -> bool"""
        return _yarp.IFrameGrabberControlsDC1394_setTransmissionDC1394(self, bTxON)


    def getTransmissionDC1394(self):
        """getTransmissionDC1394(IFrameGrabberControlsDC1394 self) -> bool"""
        return _yarp.IFrameGrabberControlsDC1394_getTransmissionDC1394(self)


    def setBroadcastDC1394(self, onoff):
        """setBroadcastDC1394(IFrameGrabberControlsDC1394 self, bool onoff) -> bool"""
        return _yarp.IFrameGrabberControlsDC1394_setBroadcastDC1394(self, onoff)


    def setDefaultsDC1394(self):
        """setDefaultsDC1394(IFrameGrabberControlsDC1394 self) -> bool"""
        return _yarp.IFrameGrabberControlsDC1394_setDefaultsDC1394(self)


    def setResetDC1394(self):
        """setResetDC1394(IFrameGrabberControlsDC1394 self) -> bool"""
        return _yarp.IFrameGrabberControlsDC1394_setResetDC1394(self)


    def setPowerDC1394(self, onoff):
        """setPowerDC1394(IFrameGrabberControlsDC1394 self, bool onoff) -> bool"""
        return _yarp.IFrameGrabberControlsDC1394_setPowerDC1394(self, onoff)


    def setCaptureDC1394(self, bON):
        """setCaptureDC1394(IFrameGrabberControlsDC1394 self, bool bON) -> bool"""
        return _yarp.IFrameGrabberControlsDC1394_setCaptureDC1394(self, bON)


    def getBytesPerPacketDC1394(self):
        """getBytesPerPacketDC1394(IFrameGrabberControlsDC1394 self) -> unsigned int"""
        return _yarp.IFrameGrabberControlsDC1394_getBytesPerPacketDC1394(self)


    def setBytesPerPacketDC1394(self, bpp):
        """setBytesPerPacketDC1394(IFrameGrabberControlsDC1394 self, unsigned int bpp) -> bool"""
        return _yarp.IFrameGrabberControlsDC1394_setBytesPerPacketDC1394(self, bpp)

    __swig_destroy__ = _yarp.delete_IFrameGrabberControlsDC1394
    __del__ = lambda self: None
IFrameGrabberControlsDC1394_swigregister = _yarp.IFrameGrabberControlsDC1394_swigregister
IFrameGrabberControlsDC1394_swigregister(IFrameGrabberControlsDC1394)

class IAudioVisualGrabber(_object):
    """Proxy of C++ yarp::dev::IAudioVisualGrabber class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IAudioVisualGrabber, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IAudioVisualGrabber, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_IAudioVisualGrabber
    __del__ = lambda self: None

    def getAudioVisual(self, image, sound):
        """getAudioVisual(IAudioVisualGrabber self, ImageRgb image, Sound sound) -> bool"""
        return _yarp.IAudioVisualGrabber_getAudioVisual(self, image, sound)

IAudioVisualGrabber_swigregister = _yarp.IAudioVisualGrabber_swigregister
IAudioVisualGrabber_swigregister(IAudioVisualGrabber)

class IFrameWriterAudioVisual(_object):
    """Proxy of C++ yarp::dev::IFrameWriterAudioVisual class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IFrameWriterAudioVisual, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IFrameWriterAudioVisual, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_IFrameWriterAudioVisual
    __del__ = lambda self: None

    def putAudioVisual(self, image, sound):
        """putAudioVisual(IFrameWriterAudioVisual self, ImageRgb image, Sound sound) -> bool"""
        return _yarp.IFrameWriterAudioVisual_putAudioVisual(self, image, sound)

IFrameWriterAudioVisual_swigregister = _yarp.IFrameWriterAudioVisual_swigregister
IFrameWriterAudioVisual_swigregister(IFrameWriterAudioVisual)

class IAudioVisualStream(_object):
    """Proxy of C++ yarp::dev::IAudioVisualStream class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IAudioVisualStream, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IAudioVisualStream, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_IAudioVisualStream
    __del__ = lambda self: None

    def hasAudio(self):
        """hasAudio(IAudioVisualStream self) -> bool"""
        return _yarp.IAudioVisualStream_hasAudio(self)


    def hasVideo(self):
        """hasVideo(IAudioVisualStream self) -> bool"""
        return _yarp.IAudioVisualStream_hasVideo(self)


    def hasRawVideo(self):
        """hasRawVideo(IAudioVisualStream self) -> bool"""
        return _yarp.IAudioVisualStream_hasRawVideo(self)

IAudioVisualStream_swigregister = _yarp.IAudioVisualStream_swigregister
IAudioVisualStream_swigregister(IAudioVisualStream)


_yarp.VOCAB_JOINTTYPE_REVOLUTE_swigconstant(_yarp)
VOCAB_JOINTTYPE_REVOLUTE = _yarp.VOCAB_JOINTTYPE_REVOLUTE

_yarp.VOCAB_JOINTTYPE_PRISMATIC_swigconstant(_yarp)
VOCAB_JOINTTYPE_PRISMATIC = _yarp.VOCAB_JOINTTYPE_PRISMATIC

_yarp.VOCAB_JOINTTYPE_UNKNOWN_swigconstant(_yarp)
VOCAB_JOINTTYPE_UNKNOWN = _yarp.VOCAB_JOINTTYPE_UNKNOWN
class CalibrationParameters(_object):
    """Proxy of C++ yarp::dev::CalibrationParameters class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CalibrationParameters, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CalibrationParameters, name)
    __repr__ = _swig_repr
    __swig_setmethods__["type"] = _yarp.CalibrationParameters_type_set
    __swig_getmethods__["type"] = _yarp.CalibrationParameters_type_get
    if _newclass:
        type = _swig_property(_yarp.CalibrationParameters_type_get, _yarp.CalibrationParameters_type_set)
    __swig_setmethods__["param1"] = _yarp.CalibrationParameters_param1_set
    __swig_getmethods__["param1"] = _yarp.CalibrationParameters_param1_get
    if _newclass:
        param1 = _swig_property(_yarp.CalibrationParameters_param1_get, _yarp.CalibrationParameters_param1_set)
    __swig_setmethods__["param2"] = _yarp.CalibrationParameters_param2_set
    __swig_getmethods__["param2"] = _yarp.CalibrationParameters_param2_get
    if _newclass:
        param2 = _swig_property(_yarp.CalibrationParameters_param2_get, _yarp.CalibrationParameters_param2_set)
    __swig_setmethods__["param3"] = _yarp.CalibrationParameters_param3_set
    __swig_getmethods__["param3"] = _yarp.CalibrationParameters_param3_get
    if _newclass:
        param3 = _swig_property(_yarp.CalibrationParameters_param3_get, _yarp.CalibrationParameters_param3_set)
    __swig_setmethods__["param4"] = _yarp.CalibrationParameters_param4_set
    __swig_getmethods__["param4"] = _yarp.CalibrationParameters_param4_get
    if _newclass:
        param4 = _swig_property(_yarp.CalibrationParameters_param4_get, _yarp.CalibrationParameters_param4_set)
    __swig_setmethods__["param5"] = _yarp.CalibrationParameters_param5_set
    __swig_getmethods__["param5"] = _yarp.CalibrationParameters_param5_get
    if _newclass:
        param5 = _swig_property(_yarp.CalibrationParameters_param5_get, _yarp.CalibrationParameters_param5_set)
    __swig_setmethods__["paramZero"] = _yarp.CalibrationParameters_paramZero_set
    __swig_getmethods__["paramZero"] = _yarp.CalibrationParameters_paramZero_get
    if _newclass:
        paramZero = _swig_property(_yarp.CalibrationParameters_paramZero_get, _yarp.CalibrationParameters_paramZero_set)

    def __init__(self):
        """__init__(yarp::dev::CalibrationParameters self) -> CalibrationParameters"""
        this = _yarp.new_CalibrationParameters()
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _yarp.delete_CalibrationParameters
    __del__ = lambda self: None
CalibrationParameters_swigregister = _yarp.CalibrationParameters_swigregister
CalibrationParameters_swigregister(CalibrationParameters)

class IAmplifierControl(_object):
    """Proxy of C++ yarp::dev::IAmplifierControl class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IAmplifierControl, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IAmplifierControl, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_IAmplifierControl
    __del__ = lambda self: None

    def enableAmp(self, j):
        """enableAmp(IAmplifierControl self, int j) -> bool"""
        return _yarp.IAmplifierControl_enableAmp(self, j)


    def disableAmp(self, j):
        """disableAmp(IAmplifierControl self, int j) -> bool"""
        return _yarp.IAmplifierControl_disableAmp(self, j)


    def getAmpStatus(self, *args):
        """
        getAmpStatus(IAmplifierControl self, int * st) -> bool
        getAmpStatus(IAmplifierControl self, int j, int * v) -> bool
        """
        return _yarp.IAmplifierControl_getAmpStatus(self, *args)


    def getMaxCurrent(self, j, v):
        """getMaxCurrent(IAmplifierControl self, int j, double * v) -> bool"""
        return _yarp.IAmplifierControl_getMaxCurrent(self, j, v)


    def setMaxCurrent(self, j, v):
        """setMaxCurrent(IAmplifierControl self, int j, double v) -> bool"""
        return _yarp.IAmplifierControl_setMaxCurrent(self, j, v)


    def getNominalCurrent(self, m, val):
        """getNominalCurrent(IAmplifierControl self, int m, double * val) -> bool"""
        return _yarp.IAmplifierControl_getNominalCurrent(self, m, val)


    def getPeakCurrent(self, m, val):
        """getPeakCurrent(IAmplifierControl self, int m, double * val) -> bool"""
        return _yarp.IAmplifierControl_getPeakCurrent(self, m, val)


    def setPeakCurrent(self, m, val):
        """setPeakCurrent(IAmplifierControl self, int m, double const val) -> bool"""
        return _yarp.IAmplifierControl_setPeakCurrent(self, m, val)


    def getPWM(self, j, val):
        """getPWM(IAmplifierControl self, int j, double * val) -> bool"""
        return _yarp.IAmplifierControl_getPWM(self, j, val)


    def getPWMLimit(self, j, val):
        """getPWMLimit(IAmplifierControl self, int j, double * val) -> bool"""
        return _yarp.IAmplifierControl_getPWMLimit(self, j, val)


    def setPWMLimit(self, j, val):
        """setPWMLimit(IAmplifierControl self, int j, double const val) -> bool"""
        return _yarp.IAmplifierControl_setPWMLimit(self, j, val)


    def getPowerSupplyVoltage(self, j, val):
        """getPowerSupplyVoltage(IAmplifierControl self, int j, double * val) -> bool"""
        return _yarp.IAmplifierControl_getPowerSupplyVoltage(self, j, val)


    def getCurrents(self, *args):
        """
        getCurrents(IAmplifierControl self, double * vals) -> bool
        getCurrents(IAmplifierControl self, DVector data) -> bool
        """
        return _yarp.IAmplifierControl_getCurrents(self, *args)


    def getCurrent(self, *args):
        """
        getCurrent(IAmplifierControl self, int j, double * val) -> bool
        getCurrent(IAmplifierControl self, int j, DVector data) -> bool
        """
        return _yarp.IAmplifierControl_getCurrent(self, *args)

IAmplifierControl_swigregister = _yarp.IAmplifierControl_swigregister
IAmplifierControl_swigregister(IAmplifierControl)

class IAmplifierControlRaw(_object):
    """Proxy of C++ yarp::dev::IAmplifierControlRaw class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IAmplifierControlRaw, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IAmplifierControlRaw, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_IAmplifierControlRaw
    __del__ = lambda self: None

    def enableAmpRaw(self, j):
        """enableAmpRaw(IAmplifierControlRaw self, int j) -> bool"""
        return _yarp.IAmplifierControlRaw_enableAmpRaw(self, j)


    def disableAmpRaw(self, j):
        """disableAmpRaw(IAmplifierControlRaw self, int j) -> bool"""
        return _yarp.IAmplifierControlRaw_disableAmpRaw(self, j)


    def getAmpStatusRaw(self, *args):
        """
        getAmpStatusRaw(IAmplifierControlRaw self, int * st) -> bool
        getAmpStatusRaw(IAmplifierControlRaw self, int j, int * st) -> bool
        """
        return _yarp.IAmplifierControlRaw_getAmpStatusRaw(self, *args)


    def getCurrentsRaw(self, vals):
        """getCurrentsRaw(IAmplifierControlRaw self, double * vals) -> bool"""
        return _yarp.IAmplifierControlRaw_getCurrentsRaw(self, vals)


    def getCurrentRaw(self, j, val):
        """getCurrentRaw(IAmplifierControlRaw self, int j, double * val) -> bool"""
        return _yarp.IAmplifierControlRaw_getCurrentRaw(self, j, val)


    def setMaxCurrentRaw(self, j, v):
        """setMaxCurrentRaw(IAmplifierControlRaw self, int j, double v) -> bool"""
        return _yarp.IAmplifierControlRaw_setMaxCurrentRaw(self, j, v)


    def getMaxCurrentRaw(self, j, v):
        """getMaxCurrentRaw(IAmplifierControlRaw self, int j, double * v) -> bool"""
        return _yarp.IAmplifierControlRaw_getMaxCurrentRaw(self, j, v)


    def getNominalCurrentRaw(self, m, val):
        """getNominalCurrentRaw(IAmplifierControlRaw self, int m, double * val) -> bool"""
        return _yarp.IAmplifierControlRaw_getNominalCurrentRaw(self, m, val)


    def getPeakCurrentRaw(self, m, val):
        """getPeakCurrentRaw(IAmplifierControlRaw self, int m, double * val) -> bool"""
        return _yarp.IAmplifierControlRaw_getPeakCurrentRaw(self, m, val)


    def setPeakCurrentRaw(self, m, val):
        """setPeakCurrentRaw(IAmplifierControlRaw self, int m, double const val) -> bool"""
        return _yarp.IAmplifierControlRaw_setPeakCurrentRaw(self, m, val)


    def getPWMRaw(self, j, val):
        """getPWMRaw(IAmplifierControlRaw self, int j, double * val) -> bool"""
        return _yarp.IAmplifierControlRaw_getPWMRaw(self, j, val)


    def getPWMLimitRaw(self, j, val):
        """getPWMLimitRaw(IAmplifierControlRaw self, int j, double * val) -> bool"""
        return _yarp.IAmplifierControlRaw_getPWMLimitRaw(self, j, val)


    def setPWMLimitRaw(self, j, val):
        """setPWMLimitRaw(IAmplifierControlRaw self, int j, double const val) -> bool"""
        return _yarp.IAmplifierControlRaw_setPWMLimitRaw(self, j, val)


    def getPowerSupplyVoltageRaw(self, j, val):
        """getPowerSupplyVoltageRaw(IAmplifierControlRaw self, int j, double * val) -> bool"""
        return _yarp.IAmplifierControlRaw_getPowerSupplyVoltageRaw(self, j, val)

IAmplifierControlRaw_swigregister = _yarp.IAmplifierControlRaw_swigregister
IAmplifierControlRaw_swigregister(IAmplifierControlRaw)

class IControlCalibrationRaw(_object):
    """Proxy of C++ yarp::dev::IControlCalibrationRaw class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IControlCalibrationRaw, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IControlCalibrationRaw, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_IControlCalibrationRaw
    __del__ = lambda self: None

    def calibrateRaw(self, j, p):
        """calibrateRaw(IControlCalibrationRaw self, int j, double p) -> bool"""
        return _yarp.IControlCalibrationRaw_calibrateRaw(self, j, p)


    def doneRaw(self, j):
        """doneRaw(IControlCalibrationRaw self, int j) -> bool"""
        return _yarp.IControlCalibrationRaw_doneRaw(self, j)

IControlCalibrationRaw_swigregister = _yarp.IControlCalibrationRaw_swigregister
IControlCalibrationRaw_swigregister(IControlCalibrationRaw)

class IControlCalibration2Raw(_object):
    """Proxy of C++ yarp::dev::IControlCalibration2Raw class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IControlCalibration2Raw, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IControlCalibration2Raw, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_IControlCalibration2Raw
    __del__ = lambda self: None

    def calibrate2Raw(self, axis, type, p1, p2, p3):
        """calibrate2Raw(IControlCalibration2Raw self, int axis, unsigned int type, double p1, double p2, double p3) -> bool"""
        return _yarp.IControlCalibration2Raw_calibrate2Raw(self, axis, type, p1, p2, p3)


    def setCalibrationParametersRaw(self, axis, params):
        """setCalibrationParametersRaw(IControlCalibration2Raw self, int axis, CalibrationParameters params) -> bool"""
        return _yarp.IControlCalibration2Raw_setCalibrationParametersRaw(self, axis, params)


    def doneRaw(self, j):
        """doneRaw(IControlCalibration2Raw self, int j) -> bool"""
        return _yarp.IControlCalibration2Raw_doneRaw(self, j)

IControlCalibration2Raw_swigregister = _yarp.IControlCalibration2Raw_swigregister
IControlCalibration2Raw_swigregister(IControlCalibration2Raw)

class IControlCalibration(_object):
    """Proxy of C++ yarp::dev::IControlCalibration class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IControlCalibration, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IControlCalibration, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_IControlCalibration
    __del__ = lambda self: None

    def done(self, j):
        """done(IControlCalibration self, int j) -> bool"""
        return _yarp.IControlCalibration_done(self, j)


    def setCalibrator(self, c):
        """setCalibrator(IControlCalibration self, ICalibrator * c) -> bool"""
        return _yarp.IControlCalibration_setCalibrator(self, c)


    def calibrate(self, *args):
        """
        calibrate(IControlCalibration self, int j, double p) -> bool
        calibrate(IControlCalibration self) -> bool
        """
        return _yarp.IControlCalibration_calibrate(self, *args)


    def park(self, wait=True):
        """
        park(IControlCalibration self, bool wait=True) -> bool
        park(IControlCalibration self) -> bool
        """
        return _yarp.IControlCalibration_park(self, wait)

IControlCalibration_swigregister = _yarp.IControlCalibration_swigregister
IControlCalibration_swigregister(IControlCalibration)

class IControlCalibration2(_object):
    """Proxy of C++ yarp::dev::IControlCalibration2 class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IControlCalibration2, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IControlCalibration2, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_IControlCalibration2
    __del__ = lambda self: None

    def calibrate2(self, axis, type, p1, p2, p3):
        """calibrate2(IControlCalibration2 self, int axis, unsigned int type, double p1, double p2, double p3) -> bool"""
        return _yarp.IControlCalibration2_calibrate2(self, axis, type, p1, p2, p3)


    def setCalibrationParameters(self, axis, params):
        """setCalibrationParameters(IControlCalibration2 self, int axis, CalibrationParameters params) -> bool"""
        return _yarp.IControlCalibration2_setCalibrationParameters(self, axis, params)


    def done(self, j):
        """done(IControlCalibration2 self, int j) -> bool"""
        return _yarp.IControlCalibration2_done(self, j)


    def setCalibrator(self, c):
        """setCalibrator(IControlCalibration2 self, ICalibrator * c) -> bool"""
        return _yarp.IControlCalibration2_setCalibrator(self, c)


    def calibrate(self):
        """calibrate(IControlCalibration2 self) -> bool"""
        return _yarp.IControlCalibration2_calibrate(self)


    def park(self, wait=True):
        """
        park(IControlCalibration2 self, bool wait=True) -> bool
        park(IControlCalibration2 self) -> bool
        """
        return _yarp.IControlCalibration2_park(self, wait)


    def abortCalibration(self):
        """abortCalibration(IControlCalibration2 self) -> bool"""
        return _yarp.IControlCalibration2_abortCalibration(self)


    def abortPark(self):
        """abortPark(IControlCalibration2 self) -> bool"""
        return _yarp.IControlCalibration2_abortPark(self)

IControlCalibration2_swigregister = _yarp.IControlCalibration2_swigregister
IControlCalibration2_swigregister(IControlCalibration2)

class IControlDebug(_object):
    """Proxy of C++ yarp::dev::IControlDebug class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IControlDebug, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IControlDebug, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_IControlDebug
    __del__ = lambda self: None

    def setPrintFunction(self, f):
        """setPrintFunction(IControlDebug self, int (*)(char const *,...) f) -> bool"""
        return _yarp.IControlDebug_setPrintFunction(self, f)


    def loadBootMemory(self):
        """loadBootMemory(IControlDebug self) -> bool"""
        return _yarp.IControlDebug_loadBootMemory(self)


    def saveBootMemory(self):
        """saveBootMemory(IControlDebug self) -> bool"""
        return _yarp.IControlDebug_saveBootMemory(self)

IControlDebug_swigregister = _yarp.IControlDebug_swigregister
IControlDebug_swigregister(IControlDebug)

class IControlLimits(_object):
    """Proxy of C++ yarp::dev::IControlLimits class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IControlLimits, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IControlLimits, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_IControlLimits
    __del__ = lambda self: None

    def setLimits(self, axis, min, max):
        """setLimits(IControlLimits self, int axis, double min, double max) -> bool"""
        return _yarp.IControlLimits_setLimits(self, axis, min, max)


    def getLimits(self, *args):
        """
        getLimits(IControlLimits self, int axis, double * min, double * max) -> bool
        getLimits(IControlLimits self, int axis, DVector min, DVector max) -> bool
        """
        return _yarp.IControlLimits_getLimits(self, *args)

IControlLimits_swigregister = _yarp.IControlLimits_swigregister
IControlLimits_swigregister(IControlLimits)

class IControlLimitsRaw(_object):
    """Proxy of C++ yarp::dev::IControlLimitsRaw class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IControlLimitsRaw, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IControlLimitsRaw, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_IControlLimitsRaw
    __del__ = lambda self: None

    def setLimitsRaw(self, axis, min, max):
        """setLimitsRaw(IControlLimitsRaw self, int axis, double min, double max) -> bool"""
        return _yarp.IControlLimitsRaw_setLimitsRaw(self, axis, min, max)


    def getLimitsRaw(self, axis, min, max):
        """getLimitsRaw(IControlLimitsRaw self, int axis, double * min, double * max) -> bool"""
        return _yarp.IControlLimitsRaw_getLimitsRaw(self, axis, min, max)

IControlLimitsRaw_swigregister = _yarp.IControlLimitsRaw_swigregister
IControlLimitsRaw_swigregister(IControlLimitsRaw)

class IAxisInfo(_object):
    """Proxy of C++ yarp::dev::IAxisInfo class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IAxisInfo, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IAxisInfo, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_IAxisInfo
    __del__ = lambda self: None

    def getAxisName(self, axis, name):
        """getAxisName(IAxisInfo self, int axis, yarp::os::ConstString & name) -> bool"""
        return _yarp.IAxisInfo_getAxisName(self, axis, name)


    def getJointType(self, axis, type):
        """getJointType(IAxisInfo self, int axis, yarp::dev::JointTypeEnum & type) -> bool"""
        return _yarp.IAxisInfo_getJointType(self, axis, type)

IAxisInfo_swigregister = _yarp.IAxisInfo_swigregister
IAxisInfo_swigregister(IAxisInfo)

class IAxisInfoRaw(_object):
    """Proxy of C++ yarp::dev::IAxisInfoRaw class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IAxisInfoRaw, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IAxisInfoRaw, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_IAxisInfoRaw
    __del__ = lambda self: None

    def getAxisNameRaw(self, axis, name):
        """getAxisNameRaw(IAxisInfoRaw self, int axis, yarp::os::ConstString & name) -> bool"""
        return _yarp.IAxisInfoRaw_getAxisNameRaw(self, axis, name)


    def getJointTypeRaw(self, axis, type):
        """getJointTypeRaw(IAxisInfoRaw self, int axis, yarp::dev::JointTypeEnum & type) -> bool"""
        return _yarp.IAxisInfoRaw_getJointTypeRaw(self, axis, type)

IAxisInfoRaw_swigregister = _yarp.IAxisInfoRaw_swigregister
IAxisInfoRaw_swigregister(IAxisInfoRaw)

class Pid(_object):
    """Proxy of C++ yarp::dev::Pid class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Pid, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Pid, name)
    __repr__ = _swig_repr
    __swig_setmethods__["kp"] = _yarp.Pid_kp_set
    __swig_getmethods__["kp"] = _yarp.Pid_kp_get
    if _newclass:
        kp = _swig_property(_yarp.Pid_kp_get, _yarp.Pid_kp_set)
    __swig_setmethods__["kd"] = _yarp.Pid_kd_set
    __swig_getmethods__["kd"] = _yarp.Pid_kd_get
    if _newclass:
        kd = _swig_property(_yarp.Pid_kd_get, _yarp.Pid_kd_set)
    __swig_setmethods__["ki"] = _yarp.Pid_ki_set
    __swig_getmethods__["ki"] = _yarp.Pid_ki_get
    if _newclass:
        ki = _swig_property(_yarp.Pid_ki_get, _yarp.Pid_ki_set)
    __swig_setmethods__["max_int"] = _yarp.Pid_max_int_set
    __swig_getmethods__["max_int"] = _yarp.Pid_max_int_get
    if _newclass:
        max_int = _swig_property(_yarp.Pid_max_int_get, _yarp.Pid_max_int_set)
    __swig_setmethods__["scale"] = _yarp.Pid_scale_set
    __swig_getmethods__["scale"] = _yarp.Pid_scale_get
    if _newclass:
        scale = _swig_property(_yarp.Pid_scale_get, _yarp.Pid_scale_set)
    __swig_setmethods__["max_output"] = _yarp.Pid_max_output_set
    __swig_getmethods__["max_output"] = _yarp.Pid_max_output_get
    if _newclass:
        max_output = _swig_property(_yarp.Pid_max_output_get, _yarp.Pid_max_output_set)
    __swig_setmethods__["offset"] = _yarp.Pid_offset_set
    __swig_getmethods__["offset"] = _yarp.Pid_offset_get
    if _newclass:
        offset = _swig_property(_yarp.Pid_offset_get, _yarp.Pid_offset_set)
    __swig_setmethods__["stiction_up_val"] = _yarp.Pid_stiction_up_val_set
    __swig_getmethods__["stiction_up_val"] = _yarp.Pid_stiction_up_val_get
    if _newclass:
        stiction_up_val = _swig_property(_yarp.Pid_stiction_up_val_get, _yarp.Pid_stiction_up_val_set)
    __swig_setmethods__["stiction_down_val"] = _yarp.Pid_stiction_down_val_set
    __swig_getmethods__["stiction_down_val"] = _yarp.Pid_stiction_down_val_get
    if _newclass:
        stiction_down_val = _swig_property(_yarp.Pid_stiction_down_val_get, _yarp.Pid_stiction_down_val_set)
    __swig_setmethods__["kff"] = _yarp.Pid_kff_set
    __swig_getmethods__["kff"] = _yarp.Pid_kff_get
    if _newclass:
        kff = _swig_property(_yarp.Pid_kff_get, _yarp.Pid_kff_set)
    __swig_destroy__ = _yarp.delete_Pid
    __del__ = lambda self: None

    def __init__(self, *args):
        """
        __init__(yarp::dev::Pid self) -> Pid
        __init__(yarp::dev::Pid self, double kp, double kd, double ki, double int_max, double scale, double out_max) -> Pid
        __init__(yarp::dev::Pid self, double kp, double kd, double ki, double int_max, double scale, double out_max, double st_up, double st_down, double kff) -> Pid
        """
        this = _yarp.new_Pid(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def setMaxInt(self, m):
        """setMaxInt(Pid self, double m)"""
        return _yarp.Pid_setMaxInt(self, m)


    def setMaxOut(self, m):
        """setMaxOut(Pid self, double m)"""
        return _yarp.Pid_setMaxOut(self, m)


    def setStictionValues(self, up_value, down_value):
        """setStictionValues(Pid self, double up_value, double down_value)"""
        return _yarp.Pid_setStictionValues(self, up_value, down_value)


    def isEqual(self, p):
        """isEqual(Pid self, Pid p) -> bool"""
        return _yarp.Pid_isEqual(self, p)


    def clear(self):
        """clear(Pid self)"""
        return _yarp.Pid_clear(self)

Pid_swigregister = _yarp.Pid_swigregister
Pid_swigregister(Pid)

class CartesianEventParameters(_object):
    """Proxy of C++ yarp::dev::CartesianEventParameters class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CartesianEventParameters, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CartesianEventParameters, name)
    __repr__ = _swig_repr
    __swig_setmethods__["type"] = _yarp.CartesianEventParameters_type_set
    __swig_getmethods__["type"] = _yarp.CartesianEventParameters_type_get
    if _newclass:
        type = _swig_property(_yarp.CartesianEventParameters_type_get, _yarp.CartesianEventParameters_type_set)
    __swig_setmethods__["motionOngoingCheckPoint"] = _yarp.CartesianEventParameters_motionOngoingCheckPoint_set
    __swig_getmethods__["motionOngoingCheckPoint"] = _yarp.CartesianEventParameters_motionOngoingCheckPoint_get
    if _newclass:
        motionOngoingCheckPoint = _swig_property(_yarp.CartesianEventParameters_motionOngoingCheckPoint_get, _yarp.CartesianEventParameters_motionOngoingCheckPoint_set)

    def __init__(self):
        """__init__(yarp::dev::CartesianEventParameters self) -> CartesianEventParameters"""
        this = _yarp.new_CartesianEventParameters()
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _yarp.delete_CartesianEventParameters
    __del__ = lambda self: None
CartesianEventParameters_swigregister = _yarp.CartesianEventParameters_swigregister
CartesianEventParameters_swigregister(CartesianEventParameters)

class CartesianEventVariables(_object):
    """Proxy of C++ yarp::dev::CartesianEventVariables class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CartesianEventVariables, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CartesianEventVariables, name)
    __repr__ = _swig_repr
    __swig_setmethods__["type"] = _yarp.CartesianEventVariables_type_set
    __swig_getmethods__["type"] = _yarp.CartesianEventVariables_type_get
    if _newclass:
        type = _swig_property(_yarp.CartesianEventVariables_type_get, _yarp.CartesianEventVariables_type_set)
    __swig_setmethods__["time"] = _yarp.CartesianEventVariables_time_set
    __swig_getmethods__["time"] = _yarp.CartesianEventVariables_time_get
    if _newclass:
        time = _swig_property(_yarp.CartesianEventVariables_time_get, _yarp.CartesianEventVariables_time_set)
    __swig_setmethods__["motionOngoingCheckPoint"] = _yarp.CartesianEventVariables_motionOngoingCheckPoint_set
    __swig_getmethods__["motionOngoingCheckPoint"] = _yarp.CartesianEventVariables_motionOngoingCheckPoint_get
    if _newclass:
        motionOngoingCheckPoint = _swig_property(_yarp.CartesianEventVariables_motionOngoingCheckPoint_get, _yarp.CartesianEventVariables_motionOngoingCheckPoint_set)

    def __init__(self):
        """__init__(yarp::dev::CartesianEventVariables self) -> CartesianEventVariables"""
        this = _yarp.new_CartesianEventVariables()
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _yarp.delete_CartesianEventVariables
    __del__ = lambda self: None
CartesianEventVariables_swigregister = _yarp.CartesianEventVariables_swigregister
CartesianEventVariables_swigregister(CartesianEventVariables)

class CartesianEvent(_object):
    """Proxy of C++ yarp::dev::CartesianEvent class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CartesianEvent, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CartesianEvent, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_CartesianEvent
    __del__ = lambda self: None
    __swig_setmethods__["cartesianEventParameters"] = _yarp.CartesianEvent_cartesianEventParameters_set
    __swig_getmethods__["cartesianEventParameters"] = _yarp.CartesianEvent_cartesianEventParameters_get
    if _newclass:
        cartesianEventParameters = _swig_property(_yarp.CartesianEvent_cartesianEventParameters_get, _yarp.CartesianEvent_cartesianEventParameters_set)
    __swig_setmethods__["cartesianEventVariables"] = _yarp.CartesianEvent_cartesianEventVariables_set
    __swig_getmethods__["cartesianEventVariables"] = _yarp.CartesianEvent_cartesianEventVariables_get
    if _newclass:
        cartesianEventVariables = _swig_property(_yarp.CartesianEvent_cartesianEventVariables_get, _yarp.CartesianEvent_cartesianEventVariables_set)

    def cartesianEventCallback(self):
        """cartesianEventCallback(CartesianEvent self)"""
        return _yarp.CartesianEvent_cartesianEventCallback(self)

CartesianEvent_swigregister = _yarp.CartesianEvent_swigregister
CartesianEvent_swigregister(CartesianEvent)

class ICartesianControl(_object):
    """Proxy of C++ yarp::dev::ICartesianControl class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ICartesianControl, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ICartesianControl, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_ICartesianControl
    __del__ = lambda self: None

    def setTrackingMode(self, f):
        """setTrackingMode(ICartesianControl self, bool const f) -> bool"""
        return _yarp.ICartesianControl_setTrackingMode(self, f)


    def getTrackingMode(self, f):
        """getTrackingMode(ICartesianControl self, bool * f) -> bool"""
        return _yarp.ICartesianControl_getTrackingMode(self, f)


    def setReferenceMode(self, f):
        """setReferenceMode(ICartesianControl self, bool const f) -> bool"""
        return _yarp.ICartesianControl_setReferenceMode(self, f)


    def getReferenceMode(self, f):
        """getReferenceMode(ICartesianControl self, bool * f) -> bool"""
        return _yarp.ICartesianControl_getReferenceMode(self, f)


    def setPosePriority(self, p):
        """setPosePriority(ICartesianControl self, yarp::os::ConstString const & p) -> bool"""
        return _yarp.ICartesianControl_setPosePriority(self, p)


    def getPosePriority(self, p):
        """getPosePriority(ICartesianControl self, yarp::os::ConstString & p) -> bool"""
        return _yarp.ICartesianControl_getPosePriority(self, p)


    def getPose(self, *args):
        """
        getPose(ICartesianControl self, Vector x, Vector o, Stamp stamp=None) -> bool
        getPose(ICartesianControl self, Vector x, Vector o) -> bool
        getPose(ICartesianControl self, int const axis, Vector x, Vector o, Stamp stamp=None) -> bool
        getPose(ICartesianControl self, int const axis, Vector x, Vector o) -> bool
        """
        return _yarp.ICartesianControl_getPose(self, *args)


    def goToPose(self, xd, od, t=0.0):
        """
        goToPose(ICartesianControl self, Vector xd, Vector od, double const t=0.0) -> bool
        goToPose(ICartesianControl self, Vector xd, Vector od) -> bool
        """
        return _yarp.ICartesianControl_goToPose(self, xd, od, t)


    def goToPosition(self, xd, t=0.0):
        """
        goToPosition(ICartesianControl self, Vector xd, double const t=0.0) -> bool
        goToPosition(ICartesianControl self, Vector xd) -> bool
        """
        return _yarp.ICartesianControl_goToPosition(self, xd, t)


    def goToPoseSync(self, xd, od, t=0.0):
        """
        goToPoseSync(ICartesianControl self, Vector xd, Vector od, double const t=0.0) -> bool
        goToPoseSync(ICartesianControl self, Vector xd, Vector od) -> bool
        """
        return _yarp.ICartesianControl_goToPoseSync(self, xd, od, t)


    def goToPositionSync(self, xd, t=0.0):
        """
        goToPositionSync(ICartesianControl self, Vector xd, double const t=0.0) -> bool
        goToPositionSync(ICartesianControl self, Vector xd) -> bool
        """
        return _yarp.ICartesianControl_goToPositionSync(self, xd, t)


    def getDesired(self, xdhat, odhat, qdhat):
        """getDesired(ICartesianControl self, Vector xdhat, Vector odhat, Vector qdhat) -> bool"""
        return _yarp.ICartesianControl_getDesired(self, xdhat, odhat, qdhat)


    def askForPose(self, *args):
        """
        askForPose(ICartesianControl self, Vector xd, Vector od, Vector xdhat, Vector odhat, Vector qdhat) -> bool
        askForPose(ICartesianControl self, Vector q0, Vector xd, Vector od, Vector xdhat, Vector odhat, Vector qdhat) -> bool
        """
        return _yarp.ICartesianControl_askForPose(self, *args)


    def askForPosition(self, *args):
        """
        askForPosition(ICartesianControl self, Vector xd, Vector xdhat, Vector odhat, Vector qdhat) -> bool
        askForPosition(ICartesianControl self, Vector q0, Vector xd, Vector xdhat, Vector odhat, Vector qdhat) -> bool
        """
        return _yarp.ICartesianControl_askForPosition(self, *args)


    def getDOF(self, curDof):
        """getDOF(ICartesianControl self, Vector curDof) -> bool"""
        return _yarp.ICartesianControl_getDOF(self, curDof)


    def setDOF(self, newDof, curDof):
        """setDOF(ICartesianControl self, Vector newDof, Vector curDof) -> bool"""
        return _yarp.ICartesianControl_setDOF(self, newDof, curDof)


    def getRestPos(self, curRestPos):
        """getRestPos(ICartesianControl self, Vector curRestPos) -> bool"""
        return _yarp.ICartesianControl_getRestPos(self, curRestPos)


    def setRestPos(self, newRestPos, curRestPos):
        """setRestPos(ICartesianControl self, Vector newRestPos, Vector curRestPos) -> bool"""
        return _yarp.ICartesianControl_setRestPos(self, newRestPos, curRestPos)


    def getRestWeights(self, curRestWeights):
        """getRestWeights(ICartesianControl self, Vector curRestWeights) -> bool"""
        return _yarp.ICartesianControl_getRestWeights(self, curRestWeights)


    def setRestWeights(self, newRestWeights, curRestWeights):
        """setRestWeights(ICartesianControl self, Vector newRestWeights, Vector curRestWeights) -> bool"""
        return _yarp.ICartesianControl_setRestWeights(self, newRestWeights, curRestWeights)


    def getLimits(self, axis, min, max):
        """getLimits(ICartesianControl self, int const axis, double * min, double * max) -> bool"""
        return _yarp.ICartesianControl_getLimits(self, axis, min, max)


    def setLimits(self, axis, min, max):
        """setLimits(ICartesianControl self, int const axis, double const min, double const max) -> bool"""
        return _yarp.ICartesianControl_setLimits(self, axis, min, max)


    def getTrajTime(self, t):
        """getTrajTime(ICartesianControl self, double * t) -> bool"""
        return _yarp.ICartesianControl_getTrajTime(self, t)


    def setTrajTime(self, t):
        """setTrajTime(ICartesianControl self, double const t) -> bool"""
        return _yarp.ICartesianControl_setTrajTime(self, t)


    def getInTargetTol(self, tol):
        """getInTargetTol(ICartesianControl self, double * tol) -> bool"""
        return _yarp.ICartesianControl_getInTargetTol(self, tol)


    def setInTargetTol(self, tol):
        """setInTargetTol(ICartesianControl self, double const tol) -> bool"""
        return _yarp.ICartesianControl_setInTargetTol(self, tol)


    def getJointsVelocities(self, qdot):
        """getJointsVelocities(ICartesianControl self, Vector qdot) -> bool"""
        return _yarp.ICartesianControl_getJointsVelocities(self, qdot)


    def getTaskVelocities(self, xdot, odot):
        """getTaskVelocities(ICartesianControl self, Vector xdot, Vector odot) -> bool"""
        return _yarp.ICartesianControl_getTaskVelocities(self, xdot, odot)


    def setTaskVelocities(self, xdot, odot):
        """setTaskVelocities(ICartesianControl self, Vector xdot, Vector odot) -> bool"""
        return _yarp.ICartesianControl_setTaskVelocities(self, xdot, odot)


    def attachTipFrame(self, x, o):
        """attachTipFrame(ICartesianControl self, Vector x, Vector o) -> bool"""
        return _yarp.ICartesianControl_attachTipFrame(self, x, o)


    def getTipFrame(self, x, o):
        """getTipFrame(ICartesianControl self, Vector x, Vector o) -> bool"""
        return _yarp.ICartesianControl_getTipFrame(self, x, o)


    def removeTipFrame(self):
        """removeTipFrame(ICartesianControl self) -> bool"""
        return _yarp.ICartesianControl_removeTipFrame(self)


    def waitMotionDone(self, period=0.1, timeout=0.0):
        """
        waitMotionDone(ICartesianControl self, double const period=0.1, double const timeout=0.0) -> bool
        waitMotionDone(ICartesianControl self, double const period=0.1) -> bool
        waitMotionDone(ICartesianControl self) -> bool
        """
        return _yarp.ICartesianControl_waitMotionDone(self, period, timeout)


    def stopControl(self):
        """stopControl(ICartesianControl self) -> bool"""
        return _yarp.ICartesianControl_stopControl(self)


    def restoreContext(self, id):
        """restoreContext(ICartesianControl self, int const id) -> bool"""
        return _yarp.ICartesianControl_restoreContext(self, id)


    def deleteContext(self, id):
        """deleteContext(ICartesianControl self, int const id) -> bool"""
        return _yarp.ICartesianControl_deleteContext(self, id)


    def getInfo(self, info):
        """getInfo(ICartesianControl self, Bottle info) -> bool"""
        return _yarp.ICartesianControl_getInfo(self, info)


    def registerEvent(self, event):
        """registerEvent(ICartesianControl self, CartesianEvent event) -> bool"""
        return _yarp.ICartesianControl_registerEvent(self, event)


    def unregisterEvent(self, event):
        """unregisterEvent(ICartesianControl self, CartesianEvent event) -> bool"""
        return _yarp.ICartesianControl_unregisterEvent(self, event)


    def tweakSet(self, options):
        """tweakSet(ICartesianControl self, Bottle options) -> bool"""
        return _yarp.ICartesianControl_tweakSet(self, options)


    def tweakGet(self, options):
        """tweakGet(ICartesianControl self, Bottle options) -> bool"""
        return _yarp.ICartesianControl_tweakGet(self, options)


    def checkMotionDone(self, *args):
        """
        checkMotionDone(ICartesianControl self, bool * f) -> bool
        checkMotionDone(ICartesianControl self, BVector flag) -> bool
        checkMotionDone(ICartesianControl self) -> bool
        """
        return _yarp.ICartesianControl_checkMotionDone(self, *args)


    def isMotionDone(self):
        """isMotionDone(ICartesianControl self) -> bool"""
        return _yarp.ICartesianControl_isMotionDone(self)


    def storeContext(self, *args):
        """
        storeContext(ICartesianControl self, int * id) -> bool
        storeContext(ICartesianControl self) -> int
        """
        return _yarp.ICartesianControl_storeContext(self, *args)

ICartesianControl_swigregister = _yarp.ICartesianControl_swigregister
ICartesianControl_swigregister(ICartesianControl)

class GazeEventParameters(_object):
    """Proxy of C++ yarp::dev::GazeEventParameters class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, GazeEventParameters, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, GazeEventParameters, name)
    __repr__ = _swig_repr
    __swig_setmethods__["type"] = _yarp.GazeEventParameters_type_set
    __swig_getmethods__["type"] = _yarp.GazeEventParameters_type_get
    if _newclass:
        type = _swig_property(_yarp.GazeEventParameters_type_get, _yarp.GazeEventParameters_type_set)
    __swig_setmethods__["motionOngoingCheckPoint"] = _yarp.GazeEventParameters_motionOngoingCheckPoint_set
    __swig_getmethods__["motionOngoingCheckPoint"] = _yarp.GazeEventParameters_motionOngoingCheckPoint_get
    if _newclass:
        motionOngoingCheckPoint = _swig_property(_yarp.GazeEventParameters_motionOngoingCheckPoint_get, _yarp.GazeEventParameters_motionOngoingCheckPoint_set)

    def __init__(self):
        """__init__(yarp::dev::GazeEventParameters self) -> GazeEventParameters"""
        this = _yarp.new_GazeEventParameters()
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _yarp.delete_GazeEventParameters
    __del__ = lambda self: None
GazeEventParameters_swigregister = _yarp.GazeEventParameters_swigregister
GazeEventParameters_swigregister(GazeEventParameters)

class GazeEventVariables(_object):
    """Proxy of C++ yarp::dev::GazeEventVariables class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, GazeEventVariables, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, GazeEventVariables, name)
    __repr__ = _swig_repr
    __swig_setmethods__["type"] = _yarp.GazeEventVariables_type_set
    __swig_getmethods__["type"] = _yarp.GazeEventVariables_type_get
    if _newclass:
        type = _swig_property(_yarp.GazeEventVariables_type_get, _yarp.GazeEventVariables_type_set)
    __swig_setmethods__["time"] = _yarp.GazeEventVariables_time_set
    __swig_getmethods__["time"] = _yarp.GazeEventVariables_time_get
    if _newclass:
        time = _swig_property(_yarp.GazeEventVariables_time_get, _yarp.GazeEventVariables_time_set)
    __swig_setmethods__["motionOngoingCheckPoint"] = _yarp.GazeEventVariables_motionOngoingCheckPoint_set
    __swig_getmethods__["motionOngoingCheckPoint"] = _yarp.GazeEventVariables_motionOngoingCheckPoint_get
    if _newclass:
        motionOngoingCheckPoint = _swig_property(_yarp.GazeEventVariables_motionOngoingCheckPoint_get, _yarp.GazeEventVariables_motionOngoingCheckPoint_set)

    def __init__(self):
        """__init__(yarp::dev::GazeEventVariables self) -> GazeEventVariables"""
        this = _yarp.new_GazeEventVariables()
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _yarp.delete_GazeEventVariables
    __del__ = lambda self: None
GazeEventVariables_swigregister = _yarp.GazeEventVariables_swigregister
GazeEventVariables_swigregister(GazeEventVariables)

class GazeEvent(_object):
    """Proxy of C++ yarp::dev::GazeEvent class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, GazeEvent, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, GazeEvent, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_GazeEvent
    __del__ = lambda self: None
    __swig_setmethods__["gazeEventParameters"] = _yarp.GazeEvent_gazeEventParameters_set
    __swig_getmethods__["gazeEventParameters"] = _yarp.GazeEvent_gazeEventParameters_get
    if _newclass:
        gazeEventParameters = _swig_property(_yarp.GazeEvent_gazeEventParameters_get, _yarp.GazeEvent_gazeEventParameters_set)
    __swig_setmethods__["gazeEventVariables"] = _yarp.GazeEvent_gazeEventVariables_set
    __swig_getmethods__["gazeEventVariables"] = _yarp.GazeEvent_gazeEventVariables_get
    if _newclass:
        gazeEventVariables = _swig_property(_yarp.GazeEvent_gazeEventVariables_get, _yarp.GazeEvent_gazeEventVariables_set)

    def gazeEventCallback(self):
        """gazeEventCallback(GazeEvent self)"""
        return _yarp.GazeEvent_gazeEventCallback(self)

GazeEvent_swigregister = _yarp.GazeEvent_swigregister
GazeEvent_swigregister(GazeEvent)

class IGazeControl(_object):
    """Proxy of C++ yarp::dev::IGazeControl class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IGazeControl, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IGazeControl, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_IGazeControl
    __del__ = lambda self: None

    def setTrackingMode(self, f):
        """setTrackingMode(IGazeControl self, bool const f) -> bool"""
        return _yarp.IGazeControl_setTrackingMode(self, f)


    def setStabilizationMode(self, f):
        """setStabilizationMode(IGazeControl self, bool const f) -> bool"""
        return _yarp.IGazeControl_setStabilizationMode(self, f)


    def getStabilizationMode(self, f):
        """getStabilizationMode(IGazeControl self, bool * f) -> bool"""
        return _yarp.IGazeControl_getStabilizationMode(self, f)


    def getFixationPoint(self, fp, stamp=None):
        """
        getFixationPoint(IGazeControl self, Vector fp, Stamp stamp=None) -> bool
        getFixationPoint(IGazeControl self, Vector fp) -> bool
        """
        return _yarp.IGazeControl_getFixationPoint(self, fp, stamp)


    def getAngles(self, ang, stamp=None):
        """
        getAngles(IGazeControl self, Vector ang, Stamp stamp=None) -> bool
        getAngles(IGazeControl self, Vector ang) -> bool
        """
        return _yarp.IGazeControl_getAngles(self, ang, stamp)


    def lookAtFixationPoint(self, fp):
        """lookAtFixationPoint(IGazeControl self, Vector fp) -> bool"""
        return _yarp.IGazeControl_lookAtFixationPoint(self, fp)


    def lookAtAbsAngles(self, ang):
        """lookAtAbsAngles(IGazeControl self, Vector ang) -> bool"""
        return _yarp.IGazeControl_lookAtAbsAngles(self, ang)


    def lookAtRelAngles(self, ang):
        """lookAtRelAngles(IGazeControl self, Vector ang) -> bool"""
        return _yarp.IGazeControl_lookAtRelAngles(self, ang)


    def lookAtMonoPixel(self, camSel, px, z=1.0):
        """
        lookAtMonoPixel(IGazeControl self, int const camSel, Vector px, double const z=1.0) -> bool
        lookAtMonoPixel(IGazeControl self, int const camSel, Vector px) -> bool
        """
        return _yarp.IGazeControl_lookAtMonoPixel(self, camSel, px, z)


    def lookAtMonoPixelWithVergence(self, camSel, px, ver):
        """lookAtMonoPixelWithVergence(IGazeControl self, int const camSel, Vector px, double const ver) -> bool"""
        return _yarp.IGazeControl_lookAtMonoPixelWithVergence(self, camSel, px, ver)


    def lookAtStereoPixels(self, pxl, pxr):
        """lookAtStereoPixels(IGazeControl self, Vector pxl, Vector pxr) -> bool"""
        return _yarp.IGazeControl_lookAtStereoPixels(self, pxl, pxr)


    def lookAtFixationPointSync(self, fp):
        """lookAtFixationPointSync(IGazeControl self, Vector fp) -> bool"""
        return _yarp.IGazeControl_lookAtFixationPointSync(self, fp)


    def lookAtAbsAnglesSync(self, ang):
        """lookAtAbsAnglesSync(IGazeControl self, Vector ang) -> bool"""
        return _yarp.IGazeControl_lookAtAbsAnglesSync(self, ang)


    def lookAtRelAnglesSync(self, ang):
        """lookAtRelAnglesSync(IGazeControl self, Vector ang) -> bool"""
        return _yarp.IGazeControl_lookAtRelAnglesSync(self, ang)


    def lookAtMonoPixelSync(self, camSel, px, z=1.0):
        """
        lookAtMonoPixelSync(IGazeControl self, int const camSel, Vector px, double const z=1.0) -> bool
        lookAtMonoPixelSync(IGazeControl self, int const camSel, Vector px) -> bool
        """
        return _yarp.IGazeControl_lookAtMonoPixelSync(self, camSel, px, z)


    def lookAtMonoPixelWithVergenceSync(self, camSel, px, ver):
        """lookAtMonoPixelWithVergenceSync(IGazeControl self, int const camSel, Vector px, double const ver) -> bool"""
        return _yarp.IGazeControl_lookAtMonoPixelWithVergenceSync(self, camSel, px, ver)


    def lookAtStereoPixelsSync(self, pxl, pxr):
        """lookAtStereoPixelsSync(IGazeControl self, Vector pxl, Vector pxr) -> bool"""
        return _yarp.IGazeControl_lookAtStereoPixelsSync(self, pxl, pxr)


    def getVORGain(self, gain):
        """getVORGain(IGazeControl self, double * gain) -> bool"""
        return _yarp.IGazeControl_getVORGain(self, gain)


    def getOCRGain(self, gain):
        """getOCRGain(IGazeControl self, double * gain) -> bool"""
        return _yarp.IGazeControl_getOCRGain(self, gain)


    def getSaccadesMode(self, f):
        """getSaccadesMode(IGazeControl self, bool * f) -> bool"""
        return _yarp.IGazeControl_getSaccadesMode(self, f)


    def getSaccadesInhibitionPeriod(self, period):
        """getSaccadesInhibitionPeriod(IGazeControl self, double * period) -> bool"""
        return _yarp.IGazeControl_getSaccadesInhibitionPeriod(self, period)


    def getSaccadesActivationAngle(self, angle):
        """getSaccadesActivationAngle(IGazeControl self, double * angle) -> bool"""
        return _yarp.IGazeControl_getSaccadesActivationAngle(self, angle)


    def getLeftEyePose(self, x, od, stamp=None):
        """
        getLeftEyePose(IGazeControl self, Vector x, Vector od, Stamp stamp=None) -> bool
        getLeftEyePose(IGazeControl self, Vector x, Vector od) -> bool
        """
        return _yarp.IGazeControl_getLeftEyePose(self, x, od, stamp)


    def getRightEyePose(self, x, od, stamp=None):
        """
        getRightEyePose(IGazeControl self, Vector x, Vector od, Stamp stamp=None) -> bool
        getRightEyePose(IGazeControl self, Vector x, Vector od) -> bool
        """
        return _yarp.IGazeControl_getRightEyePose(self, x, od, stamp)


    def getHeadPose(self, x, od, stamp=None):
        """
        getHeadPose(IGazeControl self, Vector x, Vector od, Stamp stamp=None) -> bool
        getHeadPose(IGazeControl self, Vector x, Vector od) -> bool
        """
        return _yarp.IGazeControl_getHeadPose(self, x, od, stamp)


    def get2DPixel(self, camSel, x, px):
        """get2DPixel(IGazeControl self, int const camSel, Vector x, Vector px) -> bool"""
        return _yarp.IGazeControl_get2DPixel(self, camSel, x, px)


    def get3DPoint(self, camSel, px, z, x):
        """get3DPoint(IGazeControl self, int const camSel, Vector px, double const z, Vector x) -> bool"""
        return _yarp.IGazeControl_get3DPoint(self, camSel, px, z, x)


    def get3DPointOnPlane(self, camSel, px, plane, x):
        """get3DPointOnPlane(IGazeControl self, int const camSel, Vector px, Vector plane, Vector x) -> bool"""
        return _yarp.IGazeControl_get3DPointOnPlane(self, camSel, px, plane, x)


    def get3DPointFromAngles(self, mode, ang, x):
        """get3DPointFromAngles(IGazeControl self, int const mode, Vector ang, Vector x) -> bool"""
        return _yarp.IGazeControl_get3DPointFromAngles(self, mode, ang, x)


    def getAnglesFrom3DPoint(self, x, ang):
        """getAnglesFrom3DPoint(IGazeControl self, Vector x, Vector ang) -> bool"""
        return _yarp.IGazeControl_getAnglesFrom3DPoint(self, x, ang)


    def triangulate3DPoint(self, pxl, pxr, x):
        """triangulate3DPoint(IGazeControl self, Vector pxl, Vector pxr, Vector x) -> bool"""
        return _yarp.IGazeControl_triangulate3DPoint(self, pxl, pxr, x)


    def getJointsDesired(self, qdes):
        """getJointsDesired(IGazeControl self, Vector qdes) -> bool"""
        return _yarp.IGazeControl_getJointsDesired(self, qdes)


    def getJointsVelocities(self, qdot):
        """getJointsVelocities(IGazeControl self, Vector qdot) -> bool"""
        return _yarp.IGazeControl_getJointsVelocities(self, qdot)


    def getStereoOptions(self, options):
        """getStereoOptions(IGazeControl self, Bottle options) -> bool"""
        return _yarp.IGazeControl_getStereoOptions(self, options)


    def setNeckTrajTime(self, t):
        """setNeckTrajTime(IGazeControl self, double const t) -> bool"""
        return _yarp.IGazeControl_setNeckTrajTime(self, t)


    def setEyesTrajTime(self, t):
        """setEyesTrajTime(IGazeControl self, double const t) -> bool"""
        return _yarp.IGazeControl_setEyesTrajTime(self, t)


    def setVORGain(self, gain):
        """setVORGain(IGazeControl self, double const gain) -> bool"""
        return _yarp.IGazeControl_setVORGain(self, gain)


    def setOCRGain(self, gain):
        """setOCRGain(IGazeControl self, double const gain) -> bool"""
        return _yarp.IGazeControl_setOCRGain(self, gain)


    def setSaccadesMode(self, f):
        """setSaccadesMode(IGazeControl self, bool const f) -> bool"""
        return _yarp.IGazeControl_setSaccadesMode(self, f)


    def setSaccadesInhibitionPeriod(self, period):
        """setSaccadesInhibitionPeriod(IGazeControl self, double const period) -> bool"""
        return _yarp.IGazeControl_setSaccadesInhibitionPeriod(self, period)


    def setSaccadesActivationAngle(self, angle):
        """setSaccadesActivationAngle(IGazeControl self, double const angle) -> bool"""
        return _yarp.IGazeControl_setSaccadesActivationAngle(self, angle)


    def setStereoOptions(self, options):
        """setStereoOptions(IGazeControl self, Bottle options) -> bool"""
        return _yarp.IGazeControl_setStereoOptions(self, options)


    def bindNeckPitch(self, min, max):
        """bindNeckPitch(IGazeControl self, double const min, double const max) -> bool"""
        return _yarp.IGazeControl_bindNeckPitch(self, min, max)


    def blockNeckPitch(self, *args):
        """
        blockNeckPitch(IGazeControl self, double const val) -> bool
        blockNeckPitch(IGazeControl self) -> bool
        """
        return _yarp.IGazeControl_blockNeckPitch(self, *args)


    def bindNeckRoll(self, min, max):
        """bindNeckRoll(IGazeControl self, double const min, double const max) -> bool"""
        return _yarp.IGazeControl_bindNeckRoll(self, min, max)


    def blockNeckRoll(self, *args):
        """
        blockNeckRoll(IGazeControl self, double const val) -> bool
        blockNeckRoll(IGazeControl self) -> bool
        """
        return _yarp.IGazeControl_blockNeckRoll(self, *args)


    def bindNeckYaw(self, min, max):
        """bindNeckYaw(IGazeControl self, double const min, double const max) -> bool"""
        return _yarp.IGazeControl_bindNeckYaw(self, min, max)


    def blockNeckYaw(self, *args):
        """
        blockNeckYaw(IGazeControl self, double const val) -> bool
        blockNeckYaw(IGazeControl self) -> bool
        """
        return _yarp.IGazeControl_blockNeckYaw(self, *args)


    def blockEyes(self, *args):
        """
        blockEyes(IGazeControl self, double const ver) -> bool
        blockEyes(IGazeControl self) -> bool
        """
        return _yarp.IGazeControl_blockEyes(self, *args)


    def getNeckPitchRange(self, min, max):
        """getNeckPitchRange(IGazeControl self, double * min, double * max) -> bool"""
        return _yarp.IGazeControl_getNeckPitchRange(self, min, max)


    def getNeckRollRange(self, min, max):
        """getNeckRollRange(IGazeControl self, double * min, double * max) -> bool"""
        return _yarp.IGazeControl_getNeckRollRange(self, min, max)


    def getNeckYawRange(self, min, max):
        """getNeckYawRange(IGazeControl self, double * min, double * max) -> bool"""
        return _yarp.IGazeControl_getNeckYawRange(self, min, max)


    def getBlockedVergence(self, ver):
        """getBlockedVergence(IGazeControl self, double * ver) -> bool"""
        return _yarp.IGazeControl_getBlockedVergence(self, ver)


    def clearNeckPitch(self):
        """clearNeckPitch(IGazeControl self) -> bool"""
        return _yarp.IGazeControl_clearNeckPitch(self)


    def clearNeckRoll(self):
        """clearNeckRoll(IGazeControl self) -> bool"""
        return _yarp.IGazeControl_clearNeckRoll(self)


    def clearNeckYaw(self):
        """clearNeckYaw(IGazeControl self) -> bool"""
        return _yarp.IGazeControl_clearNeckYaw(self)


    def clearEyes(self):
        """clearEyes(IGazeControl self) -> bool"""
        return _yarp.IGazeControl_clearEyes(self)


    def getNeckAngleUserTolerance(self, angle):
        """getNeckAngleUserTolerance(IGazeControl self, double * angle) -> bool"""
        return _yarp.IGazeControl_getNeckAngleUserTolerance(self, angle)


    def setNeckAngleUserTolerance(self, angle):
        """setNeckAngleUserTolerance(IGazeControl self, double const angle) -> bool"""
        return _yarp.IGazeControl_setNeckAngleUserTolerance(self, angle)


    def waitMotionDone(self, period=0.1, timeout=0.0):
        """
        waitMotionDone(IGazeControl self, double const period=0.1, double const timeout=0.0) -> bool
        waitMotionDone(IGazeControl self, double const period=0.1) -> bool
        waitMotionDone(IGazeControl self) -> bool
        """
        return _yarp.IGazeControl_waitMotionDone(self, period, timeout)


    def checkSaccadeDone(self, f):
        """checkSaccadeDone(IGazeControl self, bool * f) -> bool"""
        return _yarp.IGazeControl_checkSaccadeDone(self, f)


    def waitSaccadeDone(self, period=0.1, timeout=0.0):
        """
        waitSaccadeDone(IGazeControl self, double const period=0.1, double const timeout=0.0) -> bool
        waitSaccadeDone(IGazeControl self, double const period=0.1) -> bool
        waitSaccadeDone(IGazeControl self) -> bool
        """
        return _yarp.IGazeControl_waitSaccadeDone(self, period, timeout)


    def stopControl(self):
        """stopControl(IGazeControl self) -> bool"""
        return _yarp.IGazeControl_stopControl(self)


    def storeContext(self, id):
        """storeContext(IGazeControl self, int * id) -> bool"""
        return _yarp.IGazeControl_storeContext(self, id)


    def restoreContext(self, id):
        """restoreContext(IGazeControl self, int const id) -> bool"""
        return _yarp.IGazeControl_restoreContext(self, id)


    def deleteContext(self, id):
        """deleteContext(IGazeControl self, int const id) -> bool"""
        return _yarp.IGazeControl_deleteContext(self, id)


    def getInfo(self, info):
        """getInfo(IGazeControl self, Bottle info) -> bool"""
        return _yarp.IGazeControl_getInfo(self, info)


    def registerEvent(self, event):
        """registerEvent(IGazeControl self, GazeEvent event) -> bool"""
        return _yarp.IGazeControl_registerEvent(self, event)


    def unregisterEvent(self, event):
        """unregisterEvent(IGazeControl self, GazeEvent event) -> bool"""
        return _yarp.IGazeControl_unregisterEvent(self, event)


    def tweakSet(self, options):
        """tweakSet(IGazeControl self, Bottle options) -> bool"""
        return _yarp.IGazeControl_tweakSet(self, options)


    def tweakGet(self, options):
        """tweakGet(IGazeControl self, Bottle options) -> bool"""
        return _yarp.IGazeControl_tweakGet(self, options)


    def getTrackingMode(self, *args):
        """
        getTrackingMode(IGazeControl self, bool * f) -> bool
        getTrackingMode(IGazeControl self) -> bool
        """
        return _yarp.IGazeControl_getTrackingMode(self, *args)


    def getNeckTrajTime(self, *args):
        """
        getNeckTrajTime(IGazeControl self, double * t) -> bool
        getNeckTrajTime(IGazeControl self) -> double
        """
        return _yarp.IGazeControl_getNeckTrajTime(self, *args)


    def getEyesTrajTime(self, *args):
        """
        getEyesTrajTime(IGazeControl self, double * t) -> bool
        getEyesTrajTime(IGazeControl self) -> double
        """
        return _yarp.IGazeControl_getEyesTrajTime(self, *args)


    def checkMotionDone(self, *args):
        """
        checkMotionDone(IGazeControl self, bool * f) -> bool
        checkMotionDone(IGazeControl self) -> bool
        """
        return _yarp.IGazeControl_checkMotionDone(self, *args)

IGazeControl_swigregister = _yarp.IGazeControl_swigregister
IGazeControl_swigregister(IGazeControl)

class IPositionControlRaw(_object):
    """Proxy of C++ yarp::dev::IPositionControlRaw class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IPositionControlRaw, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IPositionControlRaw, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_IPositionControlRaw
    __del__ = lambda self: None

    def getAxes(self, ax):
        """getAxes(IPositionControlRaw self, int * ax) -> bool"""
        return _yarp.IPositionControlRaw_getAxes(self, ax)


    def positionMoveRaw(self, *args):
        """
        positionMoveRaw(IPositionControlRaw self, int j, double ref) -> bool
        positionMoveRaw(IPositionControlRaw self, double const * refs) -> bool
        """
        return _yarp.IPositionControlRaw_positionMoveRaw(self, *args)


    def relativeMoveRaw(self, *args):
        """
        relativeMoveRaw(IPositionControlRaw self, int j, double delta) -> bool
        relativeMoveRaw(IPositionControlRaw self, double const * deltas) -> bool
        """
        return _yarp.IPositionControlRaw_relativeMoveRaw(self, *args)


    def checkMotionDoneRaw(self, *args):
        """
        checkMotionDoneRaw(IPositionControlRaw self, int j, bool * flag) -> bool
        checkMotionDoneRaw(IPositionControlRaw self, bool * flag) -> bool
        """
        return _yarp.IPositionControlRaw_checkMotionDoneRaw(self, *args)


    def setRefSpeedRaw(self, j, sp):
        """setRefSpeedRaw(IPositionControlRaw self, int j, double sp) -> bool"""
        return _yarp.IPositionControlRaw_setRefSpeedRaw(self, j, sp)


    def setRefSpeedsRaw(self, spds):
        """setRefSpeedsRaw(IPositionControlRaw self, double const * spds) -> bool"""
        return _yarp.IPositionControlRaw_setRefSpeedsRaw(self, spds)


    def setRefAccelerationRaw(self, j, acc):
        """setRefAccelerationRaw(IPositionControlRaw self, int j, double acc) -> bool"""
        return _yarp.IPositionControlRaw_setRefAccelerationRaw(self, j, acc)


    def setRefAccelerationsRaw(self, accs):
        """setRefAccelerationsRaw(IPositionControlRaw self, double const * accs) -> bool"""
        return _yarp.IPositionControlRaw_setRefAccelerationsRaw(self, accs)


    def getRefSpeedRaw(self, j, ref):
        """getRefSpeedRaw(IPositionControlRaw self, int j, double * ref) -> bool"""
        return _yarp.IPositionControlRaw_getRefSpeedRaw(self, j, ref)


    def getRefSpeedsRaw(self, spds):
        """getRefSpeedsRaw(IPositionControlRaw self, double * spds) -> bool"""
        return _yarp.IPositionControlRaw_getRefSpeedsRaw(self, spds)


    def getRefAccelerationRaw(self, j, acc):
        """getRefAccelerationRaw(IPositionControlRaw self, int j, double * acc) -> bool"""
        return _yarp.IPositionControlRaw_getRefAccelerationRaw(self, j, acc)


    def getRefAccelerationsRaw(self, accs):
        """getRefAccelerationsRaw(IPositionControlRaw self, double * accs) -> bool"""
        return _yarp.IPositionControlRaw_getRefAccelerationsRaw(self, accs)


    def stopRaw(self, *args):
        """
        stopRaw(IPositionControlRaw self, int j) -> bool
        stopRaw(IPositionControlRaw self) -> bool
        """
        return _yarp.IPositionControlRaw_stopRaw(self, *args)

IPositionControlRaw_swigregister = _yarp.IPositionControlRaw_swigregister
IPositionControlRaw_swigregister(IPositionControlRaw)

class IPositionControl(_object):
    """Proxy of C++ yarp::dev::IPositionControl class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IPositionControl, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IPositionControl, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_IPositionControl
    __del__ = lambda self: None

    def setRefSpeed(self, j, sp):
        """setRefSpeed(IPositionControl self, int j, double sp) -> bool"""
        return _yarp.IPositionControl_setRefSpeed(self, j, sp)


    def setRefAcceleration(self, j, acc):
        """setRefAcceleration(IPositionControl self, int j, double acc) -> bool"""
        return _yarp.IPositionControl_setRefAcceleration(self, j, acc)


    def setRefAccelerations(self, accs):
        """setRefAccelerations(IPositionControl self, double const * accs) -> bool"""
        return _yarp.IPositionControl_setRefAccelerations(self, accs)


    def stop(self, *args):
        """
        stop(IPositionControl self, int j) -> bool
        stop(IPositionControl self) -> bool
        """
        return _yarp.IPositionControl_stop(self, *args)


    def getAxes(self, *args):
        """
        getAxes(IPositionControl self, int * ax) -> bool
        getAxes(IPositionControl self) -> int
        """
        return _yarp.IPositionControl_getAxes(self, *args)


    def positionMove(self, *args):
        """
        positionMove(IPositionControl self, int j, double ref) -> bool
        positionMove(IPositionControl self, double const * refs) -> bool
        positionMove(IPositionControl self, DVector data) -> bool
        """
        return _yarp.IPositionControl_positionMove(self, *args)


    def relativeMove(self, *args):
        """
        relativeMove(IPositionControl self, int j, double delta) -> bool
        relativeMove(IPositionControl self, double const * deltas) -> bool
        relativeMove(IPositionControl self, DVector data) -> bool
        """
        return _yarp.IPositionControl_relativeMove(self, *args)


    def setRefSpeeds(self, *args):
        """
        setRefSpeeds(IPositionControl self, double const * spds) -> bool
        setRefSpeeds(IPositionControl self, DVector data) -> bool
        """
        return _yarp.IPositionControl_setRefSpeeds(self, *args)


    def getRefSpeed(self, *args):
        """
        getRefSpeed(IPositionControl self, int j, double * ref) -> bool
        getRefSpeed(IPositionControl self, int j, DVector data) -> bool
        """
        return _yarp.IPositionControl_getRefSpeed(self, *args)


    def getRefSpeeds(self, *args):
        """
        getRefSpeeds(IPositionControl self, double * spds) -> bool
        getRefSpeeds(IPositionControl self, DVector data) -> bool
        """
        return _yarp.IPositionControl_getRefSpeeds(self, *args)


    def getRefAcceleration(self, *args):
        """
        getRefAcceleration(IPositionControl self, int j, double * acc) -> bool
        getRefAcceleration(IPositionControl self, int j, DVector data) -> bool
        """
        return _yarp.IPositionControl_getRefAcceleration(self, *args)


    def getRefAccelerations(self, *args):
        """
        getRefAccelerations(IPositionControl self, double * accs) -> bool
        getRefAccelerations(IPositionControl self, DVector data) -> bool
        """
        return _yarp.IPositionControl_getRefAccelerations(self, *args)


    def checkMotionDone(self, *args):
        """
        checkMotionDone(IPositionControl self, int j, bool * flag) -> bool
        checkMotionDone(IPositionControl self, bool * flag) -> bool
        checkMotionDone(IPositionControl self) -> bool
        checkMotionDone(IPositionControl self, BVector flag) -> bool
        checkMotionDone(IPositionControl self, int i, BVector flag) -> bool
        """
        return _yarp.IPositionControl_checkMotionDone(self, *args)


    def isMotionDone(self, *args):
        """
        isMotionDone(IPositionControl self, int i) -> bool
        isMotionDone(IPositionControl self) -> bool
        """
        return _yarp.IPositionControl_isMotionDone(self, *args)

IPositionControl_swigregister = _yarp.IPositionControl_swigregister
IPositionControl_swigregister(IPositionControl)

class IEncodersRaw(_object):
    """Proxy of C++ yarp::dev::IEncodersRaw class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IEncodersRaw, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IEncodersRaw, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_IEncodersRaw
    __del__ = lambda self: None

    def getAxes(self, ax):
        """getAxes(IEncodersRaw self, int * ax) -> bool"""
        return _yarp.IEncodersRaw_getAxes(self, ax)


    def resetEncoderRaw(self, j):
        """resetEncoderRaw(IEncodersRaw self, int j) -> bool"""
        return _yarp.IEncodersRaw_resetEncoderRaw(self, j)


    def resetEncodersRaw(self):
        """resetEncodersRaw(IEncodersRaw self) -> bool"""
        return _yarp.IEncodersRaw_resetEncodersRaw(self)


    def setEncoderRaw(self, j, val):
        """setEncoderRaw(IEncodersRaw self, int j, double val) -> bool"""
        return _yarp.IEncodersRaw_setEncoderRaw(self, j, val)


    def setEncodersRaw(self, vals):
        """setEncodersRaw(IEncodersRaw self, double const * vals) -> bool"""
        return _yarp.IEncodersRaw_setEncodersRaw(self, vals)


    def getEncoderRaw(self, j, v):
        """getEncoderRaw(IEncodersRaw self, int j, double * v) -> bool"""
        return _yarp.IEncodersRaw_getEncoderRaw(self, j, v)


    def getEncodersRaw(self, encs):
        """getEncodersRaw(IEncodersRaw self, double * encs) -> bool"""
        return _yarp.IEncodersRaw_getEncodersRaw(self, encs)


    def getEncoderSpeedRaw(self, j, sp):
        """getEncoderSpeedRaw(IEncodersRaw self, int j, double * sp) -> bool"""
        return _yarp.IEncodersRaw_getEncoderSpeedRaw(self, j, sp)


    def getEncoderSpeedsRaw(self, spds):
        """getEncoderSpeedsRaw(IEncodersRaw self, double * spds) -> bool"""
        return _yarp.IEncodersRaw_getEncoderSpeedsRaw(self, spds)


    def getEncoderAccelerationRaw(self, j, spds):
        """getEncoderAccelerationRaw(IEncodersRaw self, int j, double * spds) -> bool"""
        return _yarp.IEncodersRaw_getEncoderAccelerationRaw(self, j, spds)


    def getEncoderAccelerationsRaw(self, accs):
        """getEncoderAccelerationsRaw(IEncodersRaw self, double * accs) -> bool"""
        return _yarp.IEncodersRaw_getEncoderAccelerationsRaw(self, accs)

IEncodersRaw_swigregister = _yarp.IEncodersRaw_swigregister
IEncodersRaw_swigregister(IEncodersRaw)

class IEncoders(_object):
    """Proxy of C++ yarp::dev::IEncoders class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IEncoders, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IEncoders, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_IEncoders
    __del__ = lambda self: None

    def resetEncoder(self, j):
        """resetEncoder(IEncoders self, int j) -> bool"""
        return _yarp.IEncoders_resetEncoder(self, j)


    def resetEncoders(self):
        """resetEncoders(IEncoders self) -> bool"""
        return _yarp.IEncoders_resetEncoders(self)


    def setEncoder(self, j, val):
        """setEncoder(IEncoders self, int j, double val) -> bool"""
        return _yarp.IEncoders_setEncoder(self, j, val)


    def getAxes(self, *args):
        """
        getAxes(IEncoders self, int * ax) -> bool
        getAxes(IEncoders self) -> int
        """
        return _yarp.IEncoders_getAxes(self, *args)


    def setEncoders(self, *args):
        """
        setEncoders(IEncoders self, double const * vals) -> bool
        setEncoders(IEncoders self, DVector data) -> bool
        """
        return _yarp.IEncoders_setEncoders(self, *args)


    def getEncoder(self, *args):
        """
        getEncoder(IEncoders self, int j, double * v) -> bool
        getEncoder(IEncoders self, int j) -> double
        """
        return _yarp.IEncoders_getEncoder(self, *args)


    def getEncoders(self, *args):
        """
        getEncoders(IEncoders self, double * encs) -> bool
        getEncoders(IEncoders self, DVector data) -> bool
        """
        return _yarp.IEncoders_getEncoders(self, *args)


    def getEncoderSpeed(self, *args):
        """
        getEncoderSpeed(IEncoders self, int j, double * sp) -> bool
        getEncoderSpeed(IEncoders self, int j) -> double
        """
        return _yarp.IEncoders_getEncoderSpeed(self, *args)


    def getEncoderSpeeds(self, *args):
        """
        getEncoderSpeeds(IEncoders self, double * spds) -> bool
        getEncoderSpeeds(IEncoders self, DVector data) -> bool
        """
        return _yarp.IEncoders_getEncoderSpeeds(self, *args)


    def getEncoderAcceleration(self, *args):
        """
        getEncoderAcceleration(IEncoders self, int j, double * spds) -> bool
        getEncoderAcceleration(IEncoders self, int j) -> double
        """
        return _yarp.IEncoders_getEncoderAcceleration(self, *args)


    def getEncoderAccelerations(self, *args):
        """
        getEncoderAccelerations(IEncoders self, double * accs) -> bool
        getEncoderAccelerations(IEncoders self, DVector data) -> bool
        """
        return _yarp.IEncoders_getEncoderAccelerations(self, *args)

IEncoders_swigregister = _yarp.IEncoders_swigregister
IEncoders_swigregister(IEncoders)

class ICalibrator(_object):
    """Proxy of C++ yarp::dev::ICalibrator class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ICalibrator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ICalibrator, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_ICalibrator
    __del__ = lambda self: None

    def calibrate(self, dd):
        """calibrate(ICalibrator self, DeviceDriver dd) -> bool"""
        return _yarp.ICalibrator_calibrate(self, dd)


    def park(self, dd, wait=True):
        """
        park(ICalibrator self, DeviceDriver dd, bool wait=True) -> bool
        park(ICalibrator self, DeviceDriver dd) -> bool
        """
        return _yarp.ICalibrator_park(self, dd, wait)


    def quitCalibrate(self):
        """quitCalibrate(ICalibrator self) -> bool"""
        return _yarp.ICalibrator_quitCalibrate(self)


    def quitPark(self):
        """quitPark(ICalibrator self) -> bool"""
        return _yarp.ICalibrator_quitPark(self)

ICalibrator_swigregister = _yarp.ICalibrator_swigregister
ICalibrator_swigregister(ICalibrator)

class IRemoteCalibrator(_object):
    """Proxy of C++ yarp::dev::IRemoteCalibrator class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IRemoteCalibrator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IRemoteCalibrator, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_IRemoteCalibrator
    __del__ = lambda self: None

    def setCalibratorDevice(self, dev):
        """setCalibratorDevice(IRemoteCalibrator self, IRemoteCalibrator dev) -> bool"""
        return _yarp.IRemoteCalibrator_setCalibratorDevice(self, dev)


    def getCalibratorDevice(self):
        """getCalibratorDevice(IRemoteCalibrator self) -> IRemoteCalibrator"""
        return _yarp.IRemoteCalibrator_getCalibratorDevice(self)


    def isCalibratorDevicePresent(self, isCalib):
        """isCalibratorDevicePresent(IRemoteCalibrator self, bool * isCalib) -> bool"""
        return _yarp.IRemoteCalibrator_isCalibratorDevicePresent(self, isCalib)


    def releaseCalibratorDevice(self):
        """releaseCalibratorDevice(IRemoteCalibrator self)"""
        return _yarp.IRemoteCalibrator_releaseCalibratorDevice(self)


    def calibrateSingleJoint(self, j):
        """calibrateSingleJoint(IRemoteCalibrator self, int j) -> bool"""
        return _yarp.IRemoteCalibrator_calibrateSingleJoint(self, j)


    def calibrateWholePart(self):
        """calibrateWholePart(IRemoteCalibrator self) -> bool"""
        return _yarp.IRemoteCalibrator_calibrateWholePart(self)


    def homingSingleJoint(self, j):
        """homingSingleJoint(IRemoteCalibrator self, int j) -> bool"""
        return _yarp.IRemoteCalibrator_homingSingleJoint(self, j)


    def homingWholePart(self):
        """homingWholePart(IRemoteCalibrator self) -> bool"""
        return _yarp.IRemoteCalibrator_homingWholePart(self)


    def parkSingleJoint(self, j, _wait=True):
        """
        parkSingleJoint(IRemoteCalibrator self, int j, bool _wait=True) -> bool
        parkSingleJoint(IRemoteCalibrator self, int j) -> bool
        """
        return _yarp.IRemoteCalibrator_parkSingleJoint(self, j, _wait)


    def parkWholePart(self):
        """parkWholePart(IRemoteCalibrator self) -> bool"""
        return _yarp.IRemoteCalibrator_parkWholePart(self)


    def quitCalibrate(self):
        """quitCalibrate(IRemoteCalibrator self) -> bool"""
        return _yarp.IRemoteCalibrator_quitCalibrate(self)


    def quitPark(self):
        """quitPark(IRemoteCalibrator self) -> bool"""
        return _yarp.IRemoteCalibrator_quitPark(self)

IRemoteCalibrator_swigregister = _yarp.IRemoteCalibrator_swigregister
IRemoteCalibrator_swigregister(IRemoteCalibrator)

class IControlMode(_object):
    """Proxy of C++ yarp::dev::IControlMode class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IControlMode, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IControlMode, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_IControlMode
    __del__ = lambda self: None

    def setPositionMode(self, j):
        """setPositionMode(IControlMode self, int j) -> bool"""
        return _yarp.IControlMode_setPositionMode(self, j)


    def setVelocityMode(self, j):
        """setVelocityMode(IControlMode self, int j) -> bool"""
        return _yarp.IControlMode_setVelocityMode(self, j)


    def setTorqueMode(self, j):
        """setTorqueMode(IControlMode self, int j) -> bool"""
        return _yarp.IControlMode_setTorqueMode(self, j)


    def setImpedancePositionMode(self, j):
        """setImpedancePositionMode(IControlMode self, int j) -> bool"""
        return _yarp.IControlMode_setImpedancePositionMode(self, j)


    def setImpedanceVelocityMode(self, j):
        """setImpedanceVelocityMode(IControlMode self, int j) -> bool"""
        return _yarp.IControlMode_setImpedanceVelocityMode(self, j)


    def getControlMode(self, *args):
        """
        getControlMode(IControlMode self, int j, int * mode) -> bool
        getControlMode(IControlMode self, int j) -> int
        """
        return _yarp.IControlMode_getControlMode(self, *args)


    def getControlModes(self, *args):
        """
        getControlModes(IControlMode self, int * modes) -> bool
        getControlModes(IControlMode self, IVector data) -> bool
        """
        return _yarp.IControlMode_getControlModes(self, *args)

IControlMode_swigregister = _yarp.IControlMode_swigregister
IControlMode_swigregister(IControlMode)

class IControlModeRaw(_object):
    """Proxy of C++ yarp::dev::IControlModeRaw class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IControlModeRaw, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IControlModeRaw, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_IControlModeRaw
    __del__ = lambda self: None

    def setPositionModeRaw(self, j):
        """setPositionModeRaw(IControlModeRaw self, int j) -> bool"""
        return _yarp.IControlModeRaw_setPositionModeRaw(self, j)


    def setVelocityModeRaw(self, j):
        """setVelocityModeRaw(IControlModeRaw self, int j) -> bool"""
        return _yarp.IControlModeRaw_setVelocityModeRaw(self, j)


    def setTorqueModeRaw(self, j):
        """setTorqueModeRaw(IControlModeRaw self, int j) -> bool"""
        return _yarp.IControlModeRaw_setTorqueModeRaw(self, j)


    def setImpedancePositionModeRaw(self, j):
        """setImpedancePositionModeRaw(IControlModeRaw self, int j) -> bool"""
        return _yarp.IControlModeRaw_setImpedancePositionModeRaw(self, j)


    def setImpedanceVelocityModeRaw(self, j):
        """setImpedanceVelocityModeRaw(IControlModeRaw self, int j) -> bool"""
        return _yarp.IControlModeRaw_setImpedanceVelocityModeRaw(self, j)


    def getControlModeRaw(self, j, mode):
        """getControlModeRaw(IControlModeRaw self, int j, int * mode) -> bool"""
        return _yarp.IControlModeRaw_getControlModeRaw(self, j, mode)


    def getControlModesRaw(self, modes):
        """getControlModesRaw(IControlModeRaw self, int * modes) -> bool"""
        return _yarp.IControlModeRaw_getControlModesRaw(self, modes)

IControlModeRaw_swigregister = _yarp.IControlModeRaw_swigregister
IControlModeRaw_swigregister(IControlModeRaw)

class IControlMode2(IControlMode):
    """Proxy of C++ yarp::dev::IControlMode2 class."""

    __swig_setmethods__ = {}
    for _s in [IControlMode]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IControlMode2, name, value)
    __swig_getmethods__ = {}
    for _s in [IControlMode]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IControlMode2, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_IControlMode2
    __del__ = lambda self: None

    def setPositionMode(self, j):
        """setPositionMode(IControlMode2 self, int j) -> bool"""
        return _yarp.IControlMode2_setPositionMode(self, j)


    def setVelocityMode(self, j):
        """setVelocityMode(IControlMode2 self, int j) -> bool"""
        return _yarp.IControlMode2_setVelocityMode(self, j)


    def setTorqueMode(self, j):
        """setTorqueMode(IControlMode2 self, int j) -> bool"""
        return _yarp.IControlMode2_setTorqueMode(self, j)


    def setImpedancePositionMode(self, j):
        """setImpedancePositionMode(IControlMode2 self, int j) -> bool"""
        return _yarp.IControlMode2_setImpedancePositionMode(self, j)


    def setImpedanceVelocityMode(self, j):
        """setImpedanceVelocityMode(IControlMode2 self, int j) -> bool"""
        return _yarp.IControlMode2_setImpedanceVelocityMode(self, j)


    def getControlMode(self, *args):
        """
        getControlMode(IControlMode2 self, int j, int * mode) -> bool
        getControlMode(IControlMode2 self, int j) -> int
        """
        return _yarp.IControlMode2_getControlMode(self, *args)


    def setControlMode(self, j, mode):
        """setControlMode(IControlMode2 self, int const j, int const mode) -> bool"""
        return _yarp.IControlMode2_setControlMode(self, j, mode)


    def getControlModes(self, *args):
        """
        getControlModes(IControlMode2 self, int * modes) -> bool
        getControlModes(IControlMode2 self, IVector data) -> bool
        getControlModes(IControlMode2 self, int const n_joint, int const * joints, int * modes) -> bool
        getControlModes(IControlMode2 self, int n_joint, IVector joints, IVector data) -> bool
        """
        return _yarp.IControlMode2_getControlModes(self, *args)


    def setControlModes(self, *args):
        """
        setControlModes(IControlMode2 self, int const n_joint, int const * joints, int * modes) -> bool
        setControlModes(IControlMode2 self, int * modes) -> bool
        setControlModes(IControlMode2 self, IVector data) -> bool
        setControlModes(IControlMode2 self, int n_joint, IVector joints, IVector data) -> bool
        """
        return _yarp.IControlMode2_setControlModes(self, *args)

IControlMode2_swigregister = _yarp.IControlMode2_swigregister
IControlMode2_swigregister(IControlMode2)

class IControlMode2Raw(IControlModeRaw):
    """Proxy of C++ yarp::dev::IControlMode2Raw class."""

    __swig_setmethods__ = {}
    for _s in [IControlModeRaw]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IControlMode2Raw, name, value)
    __swig_getmethods__ = {}
    for _s in [IControlModeRaw]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IControlMode2Raw, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_IControlMode2Raw
    __del__ = lambda self: None

    def setPositionModeRaw(self, j):
        """setPositionModeRaw(IControlMode2Raw self, int j) -> bool"""
        return _yarp.IControlMode2Raw_setPositionModeRaw(self, j)


    def setVelocityModeRaw(self, j):
        """setVelocityModeRaw(IControlMode2Raw self, int j) -> bool"""
        return _yarp.IControlMode2Raw_setVelocityModeRaw(self, j)


    def setTorqueModeRaw(self, j):
        """setTorqueModeRaw(IControlMode2Raw self, int j) -> bool"""
        return _yarp.IControlMode2Raw_setTorqueModeRaw(self, j)


    def setImpedancePositionModeRaw(self, j):
        """setImpedancePositionModeRaw(IControlMode2Raw self, int j) -> bool"""
        return _yarp.IControlMode2Raw_setImpedancePositionModeRaw(self, j)


    def setImpedanceVelocityModeRaw(self, j):
        """setImpedanceVelocityModeRaw(IControlMode2Raw self, int j) -> bool"""
        return _yarp.IControlMode2Raw_setImpedanceVelocityModeRaw(self, j)


    def getControlModeRaw(self, j, mode):
        """getControlModeRaw(IControlMode2Raw self, int j, int * mode) -> bool"""
        return _yarp.IControlMode2Raw_getControlModeRaw(self, j, mode)


    def getControlModesRaw(self, *args):
        """
        getControlModesRaw(IControlMode2Raw self, int * modes) -> bool
        getControlModesRaw(IControlMode2Raw self, int const n_joint, int const * joints, int * modes) -> bool
        """
        return _yarp.IControlMode2Raw_getControlModesRaw(self, *args)


    def setControlModeRaw(self, j, mode):
        """setControlModeRaw(IControlMode2Raw self, int const j, int const mode) -> bool"""
        return _yarp.IControlMode2Raw_setControlModeRaw(self, j, mode)


    def setControlModesRaw(self, *args):
        """
        setControlModesRaw(IControlMode2Raw self, int const n_joint, int const * joints, int * modes) -> bool
        setControlModesRaw(IControlMode2Raw self, int * modes) -> bool
        """
        return _yarp.IControlMode2Raw_setControlModesRaw(self, *args)

IControlMode2Raw_swigregister = _yarp.IControlMode2Raw_swigregister
IControlMode2Raw_swigregister(IControlMode2Raw)

class MotorTorqueParameters(_object):
    """Proxy of C++ yarp::dev::MotorTorqueParameters class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, MotorTorqueParameters, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, MotorTorqueParameters, name)
    __repr__ = _swig_repr
    __swig_setmethods__["bemf"] = _yarp.MotorTorqueParameters_bemf_set
    __swig_getmethods__["bemf"] = _yarp.MotorTorqueParameters_bemf_get
    if _newclass:
        bemf = _swig_property(_yarp.MotorTorqueParameters_bemf_get, _yarp.MotorTorqueParameters_bemf_set)
    __swig_setmethods__["bemf_scale"] = _yarp.MotorTorqueParameters_bemf_scale_set
    __swig_getmethods__["bemf_scale"] = _yarp.MotorTorqueParameters_bemf_scale_get
    if _newclass:
        bemf_scale = _swig_property(_yarp.MotorTorqueParameters_bemf_scale_get, _yarp.MotorTorqueParameters_bemf_scale_set)
    __swig_setmethods__["ktau"] = _yarp.MotorTorqueParameters_ktau_set
    __swig_getmethods__["ktau"] = _yarp.MotorTorqueParameters_ktau_get
    if _newclass:
        ktau = _swig_property(_yarp.MotorTorqueParameters_ktau_get, _yarp.MotorTorqueParameters_ktau_set)
    __swig_setmethods__["ktau_scale"] = _yarp.MotorTorqueParameters_ktau_scale_set
    __swig_getmethods__["ktau_scale"] = _yarp.MotorTorqueParameters_ktau_scale_get
    if _newclass:
        ktau_scale = _swig_property(_yarp.MotorTorqueParameters_ktau_scale_get, _yarp.MotorTorqueParameters_ktau_scale_set)

    def __init__(self):
        """__init__(yarp::dev::MotorTorqueParameters self) -> MotorTorqueParameters"""
        this = _yarp.new_MotorTorqueParameters()
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _yarp.delete_MotorTorqueParameters
    __del__ = lambda self: None
MotorTorqueParameters_swigregister = _yarp.MotorTorqueParameters_swigregister
MotorTorqueParameters_swigregister(MotorTorqueParameters)

class ITorqueControl(_object):
    """Proxy of C++ yarp::dev::ITorqueControl class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ITorqueControl, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ITorqueControl, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_ITorqueControl
    __del__ = lambda self: None

    def getAxes(self, ax):
        """getAxes(ITorqueControl self, int * ax) -> bool"""
        return _yarp.ITorqueControl_getAxes(self, ax)


    def getRefTorques(self, t):
        """getRefTorques(ITorqueControl self, double * t) -> bool"""
        return _yarp.ITorqueControl_getRefTorques(self, t)


    def getRefTorque(self, j, t):
        """getRefTorque(ITorqueControl self, int j, double * t) -> bool"""
        return _yarp.ITorqueControl_getRefTorque(self, j, t)


    def setRefTorque(self, j, t):
        """setRefTorque(ITorqueControl self, int j, double t) -> bool"""
        return _yarp.ITorqueControl_setRefTorque(self, j, t)


    def setRefTorques(self, *args):
        """
        setRefTorques(ITorqueControl self, double const * t) -> bool
        setRefTorques(ITorqueControl self, int const n_joint, int const * joints, double const * t) -> bool
        """
        return _yarp.ITorqueControl_setRefTorques(self, *args)


    def getBemfParam(self, j, bemf):
        """getBemfParam(ITorqueControl self, int j, double * bemf) -> bool"""
        return _yarp.ITorqueControl_getBemfParam(self, j, bemf)


    def setBemfParam(self, j, bemf):
        """setBemfParam(ITorqueControl self, int j, double bemf) -> bool"""
        return _yarp.ITorqueControl_setBemfParam(self, j, bemf)


    def getMotorTorqueParams(self, j, params):
        """getMotorTorqueParams(ITorqueControl self, int j, MotorTorqueParameters params) -> bool"""
        return _yarp.ITorqueControl_getMotorTorqueParams(self, j, params)


    def setMotorTorqueParams(self, j, params):
        """setMotorTorqueParams(ITorqueControl self, int j, MotorTorqueParameters params) -> bool"""
        return _yarp.ITorqueControl_setMotorTorqueParams(self, j, params)


    def getTorque(self, j, t):
        """getTorque(ITorqueControl self, int j, double * t) -> bool"""
        return _yarp.ITorqueControl_getTorque(self, j, t)


    def getTorques(self, t):
        """getTorques(ITorqueControl self, double * t) -> bool"""
        return _yarp.ITorqueControl_getTorques(self, t)


    def getTorqueRange(self, j, min, max):
        """getTorqueRange(ITorqueControl self, int j, double * min, double * max) -> bool"""
        return _yarp.ITorqueControl_getTorqueRange(self, j, min, max)


    def getTorqueRanges(self, min, max):
        """getTorqueRanges(ITorqueControl self, double * min, double * max) -> bool"""
        return _yarp.ITorqueControl_getTorqueRanges(self, min, max)


    def setTorquePid(self, j, pid):
        """setTorquePid(ITorqueControl self, int j, Pid pid) -> bool"""
        return _yarp.ITorqueControl_setTorquePid(self, j, pid)


    def setTorquePids(self, pids):
        """setTorquePids(ITorqueControl self, Pid pids) -> bool"""
        return _yarp.ITorqueControl_setTorquePids(self, pids)


    def setTorqueErrorLimit(self, j, limit):
        """setTorqueErrorLimit(ITorqueControl self, int j, double limit) -> bool"""
        return _yarp.ITorqueControl_setTorqueErrorLimit(self, j, limit)


    def setTorqueErrorLimits(self, limits):
        """setTorqueErrorLimits(ITorqueControl self, double const * limits) -> bool"""
        return _yarp.ITorqueControl_setTorqueErrorLimits(self, limits)


    def getTorqueError(self, j, err):
        """getTorqueError(ITorqueControl self, int j, double * err) -> bool"""
        return _yarp.ITorqueControl_getTorqueError(self, j, err)


    def getTorqueErrors(self, errs):
        """getTorqueErrors(ITorqueControl self, double * errs) -> bool"""
        return _yarp.ITorqueControl_getTorqueErrors(self, errs)


    def getTorquePidOutput(self, j, out):
        """getTorquePidOutput(ITorqueControl self, int j, double * out) -> bool"""
        return _yarp.ITorqueControl_getTorquePidOutput(self, j, out)


    def getTorquePidOutputs(self, outs):
        """getTorquePidOutputs(ITorqueControl self, double * outs) -> bool"""
        return _yarp.ITorqueControl_getTorquePidOutputs(self, outs)


    def getTorquePid(self, j, pid):
        """getTorquePid(ITorqueControl self, int j, Pid pid) -> bool"""
        return _yarp.ITorqueControl_getTorquePid(self, j, pid)


    def getTorquePids(self, pids):
        """getTorquePids(ITorqueControl self, Pid pids) -> bool"""
        return _yarp.ITorqueControl_getTorquePids(self, pids)


    def getTorqueErrorLimit(self, j, limit):
        """getTorqueErrorLimit(ITorqueControl self, int j, double * limit) -> bool"""
        return _yarp.ITorqueControl_getTorqueErrorLimit(self, j, limit)


    def getTorqueErrorLimits(self, limits):
        """getTorqueErrorLimits(ITorqueControl self, double * limits) -> bool"""
        return _yarp.ITorqueControl_getTorqueErrorLimits(self, limits)


    def resetTorquePid(self, j):
        """resetTorquePid(ITorqueControl self, int j) -> bool"""
        return _yarp.ITorqueControl_resetTorquePid(self, j)


    def disableTorquePid(self, j):
        """disableTorquePid(ITorqueControl self, int j) -> bool"""
        return _yarp.ITorqueControl_disableTorquePid(self, j)


    def enableTorquePid(self, j):
        """enableTorquePid(ITorqueControl self, int j) -> bool"""
        return _yarp.ITorqueControl_enableTorquePid(self, j)


    def setTorqueOffset(self, j, v):
        """setTorqueOffset(ITorqueControl self, int j, double v) -> bool"""
        return _yarp.ITorqueControl_setTorqueOffset(self, j, v)

ITorqueControl_swigregister = _yarp.ITorqueControl_swigregister
ITorqueControl_swigregister(ITorqueControl)

class ITorqueControlRaw(_object):
    """Proxy of C++ yarp::dev::ITorqueControlRaw class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ITorqueControlRaw, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ITorqueControlRaw, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_ITorqueControlRaw
    __del__ = lambda self: None

    def getAxes(self, ax):
        """getAxes(ITorqueControlRaw self, int * ax) -> bool"""
        return _yarp.ITorqueControlRaw_getAxes(self, ax)


    def getTorqueRaw(self, j, t):
        """getTorqueRaw(ITorqueControlRaw self, int j, double * t) -> bool"""
        return _yarp.ITorqueControlRaw_getTorqueRaw(self, j, t)


    def getTorquesRaw(self, t):
        """getTorquesRaw(ITorqueControlRaw self, double * t) -> bool"""
        return _yarp.ITorqueControlRaw_getTorquesRaw(self, t)


    def getTorqueRangeRaw(self, j, min, max):
        """getTorqueRangeRaw(ITorqueControlRaw self, int j, double * min, double * max) -> bool"""
        return _yarp.ITorqueControlRaw_getTorqueRangeRaw(self, j, min, max)


    def getTorqueRangesRaw(self, min, max):
        """getTorqueRangesRaw(ITorqueControlRaw self, double * min, double * max) -> bool"""
        return _yarp.ITorqueControlRaw_getTorqueRangesRaw(self, min, max)


    def setRefTorqueRaw(self, j, t):
        """setRefTorqueRaw(ITorqueControlRaw self, int j, double t) -> bool"""
        return _yarp.ITorqueControlRaw_setRefTorqueRaw(self, j, t)


    def setRefTorquesRaw(self, *args):
        """
        setRefTorquesRaw(ITorqueControlRaw self, double const * t) -> bool
        setRefTorquesRaw(ITorqueControlRaw self, int const n_joint, int const * joints, double const * t) -> bool
        """
        return _yarp.ITorqueControlRaw_setRefTorquesRaw(self, *args)


    def getRefTorquesRaw(self, t):
        """getRefTorquesRaw(ITorqueControlRaw self, double * t) -> bool"""
        return _yarp.ITorqueControlRaw_getRefTorquesRaw(self, t)


    def getRefTorqueRaw(self, j, t):
        """getRefTorqueRaw(ITorqueControlRaw self, int j, double * t) -> bool"""
        return _yarp.ITorqueControlRaw_getRefTorqueRaw(self, j, t)


    def getBemfParamRaw(self, j, bemf):
        """getBemfParamRaw(ITorqueControlRaw self, int j, double * bemf) -> bool"""
        return _yarp.ITorqueControlRaw_getBemfParamRaw(self, j, bemf)


    def setBemfParamRaw(self, j, bemf):
        """setBemfParamRaw(ITorqueControlRaw self, int j, double bemf) -> bool"""
        return _yarp.ITorqueControlRaw_setBemfParamRaw(self, j, bemf)


    def getMotorTorqueParamsRaw(self, j, params):
        """getMotorTorqueParamsRaw(ITorqueControlRaw self, int j, MotorTorqueParameters params) -> bool"""
        return _yarp.ITorqueControlRaw_getMotorTorqueParamsRaw(self, j, params)


    def setMotorTorqueParamsRaw(self, j, params):
        """setMotorTorqueParamsRaw(ITorqueControlRaw self, int j, MotorTorqueParameters params) -> bool"""
        return _yarp.ITorqueControlRaw_setMotorTorqueParamsRaw(self, j, params)


    def setTorquePidRaw(self, j, pid):
        """setTorquePidRaw(ITorqueControlRaw self, int j, Pid pid) -> bool"""
        return _yarp.ITorqueControlRaw_setTorquePidRaw(self, j, pid)


    def setTorquePidsRaw(self, pids):
        """setTorquePidsRaw(ITorqueControlRaw self, Pid pids) -> bool"""
        return _yarp.ITorqueControlRaw_setTorquePidsRaw(self, pids)


    def setTorqueErrorLimitRaw(self, j, limit):
        """setTorqueErrorLimitRaw(ITorqueControlRaw self, int j, double limit) -> bool"""
        return _yarp.ITorqueControlRaw_setTorqueErrorLimitRaw(self, j, limit)


    def setTorqueErrorLimitsRaw(self, limits):
        """setTorqueErrorLimitsRaw(ITorqueControlRaw self, double const * limits) -> bool"""
        return _yarp.ITorqueControlRaw_setTorqueErrorLimitsRaw(self, limits)


    def getTorqueErrorRaw(self, j, err):
        """getTorqueErrorRaw(ITorqueControlRaw self, int j, double * err) -> bool"""
        return _yarp.ITorqueControlRaw_getTorqueErrorRaw(self, j, err)


    def getTorqueErrorsRaw(self, errs):
        """getTorqueErrorsRaw(ITorqueControlRaw self, double * errs) -> bool"""
        return _yarp.ITorqueControlRaw_getTorqueErrorsRaw(self, errs)


    def getTorquePidOutputRaw(self, j, out):
        """getTorquePidOutputRaw(ITorqueControlRaw self, int j, double * out) -> bool"""
        return _yarp.ITorqueControlRaw_getTorquePidOutputRaw(self, j, out)


    def getTorquePidOutputsRaw(self, outs):
        """getTorquePidOutputsRaw(ITorqueControlRaw self, double * outs) -> bool"""
        return _yarp.ITorqueControlRaw_getTorquePidOutputsRaw(self, outs)


    def getTorquePidRaw(self, j, pid):
        """getTorquePidRaw(ITorqueControlRaw self, int j, Pid pid) -> bool"""
        return _yarp.ITorqueControlRaw_getTorquePidRaw(self, j, pid)


    def getTorquePidsRaw(self, pids):
        """getTorquePidsRaw(ITorqueControlRaw self, Pid pids) -> bool"""
        return _yarp.ITorqueControlRaw_getTorquePidsRaw(self, pids)


    def getTorqueErrorLimitRaw(self, j, limit):
        """getTorqueErrorLimitRaw(ITorqueControlRaw self, int j, double * limit) -> bool"""
        return _yarp.ITorqueControlRaw_getTorqueErrorLimitRaw(self, j, limit)


    def getTorqueErrorLimitsRaw(self, limits):
        """getTorqueErrorLimitsRaw(ITorqueControlRaw self, double * limits) -> bool"""
        return _yarp.ITorqueControlRaw_getTorqueErrorLimitsRaw(self, limits)


    def resetTorquePidRaw(self, j):
        """resetTorquePidRaw(ITorqueControlRaw self, int j) -> bool"""
        return _yarp.ITorqueControlRaw_resetTorquePidRaw(self, j)


    def disableTorquePidRaw(self, j):
        """disableTorquePidRaw(ITorqueControlRaw self, int j) -> bool"""
        return _yarp.ITorqueControlRaw_disableTorquePidRaw(self, j)


    def enableTorquePidRaw(self, j):
        """enableTorquePidRaw(ITorqueControlRaw self, int j) -> bool"""
        return _yarp.ITorqueControlRaw_enableTorquePidRaw(self, j)


    def setTorqueOffsetRaw(self, j, v):
        """setTorqueOffsetRaw(ITorqueControlRaw self, int j, double v) -> bool"""
        return _yarp.ITorqueControlRaw_setTorqueOffsetRaw(self, j, v)

ITorqueControlRaw_swigregister = _yarp.ITorqueControlRaw_swigregister
ITorqueControlRaw_swigregister(ITorqueControlRaw)

class IImpedanceControlRaw(_object):
    """Proxy of C++ yarp::dev::IImpedanceControlRaw class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IImpedanceControlRaw, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IImpedanceControlRaw, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_IImpedanceControlRaw
    __del__ = lambda self: None

    def getAxes(self, ax):
        """getAxes(IImpedanceControlRaw self, int * ax) -> bool"""
        return _yarp.IImpedanceControlRaw_getAxes(self, ax)


    def getImpedanceRaw(self, j, stiffness, damping):
        """getImpedanceRaw(IImpedanceControlRaw self, int j, double * stiffness, double * damping) -> bool"""
        return _yarp.IImpedanceControlRaw_getImpedanceRaw(self, j, stiffness, damping)


    def setImpedanceRaw(self, j, stiffness, damping):
        """setImpedanceRaw(IImpedanceControlRaw self, int j, double stiffness, double damping) -> bool"""
        return _yarp.IImpedanceControlRaw_setImpedanceRaw(self, j, stiffness, damping)


    def setImpedanceOffsetRaw(self, j, offset):
        """setImpedanceOffsetRaw(IImpedanceControlRaw self, int j, double offset) -> bool"""
        return _yarp.IImpedanceControlRaw_setImpedanceOffsetRaw(self, j, offset)


    def getImpedanceOffsetRaw(self, j, offset):
        """getImpedanceOffsetRaw(IImpedanceControlRaw self, int j, double * offset) -> bool"""
        return _yarp.IImpedanceControlRaw_getImpedanceOffsetRaw(self, j, offset)


    def getCurrentImpedanceLimitRaw(self, j, min_stiff, max_stiff, min_damp, max_damp):
        """getCurrentImpedanceLimitRaw(IImpedanceControlRaw self, int j, double * min_stiff, double * max_stiff, double * min_damp, double * max_damp) -> bool"""
        return _yarp.IImpedanceControlRaw_getCurrentImpedanceLimitRaw(self, j, min_stiff, max_stiff, min_damp, max_damp)

IImpedanceControlRaw_swigregister = _yarp.IImpedanceControlRaw_swigregister
IImpedanceControlRaw_swigregister(IImpedanceControlRaw)

class IImpedanceControl(_object):
    """Proxy of C++ yarp::dev::IImpedanceControl class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IImpedanceControl, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IImpedanceControl, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_IImpedanceControl
    __del__ = lambda self: None

    def getAxes(self, ax):
        """getAxes(IImpedanceControl self, int * ax) -> bool"""
        return _yarp.IImpedanceControl_getAxes(self, ax)


    def getImpedance(self, j, stiffness, damping):
        """getImpedance(IImpedanceControl self, int j, double * stiffness, double * damping) -> bool"""
        return _yarp.IImpedanceControl_getImpedance(self, j, stiffness, damping)


    def setImpedance(self, j, stiffness, damping):
        """setImpedance(IImpedanceControl self, int j, double stiffness, double damping) -> bool"""
        return _yarp.IImpedanceControl_setImpedance(self, j, stiffness, damping)


    def setImpedanceOffset(self, j, offset):
        """setImpedanceOffset(IImpedanceControl self, int j, double offset) -> bool"""
        return _yarp.IImpedanceControl_setImpedanceOffset(self, j, offset)


    def getImpedanceOffset(self, j, offset):
        """getImpedanceOffset(IImpedanceControl self, int j, double * offset) -> bool"""
        return _yarp.IImpedanceControl_getImpedanceOffset(self, j, offset)


    def getCurrentImpedanceLimit(self, j, min_stiff, max_stiff, min_damp, max_damp):
        """getCurrentImpedanceLimit(IImpedanceControl self, int j, double * min_stiff, double * max_stiff, double * min_damp, double * max_damp) -> bool"""
        return _yarp.IImpedanceControl_getCurrentImpedanceLimit(self, j, min_stiff, max_stiff, min_damp, max_damp)

IImpedanceControl_swigregister = _yarp.IImpedanceControl_swigregister
IImpedanceControl_swigregister(IImpedanceControl)

class IVelocityControlRaw(_object):
    """Proxy of C++ yarp::dev::IVelocityControlRaw class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IVelocityControlRaw, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IVelocityControlRaw, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_IVelocityControlRaw
    __del__ = lambda self: None

    def getAxes(self, axis):
        """getAxes(IVelocityControlRaw self, int * axis) -> bool"""
        return _yarp.IVelocityControlRaw_getAxes(self, axis)


    def velocityMoveRaw(self, *args):
        """
        velocityMoveRaw(IVelocityControlRaw self, int j, double sp) -> bool
        velocityMoveRaw(IVelocityControlRaw self, double const * sp) -> bool
        """
        return _yarp.IVelocityControlRaw_velocityMoveRaw(self, *args)


    def setRefAccelerationRaw(self, j, acc):
        """setRefAccelerationRaw(IVelocityControlRaw self, int j, double acc) -> bool"""
        return _yarp.IVelocityControlRaw_setRefAccelerationRaw(self, j, acc)


    def setRefAccelerationsRaw(self, accs):
        """setRefAccelerationsRaw(IVelocityControlRaw self, double const * accs) -> bool"""
        return _yarp.IVelocityControlRaw_setRefAccelerationsRaw(self, accs)


    def getRefAccelerationRaw(self, j, acc):
        """getRefAccelerationRaw(IVelocityControlRaw self, int j, double * acc) -> bool"""
        return _yarp.IVelocityControlRaw_getRefAccelerationRaw(self, j, acc)


    def getRefAccelerationsRaw(self, accs):
        """getRefAccelerationsRaw(IVelocityControlRaw self, double * accs) -> bool"""
        return _yarp.IVelocityControlRaw_getRefAccelerationsRaw(self, accs)


    def stopRaw(self, *args):
        """
        stopRaw(IVelocityControlRaw self, int j) -> bool
        stopRaw(IVelocityControlRaw self) -> bool
        """
        return _yarp.IVelocityControlRaw_stopRaw(self, *args)

IVelocityControlRaw_swigregister = _yarp.IVelocityControlRaw_swigregister
IVelocityControlRaw_swigregister(IVelocityControlRaw)

class IVelocityControl(_object):
    """Proxy of C++ yarp::dev::IVelocityControl class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IVelocityControl, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IVelocityControl, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_IVelocityControl
    __del__ = lambda self: None

    def setRefAcceleration(self, j, acc):
        """setRefAcceleration(IVelocityControl self, int j, double acc) -> bool"""
        return _yarp.IVelocityControl_setRefAcceleration(self, j, acc)


    def stop(self, *args):
        """
        stop(IVelocityControl self, int j) -> bool
        stop(IVelocityControl self) -> bool
        """
        return _yarp.IVelocityControl_stop(self, *args)


    def getAxes(self, *args):
        """
        getAxes(IVelocityControl self, int * axes) -> bool
        getAxes(IVelocityControl self) -> int
        """
        return _yarp.IVelocityControl_getAxes(self, *args)


    def velocityMove(self, *args):
        """
        velocityMove(IVelocityControl self, int j, double sp) -> bool
        velocityMove(IVelocityControl self, double const * sp) -> bool
        velocityMove(IVelocityControl self, DVector data) -> bool
        """
        return _yarp.IVelocityControl_velocityMove(self, *args)


    def setRefAccelerations(self, *args):
        """
        setRefAccelerations(IVelocityControl self, double const * accs) -> bool
        setRefAccelerations(IVelocityControl self, DVector data) -> bool
        """
        return _yarp.IVelocityControl_setRefAccelerations(self, *args)


    def getRefAcceleration(self, *args):
        """
        getRefAcceleration(IVelocityControl self, int j, double * acc) -> bool
        getRefAcceleration(IVelocityControl self, int j, DVector data) -> bool
        """
        return _yarp.IVelocityControl_getRefAcceleration(self, *args)


    def getRefAccelerations(self, *args):
        """
        getRefAccelerations(IVelocityControl self, double * accs) -> bool
        getRefAccelerations(IVelocityControl self, DVector data) -> bool
        """
        return _yarp.IVelocityControl_getRefAccelerations(self, *args)

IVelocityControl_swigregister = _yarp.IVelocityControl_swigregister
IVelocityControl_swigregister(IVelocityControl)

class IPWMControl(_object):
    """Proxy of C++ yarp::dev::IPWMControl class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IPWMControl, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IPWMControl, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_IPWMControl
    __del__ = lambda self: None

    def getNumberOfMotors(self, number):
        """getNumberOfMotors(IPWMControl self, int * number) -> bool"""
        return _yarp.IPWMControl_getNumberOfMotors(self, number)


    def setRefDutyCycle(self, m, ref):
        """setRefDutyCycle(IPWMControl self, int m, double ref) -> bool"""
        return _yarp.IPWMControl_setRefDutyCycle(self, m, ref)


    def setRefDutyCycles(self, refs):
        """setRefDutyCycles(IPWMControl self, double const * refs) -> bool"""
        return _yarp.IPWMControl_setRefDutyCycles(self, refs)


    def getRefDutyCycle(self, m, ref):
        """getRefDutyCycle(IPWMControl self, int m, double * ref) -> bool"""
        return _yarp.IPWMControl_getRefDutyCycle(self, m, ref)


    def getRefDutyCycles(self, refs):
        """getRefDutyCycles(IPWMControl self, double * refs) -> bool"""
        return _yarp.IPWMControl_getRefDutyCycles(self, refs)


    def getDutyCycle(self, m, val):
        """getDutyCycle(IPWMControl self, int m, double * val) -> bool"""
        return _yarp.IPWMControl_getDutyCycle(self, m, val)


    def getDutyCycles(self, vals):
        """getDutyCycles(IPWMControl self, double * vals) -> bool"""
        return _yarp.IPWMControl_getDutyCycles(self, vals)

IPWMControl_swigregister = _yarp.IPWMControl_swigregister
IPWMControl_swigregister(IPWMControl)

class IPWMControlRaw(_object):
    """Proxy of C++ yarp::dev::IPWMControlRaw class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IPWMControlRaw, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IPWMControlRaw, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_IPWMControlRaw
    __del__ = lambda self: None

    def getNumberOfMotorsRaw(self, number):
        """getNumberOfMotorsRaw(IPWMControlRaw self, int * number) -> bool"""
        return _yarp.IPWMControlRaw_getNumberOfMotorsRaw(self, number)


    def setRefDutyCycleRaw(self, m, ref):
        """setRefDutyCycleRaw(IPWMControlRaw self, int m, double ref) -> bool"""
        return _yarp.IPWMControlRaw_setRefDutyCycleRaw(self, m, ref)


    def setRefDutyCyclesRaw(self, refs):
        """setRefDutyCyclesRaw(IPWMControlRaw self, double const * refs) -> bool"""
        return _yarp.IPWMControlRaw_setRefDutyCyclesRaw(self, refs)


    def getRefDutyCycleRaw(self, m, ref):
        """getRefDutyCycleRaw(IPWMControlRaw self, int m, double * ref) -> bool"""
        return _yarp.IPWMControlRaw_getRefDutyCycleRaw(self, m, ref)


    def getRefDutyCyclesRaw(self, refs):
        """getRefDutyCyclesRaw(IPWMControlRaw self, double * refs) -> bool"""
        return _yarp.IPWMControlRaw_getRefDutyCyclesRaw(self, refs)


    def getDutyCycleRaw(self, m, val):
        """getDutyCycleRaw(IPWMControlRaw self, int m, double * val) -> bool"""
        return _yarp.IPWMControlRaw_getDutyCycleRaw(self, m, val)


    def getDutyCyclesRaw(self, vals):
        """getDutyCyclesRaw(IPWMControlRaw self, double * vals) -> bool"""
        return _yarp.IPWMControlRaw_getDutyCyclesRaw(self, vals)

IPWMControlRaw_swigregister = _yarp.IPWMControlRaw_swigregister
IPWMControlRaw_swigregister(IPWMControlRaw)

class ICurrentControl(_object):
    """Proxy of C++ yarp::dev::ICurrentControl class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ICurrentControl, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ICurrentControl, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_ICurrentControl
    __del__ = lambda self: None

    def getNumberOfMotors(self, ax):
        """getNumberOfMotors(ICurrentControl self, int * ax) -> bool"""
        return _yarp.ICurrentControl_getNumberOfMotors(self, ax)


    def getCurrent(self, m, curr):
        """getCurrent(ICurrentControl self, int m, double * curr) -> bool"""
        return _yarp.ICurrentControl_getCurrent(self, m, curr)


    def getCurrents(self, currs):
        """getCurrents(ICurrentControl self, double * currs) -> bool"""
        return _yarp.ICurrentControl_getCurrents(self, currs)


    def getCurrentRange(self, m, min, max):
        """getCurrentRange(ICurrentControl self, int m, double * min, double * max) -> bool"""
        return _yarp.ICurrentControl_getCurrentRange(self, m, min, max)


    def getCurrentRanges(self, min, max):
        """getCurrentRanges(ICurrentControl self, double * min, double * max) -> bool"""
        return _yarp.ICurrentControl_getCurrentRanges(self, min, max)


    def setRefCurrent(self, m, curr):
        """setRefCurrent(ICurrentControl self, int m, double curr) -> bool"""
        return _yarp.ICurrentControl_setRefCurrent(self, m, curr)


    def setRefCurrents(self, *args):
        """
        setRefCurrents(ICurrentControl self, double const * currs) -> bool
        setRefCurrents(ICurrentControl self, int const n_motor, int const * motors, double const * currs) -> bool
        """
        return _yarp.ICurrentControl_setRefCurrents(self, *args)


    def getRefCurrents(self, currs):
        """getRefCurrents(ICurrentControl self, double * currs) -> bool"""
        return _yarp.ICurrentControl_getRefCurrents(self, currs)


    def getRefCurrent(self, m, curr):
        """getRefCurrent(ICurrentControl self, int m, double * curr) -> bool"""
        return _yarp.ICurrentControl_getRefCurrent(self, m, curr)

ICurrentControl_swigregister = _yarp.ICurrentControl_swigregister
ICurrentControl_swigregister(ICurrentControl)

class ICurrentControlRaw(_object):
    """Proxy of C++ yarp::dev::ICurrentControlRaw class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ICurrentControlRaw, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ICurrentControlRaw, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_ICurrentControlRaw
    __del__ = lambda self: None

    def getNumberOfMotorsRaw(self, number):
        """getNumberOfMotorsRaw(ICurrentControlRaw self, int * number) -> bool"""
        return _yarp.ICurrentControlRaw_getNumberOfMotorsRaw(self, number)


    def getCurrentRaw(self, m, curr):
        """getCurrentRaw(ICurrentControlRaw self, int m, double * curr) -> bool"""
        return _yarp.ICurrentControlRaw_getCurrentRaw(self, m, curr)


    def getCurrentsRaw(self, currs):
        """getCurrentsRaw(ICurrentControlRaw self, double * currs) -> bool"""
        return _yarp.ICurrentControlRaw_getCurrentsRaw(self, currs)


    def getCurrentRangeRaw(self, m, min, max):
        """getCurrentRangeRaw(ICurrentControlRaw self, int m, double * min, double * max) -> bool"""
        return _yarp.ICurrentControlRaw_getCurrentRangeRaw(self, m, min, max)


    def getCurrentRangesRaw(self, min, max):
        """getCurrentRangesRaw(ICurrentControlRaw self, double * min, double * max) -> bool"""
        return _yarp.ICurrentControlRaw_getCurrentRangesRaw(self, min, max)


    def setRefCurrentRaw(self, m, curr):
        """setRefCurrentRaw(ICurrentControlRaw self, int m, double curr) -> bool"""
        return _yarp.ICurrentControlRaw_setRefCurrentRaw(self, m, curr)


    def setRefCurrentsRaw(self, *args):
        """
        setRefCurrentsRaw(ICurrentControlRaw self, double const * currs) -> bool
        setRefCurrentsRaw(ICurrentControlRaw self, int const n_motor, int const * motors, double const * currs) -> bool
        """
        return _yarp.ICurrentControlRaw_setRefCurrentsRaw(self, *args)


    def getRefCurrentsRaw(self, currs):
        """getRefCurrentsRaw(ICurrentControlRaw self, double * currs) -> bool"""
        return _yarp.ICurrentControlRaw_getRefCurrentsRaw(self, currs)


    def getRefCurrentRaw(self, m, curr):
        """getRefCurrentRaw(ICurrentControlRaw self, int m, double * curr) -> bool"""
        return _yarp.ICurrentControlRaw_getRefCurrentRaw(self, m, curr)

ICurrentControlRaw_swigregister = _yarp.ICurrentControlRaw_swigregister
ICurrentControlRaw_swigregister(ICurrentControlRaw)

class IAnalogSensor(_object):
    """Proxy of C++ yarp::dev::IAnalogSensor class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IAnalogSensor, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IAnalogSensor, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    AS_OK = _yarp.IAnalogSensor_AS_OK
    AS_ERROR = _yarp.IAnalogSensor_AS_ERROR
    AS_OVF = _yarp.IAnalogSensor_AS_OVF
    AS_TIMEOUT = _yarp.IAnalogSensor_AS_TIMEOUT
    __swig_destroy__ = _yarp.delete_IAnalogSensor
    __del__ = lambda self: None

    def read(self, out):
        """read(IAnalogSensor self, Vector out) -> int"""
        return _yarp.IAnalogSensor_read(self, out)


    def getState(self, ch):
        """getState(IAnalogSensor self, int ch) -> int"""
        return _yarp.IAnalogSensor_getState(self, ch)


    def getChannels(self):
        """getChannels(IAnalogSensor self) -> int"""
        return _yarp.IAnalogSensor_getChannels(self)


    def calibrateSensor(self, *args):
        """
        calibrateSensor(IAnalogSensor self) -> int
        calibrateSensor(IAnalogSensor self, Vector value) -> int
        """
        return _yarp.IAnalogSensor_calibrateSensor(self, *args)


    def calibrateChannel(self, *args):
        """
        calibrateChannel(IAnalogSensor self, int ch) -> int
        calibrateChannel(IAnalogSensor self, int ch, double value) -> int
        """
        return _yarp.IAnalogSensor_calibrateChannel(self, *args)

IAnalogSensor_swigregister = _yarp.IAnalogSensor_swigregister
IAnalogSensor_swigregister(IAnalogSensor)


_yarp.BUS_UNKNOWN_swigconstant(_yarp)
BUS_UNKNOWN = _yarp.BUS_UNKNOWN

_yarp.BUS_FIREWIRE_swigconstant(_yarp)
BUS_FIREWIRE = _yarp.BUS_FIREWIRE

_yarp.BUS_USB_swigconstant(_yarp)
BUS_USB = _yarp.BUS_USB

_yarp.MODE_UNKNOWN_swigconstant(_yarp)
MODE_UNKNOWN = _yarp.MODE_UNKNOWN

_yarp.MODE_MANUAL_swigconstant(_yarp)
MODE_MANUAL = _yarp.MODE_MANUAL

_yarp.MODE_AUTO_swigconstant(_yarp)
MODE_AUTO = _yarp.MODE_AUTO
class CameraDescriptor(_object):
    """Proxy of C++ CameraDescriptor class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CameraDescriptor, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CameraDescriptor, name)
    __repr__ = _swig_repr
    __swig_setmethods__["busType"] = _yarp.CameraDescriptor_busType_set
    __swig_getmethods__["busType"] = _yarp.CameraDescriptor_busType_get
    if _newclass:
        busType = _swig_property(_yarp.CameraDescriptor_busType_get, _yarp.CameraDescriptor_busType_set)
    __swig_setmethods__["deviceDescription"] = _yarp.CameraDescriptor_deviceDescription_set
    __swig_getmethods__["deviceDescription"] = _yarp.CameraDescriptor_deviceDescription_get
    if _newclass:
        deviceDescription = _swig_property(_yarp.CameraDescriptor_deviceDescription_get, _yarp.CameraDescriptor_deviceDescription_set)

    def __init__(self):
        """__init__(CameraDescriptor self) -> CameraDescriptor"""
        this = _yarp.new_CameraDescriptor()
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _yarp.delete_CameraDescriptor
    __del__ = lambda self: None
CameraDescriptor_swigregister = _yarp.CameraDescriptor_swigregister
CameraDescriptor_swigregister(CameraDescriptor)

class IFrameGrabberControls2(_object):
    """Proxy of C++ yarp::dev::IFrameGrabberControls2 class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IFrameGrabberControls2, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IFrameGrabberControls2, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_IFrameGrabberControls2
    __del__ = lambda self: None

    def busType2String(self, type):
        """busType2String(IFrameGrabberControls2 self, BusType type) -> yarp::os::ConstString"""
        return _yarp.IFrameGrabberControls2_busType2String(self, type)


    def toFeatureMode(self, _auto):
        """toFeatureMode(IFrameGrabberControls2 self, bool _auto) -> FeatureMode"""
        return _yarp.IFrameGrabberControls2_toFeatureMode(self, _auto)


    def setFeature(self, *args):
        """
        setFeature(IFrameGrabberControls2 self, int feature, double value) -> bool
        setFeature(IFrameGrabberControls2 self, int feature, double value1, double value2) -> bool
        """
        return _yarp.IFrameGrabberControls2_setFeature(self, *args)


    def setActive(self, feature, onoff):
        """setActive(IFrameGrabberControls2 self, int feature, bool onoff) -> bool"""
        return _yarp.IFrameGrabberControls2_setActive(self, feature, onoff)


    def setMode(self, feature, mode):
        """setMode(IFrameGrabberControls2 self, int feature, FeatureMode mode) -> bool"""
        return _yarp.IFrameGrabberControls2_setMode(self, feature, mode)


    def setOnePush(self, feature):
        """setOnePush(IFrameGrabberControls2 self, int feature) -> bool"""
        return _yarp.IFrameGrabberControls2_setOnePush(self, feature)


    def getCameraDescription(self, *args):
        """
        getCameraDescription(IFrameGrabberControls2 self, CameraDescriptor camera) -> bool
        getCameraDescription(IFrameGrabberControls2 self) -> CameraDescriptor
        """
        return _yarp.IFrameGrabberControls2_getCameraDescription(self, *args)


    def hasFeature(self, *args):
        """
        hasFeature(IFrameGrabberControls2 self, int feature, bool * hasFeature) -> bool
        hasFeature(IFrameGrabberControls2 self, int feature) -> bool
        """
        return _yarp.IFrameGrabberControls2_hasFeature(self, *args)


    def getFeature(self, *args):
        """
        getFeature(IFrameGrabberControls2 self, int feature, double * value) -> bool
        getFeature(IFrameGrabberControls2 self, int feature, double * value1, double * value2) -> bool
        getFeature(IFrameGrabberControls2 self, int feature) -> double
        """
        return _yarp.IFrameGrabberControls2_getFeature(self, *args)


    def hasOnOff(self, *args):
        """
        hasOnOff(IFrameGrabberControls2 self, int feature, bool * HasOnOff) -> bool
        hasOnOff(IFrameGrabberControls2 self, int feature) -> bool
        """
        return _yarp.IFrameGrabberControls2_hasOnOff(self, *args)


    def getActive(self, *args):
        """
        getActive(IFrameGrabberControls2 self, int feature, bool * isActive) -> bool
        getActive(IFrameGrabberControls2 self, int feature) -> bool
        """
        return _yarp.IFrameGrabberControls2_getActive(self, *args)


    def hasAuto(self, *args):
        """
        hasAuto(IFrameGrabberControls2 self, int feature, bool * hasAuto) -> bool
        hasAuto(IFrameGrabberControls2 self, int feature) -> bool
        """
        return _yarp.IFrameGrabberControls2_hasAuto(self, *args)


    def hasManual(self, *args):
        """
        hasManual(IFrameGrabberControls2 self, int feature, bool * hasManual) -> bool
        hasManual(IFrameGrabberControls2 self, int feature) -> bool
        """
        return _yarp.IFrameGrabberControls2_hasManual(self, *args)


    def hasOnePush(self, *args):
        """
        hasOnePush(IFrameGrabberControls2 self, int feature, bool * hasOnePush) -> bool
        hasOnePush(IFrameGrabberControls2 self, int feature) -> bool
        """
        return _yarp.IFrameGrabberControls2_hasOnePush(self, *args)


    def getMode(self, *args):
        """
        getMode(IFrameGrabberControls2 self, int feature, FeatureMode * mode) -> bool
        getMode(IFrameGrabberControls2 self, int feature) -> FeatureMode
        """
        return _yarp.IFrameGrabberControls2_getMode(self, *args)

IFrameGrabberControls2_swigregister = _yarp.IFrameGrabberControls2_swigregister
IFrameGrabberControls2_swigregister(IFrameGrabberControls2)


_yarp.VOCAB_PIDTYPE_POSITION_swigconstant(_yarp)
VOCAB_PIDTYPE_POSITION = _yarp.VOCAB_PIDTYPE_POSITION

_yarp.VOCAB_PIDTYPE_VELOCITY_swigconstant(_yarp)
VOCAB_PIDTYPE_VELOCITY = _yarp.VOCAB_PIDTYPE_VELOCITY

_yarp.VOCAB_PIDTYPE_TORQUE_swigconstant(_yarp)
VOCAB_PIDTYPE_TORQUE = _yarp.VOCAB_PIDTYPE_TORQUE

_yarp.VOCAB_PIDTYPE_CURRENT_swigconstant(_yarp)
VOCAB_PIDTYPE_CURRENT = _yarp.VOCAB_PIDTYPE_CURRENT
class IPidControlRaw(_object):
    """Proxy of C++ yarp::dev::IPidControlRaw class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IPidControlRaw, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IPidControlRaw, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_IPidControlRaw
    __del__ = lambda self: None

    def setReferenceRaw(self, j, ref):
        """setReferenceRaw(IPidControlRaw self, int j, double ref) -> bool"""
        return _yarp.IPidControlRaw_setReferenceRaw(self, j, ref)


    def setReferencesRaw(self, refs):
        """setReferencesRaw(IPidControlRaw self, double const * refs) -> bool"""
        return _yarp.IPidControlRaw_setReferencesRaw(self, refs)


    def setErrorLimitRaw(self, j, limit):
        """setErrorLimitRaw(IPidControlRaw self, int j, double limit) -> bool"""
        return _yarp.IPidControlRaw_setErrorLimitRaw(self, j, limit)


    def setErrorLimitsRaw(self, limits):
        """setErrorLimitsRaw(IPidControlRaw self, double const * limits) -> bool"""
        return _yarp.IPidControlRaw_setErrorLimitsRaw(self, limits)


    def getErrorRaw(self, j, err):
        """getErrorRaw(IPidControlRaw self, int j, double * err) -> bool"""
        return _yarp.IPidControlRaw_getErrorRaw(self, j, err)


    def getErrorsRaw(self, errs):
        """getErrorsRaw(IPidControlRaw self, double * errs) -> bool"""
        return _yarp.IPidControlRaw_getErrorsRaw(self, errs)


    def getOutputRaw(self, j, out):
        """getOutputRaw(IPidControlRaw self, int j, double * out) -> bool"""
        return _yarp.IPidControlRaw_getOutputRaw(self, j, out)


    def getOutputsRaw(self, outs):
        """getOutputsRaw(IPidControlRaw self, double * outs) -> bool"""
        return _yarp.IPidControlRaw_getOutputsRaw(self, outs)


    def getReferenceRaw(self, j, ref):
        """getReferenceRaw(IPidControlRaw self, int j, double * ref) -> bool"""
        return _yarp.IPidControlRaw_getReferenceRaw(self, j, ref)


    def getReferencesRaw(self, refs):
        """getReferencesRaw(IPidControlRaw self, double * refs) -> bool"""
        return _yarp.IPidControlRaw_getReferencesRaw(self, refs)


    def getErrorLimitRaw(self, j, limit):
        """getErrorLimitRaw(IPidControlRaw self, int j, double * limit) -> bool"""
        return _yarp.IPidControlRaw_getErrorLimitRaw(self, j, limit)


    def getErrorLimitsRaw(self, limits):
        """getErrorLimitsRaw(IPidControlRaw self, double * limits) -> bool"""
        return _yarp.IPidControlRaw_getErrorLimitsRaw(self, limits)


    def setOffsetRaw(self, j, v):
        """setOffsetRaw(IPidControlRaw self, int j, double v) -> bool"""
        return _yarp.IPidControlRaw_setOffsetRaw(self, j, v)


    def setPidRaw(self, *args):
        """
        setPidRaw(IPidControlRaw self, int j, Pid pid) -> bool
        setPidRaw(IPidControlRaw self, yarp::dev::PidControlTypeEnum const & pidtype, int j, Pid pid) -> bool
        """
        return _yarp.IPidControlRaw_setPidRaw(self, *args)


    def setPidsRaw(self, *args):
        """
        setPidsRaw(IPidControlRaw self, Pid pids) -> bool
        setPidsRaw(IPidControlRaw self, yarp::dev::PidControlTypeEnum const & pidtype, Pid pids) -> bool
        """
        return _yarp.IPidControlRaw_setPidsRaw(self, *args)


    def setPidReferenceRaw(self, pidtype, j, ref):
        """setPidReferenceRaw(IPidControlRaw self, yarp::dev::PidControlTypeEnum const & pidtype, int j, double ref) -> bool"""
        return _yarp.IPidControlRaw_setPidReferenceRaw(self, pidtype, j, ref)


    def setPidReferencesRaw(self, pidtype, refs):
        """setPidReferencesRaw(IPidControlRaw self, yarp::dev::PidControlTypeEnum const & pidtype, double const * refs) -> bool"""
        return _yarp.IPidControlRaw_setPidReferencesRaw(self, pidtype, refs)


    def setPidErrorLimitRaw(self, pidtype, j, limit):
        """setPidErrorLimitRaw(IPidControlRaw self, yarp::dev::PidControlTypeEnum const & pidtype, int j, double limit) -> bool"""
        return _yarp.IPidControlRaw_setPidErrorLimitRaw(self, pidtype, j, limit)


    def setPidErrorLimitsRaw(self, pidtype, limits):
        """setPidErrorLimitsRaw(IPidControlRaw self, yarp::dev::PidControlTypeEnum const & pidtype, double const * limits) -> bool"""
        return _yarp.IPidControlRaw_setPidErrorLimitsRaw(self, pidtype, limits)


    def getPidErrorRaw(self, pidtype, j, err):
        """getPidErrorRaw(IPidControlRaw self, yarp::dev::PidControlTypeEnum const & pidtype, int j, double * err) -> bool"""
        return _yarp.IPidControlRaw_getPidErrorRaw(self, pidtype, j, err)


    def getPidErrorsRaw(self, pidtype, errs):
        """getPidErrorsRaw(IPidControlRaw self, yarp::dev::PidControlTypeEnum const & pidtype, double * errs) -> bool"""
        return _yarp.IPidControlRaw_getPidErrorsRaw(self, pidtype, errs)


    def getPidOutputRaw(self, pidtype, j, out):
        """getPidOutputRaw(IPidControlRaw self, yarp::dev::PidControlTypeEnum const & pidtype, int j, double * out) -> bool"""
        return _yarp.IPidControlRaw_getPidOutputRaw(self, pidtype, j, out)


    def getPidOutputsRaw(self, pidtype, outs):
        """getPidOutputsRaw(IPidControlRaw self, yarp::dev::PidControlTypeEnum const & pidtype, double * outs) -> bool"""
        return _yarp.IPidControlRaw_getPidOutputsRaw(self, pidtype, outs)


    def getPidRaw(self, *args):
        """
        getPidRaw(IPidControlRaw self, int j, Pid pid) -> bool
        getPidRaw(IPidControlRaw self, yarp::dev::PidControlTypeEnum const & pidtype, int j, Pid pid) -> bool
        """
        return _yarp.IPidControlRaw_getPidRaw(self, *args)


    def getPidsRaw(self, *args):
        """
        getPidsRaw(IPidControlRaw self, Pid pids) -> bool
        getPidsRaw(IPidControlRaw self, yarp::dev::PidControlTypeEnum const & pidtype, Pid pids) -> bool
        """
        return _yarp.IPidControlRaw_getPidsRaw(self, *args)


    def getPidReferenceRaw(self, pidtype, j, ref):
        """getPidReferenceRaw(IPidControlRaw self, yarp::dev::PidControlTypeEnum const & pidtype, int j, double * ref) -> bool"""
        return _yarp.IPidControlRaw_getPidReferenceRaw(self, pidtype, j, ref)


    def getPidReferencesRaw(self, pidtype, refs):
        """getPidReferencesRaw(IPidControlRaw self, yarp::dev::PidControlTypeEnum const & pidtype, double * refs) -> bool"""
        return _yarp.IPidControlRaw_getPidReferencesRaw(self, pidtype, refs)


    def getPidErrorLimitRaw(self, pidtype, j, limit):
        """getPidErrorLimitRaw(IPidControlRaw self, yarp::dev::PidControlTypeEnum const & pidtype, int j, double * limit) -> bool"""
        return _yarp.IPidControlRaw_getPidErrorLimitRaw(self, pidtype, j, limit)


    def getPidErrorLimitsRaw(self, pidtype, limits):
        """getPidErrorLimitsRaw(IPidControlRaw self, yarp::dev::PidControlTypeEnum const & pidtype, double * limits) -> bool"""
        return _yarp.IPidControlRaw_getPidErrorLimitsRaw(self, pidtype, limits)


    def resetPidRaw(self, *args):
        """
        resetPidRaw(IPidControlRaw self, int j) -> bool
        resetPidRaw(IPidControlRaw self, yarp::dev::PidControlTypeEnum const & pidtype, int j) -> bool
        """
        return _yarp.IPidControlRaw_resetPidRaw(self, *args)


    def disablePidRaw(self, *args):
        """
        disablePidRaw(IPidControlRaw self, int j) -> bool
        disablePidRaw(IPidControlRaw self, yarp::dev::PidControlTypeEnum const & pidtype, int j) -> bool
        """
        return _yarp.IPidControlRaw_disablePidRaw(self, *args)


    def enablePidRaw(self, *args):
        """
        enablePidRaw(IPidControlRaw self, int j) -> bool
        enablePidRaw(IPidControlRaw self, yarp::dev::PidControlTypeEnum const & pidtype, int j) -> bool
        """
        return _yarp.IPidControlRaw_enablePidRaw(self, *args)


    def setPidOffsetRaw(self, pidtype, j, v):
        """setPidOffsetRaw(IPidControlRaw self, yarp::dev::PidControlTypeEnum const & pidtype, int j, double v) -> bool"""
        return _yarp.IPidControlRaw_setPidOffsetRaw(self, pidtype, j, v)


    def isPidEnabledRaw(self, pidtype, j, enabled):
        """isPidEnabledRaw(IPidControlRaw self, yarp::dev::PidControlTypeEnum const & pidtype, int j, bool * enabled) -> bool"""
        return _yarp.IPidControlRaw_isPidEnabledRaw(self, pidtype, j, enabled)

IPidControlRaw_swigregister = _yarp.IPidControlRaw_swigregister
IPidControlRaw_swigregister(IPidControlRaw)

class IPidControl(_object):
    """Proxy of C++ yarp::dev::IPidControl class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IPidControl, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IPidControl, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_IPidControl
    __del__ = lambda self: None

    def setReference(self, j, ref):
        """setReference(IPidControl self, int j, double ref) -> bool"""
        return _yarp.IPidControl_setReference(self, j, ref)


    def setErrorLimit(self, j, limit):
        """setErrorLimit(IPidControl self, int j, double limit) -> bool"""
        return _yarp.IPidControl_setErrorLimit(self, j, limit)


    def setOffset(self, j, v):
        """setOffset(IPidControl self, int j, double v) -> bool"""
        return _yarp.IPidControl_setOffset(self, j, v)


    def setPidReference(self, pidtype, j, ref):
        """setPidReference(IPidControl self, yarp::dev::PidControlTypeEnum const & pidtype, int j, double ref) -> bool"""
        return _yarp.IPidControl_setPidReference(self, pidtype, j, ref)


    def setPidReferences(self, pidtype, refs):
        """setPidReferences(IPidControl self, yarp::dev::PidControlTypeEnum const & pidtype, double const * refs) -> bool"""
        return _yarp.IPidControl_setPidReferences(self, pidtype, refs)


    def setPidErrorLimit(self, pidtype, j, limit):
        """setPidErrorLimit(IPidControl self, yarp::dev::PidControlTypeEnum const & pidtype, int j, double limit) -> bool"""
        return _yarp.IPidControl_setPidErrorLimit(self, pidtype, j, limit)


    def setPidErrorLimits(self, pidtype, limits):
        """setPidErrorLimits(IPidControl self, yarp::dev::PidControlTypeEnum const & pidtype, double const * limits) -> bool"""
        return _yarp.IPidControl_setPidErrorLimits(self, pidtype, limits)


    def getPidError(self, pidtype, j, err):
        """getPidError(IPidControl self, yarp::dev::PidControlTypeEnum const & pidtype, int j, double * err) -> bool"""
        return _yarp.IPidControl_getPidError(self, pidtype, j, err)


    def getPidErrors(self, pidtype, errs):
        """getPidErrors(IPidControl self, yarp::dev::PidControlTypeEnum const & pidtype, double * errs) -> bool"""
        return _yarp.IPidControl_getPidErrors(self, pidtype, errs)


    def getPidOutput(self, pidtype, j, out):
        """getPidOutput(IPidControl self, yarp::dev::PidControlTypeEnum const & pidtype, int j, double * out) -> bool"""
        return _yarp.IPidControl_getPidOutput(self, pidtype, j, out)


    def getPidOutputs(self, pidtype, outs):
        """getPidOutputs(IPidControl self, yarp::dev::PidControlTypeEnum const & pidtype, double * outs) -> bool"""
        return _yarp.IPidControl_getPidOutputs(self, pidtype, outs)


    def getPidReference(self, pidtype, j, ref):
        """getPidReference(IPidControl self, yarp::dev::PidControlTypeEnum const & pidtype, int j, double * ref) -> bool"""
        return _yarp.IPidControl_getPidReference(self, pidtype, j, ref)


    def getPidReferences(self, pidtype, refs):
        """getPidReferences(IPidControl self, yarp::dev::PidControlTypeEnum const & pidtype, double * refs) -> bool"""
        return _yarp.IPidControl_getPidReferences(self, pidtype, refs)


    def getPidErrorLimit(self, pidtype, j, limit):
        """getPidErrorLimit(IPidControl self, yarp::dev::PidControlTypeEnum const & pidtype, int j, double * limit) -> bool"""
        return _yarp.IPidControl_getPidErrorLimit(self, pidtype, j, limit)


    def getPidErrorLimits(self, pidtype, limits):
        """getPidErrorLimits(IPidControl self, yarp::dev::PidControlTypeEnum const & pidtype, double * limits) -> bool"""
        return _yarp.IPidControl_getPidErrorLimits(self, pidtype, limits)


    def resetPid(self, *args):
        """
        resetPid(IPidControl self, int j) -> bool
        resetPid(IPidControl self, yarp::dev::PidControlTypeEnum const & pidtype, int j) -> bool
        """
        return _yarp.IPidControl_resetPid(self, *args)


    def disablePid(self, *args):
        """
        disablePid(IPidControl self, int j) -> bool
        disablePid(IPidControl self, yarp::dev::PidControlTypeEnum const & pidtype, int j) -> bool
        """
        return _yarp.IPidControl_disablePid(self, *args)


    def enablePid(self, *args):
        """
        enablePid(IPidControl self, int j) -> bool
        enablePid(IPidControl self, yarp::dev::PidControlTypeEnum const & pidtype, int j) -> bool
        """
        return _yarp.IPidControl_enablePid(self, *args)


    def setPidOffset(self, pidtype, j, v):
        """setPidOffset(IPidControl self, yarp::dev::PidControlTypeEnum const & pidtype, int j, double v) -> bool"""
        return _yarp.IPidControl_setPidOffset(self, pidtype, j, v)


    def isPidEnabled(self, pidtype, j, enabled):
        """isPidEnabled(IPidControl self, yarp::dev::PidControlTypeEnum const & pidtype, int j, bool * enabled) -> bool"""
        return _yarp.IPidControl_isPidEnabled(self, pidtype, j, enabled)


    def setReferences(self, *args):
        """
        setReferences(IPidControl self, double const * refs) -> bool
        setReferences(IPidControl self, DVector data) -> bool
        """
        return _yarp.IPidControl_setReferences(self, *args)


    def getReference(self, *args):
        """
        getReference(IPidControl self, int j, double * ref) -> bool
        getReference(IPidControl self, int j, DVector data) -> bool
        """
        return _yarp.IPidControl_getReference(self, *args)


    def getReferences(self, *args):
        """
        getReferences(IPidControl self, double * refs) -> bool
        getReferences(IPidControl self, DVector data) -> bool
        """
        return _yarp.IPidControl_getReferences(self, *args)


    def setErrorLimits(self, *args):
        """
        setErrorLimits(IPidControl self, double const * limits) -> bool
        setErrorLimits(IPidControl self, DVector data) -> bool
        """
        return _yarp.IPidControl_setErrorLimits(self, *args)


    def getErrorLimit(self, *args):
        """
        getErrorLimit(IPidControl self, int j, double * limit) -> bool
        getErrorLimit(IPidControl self, int j, DVector data) -> bool
        """
        return _yarp.IPidControl_getErrorLimit(self, *args)


    def getErrorLimits(self, *args):
        """
        getErrorLimits(IPidControl self, double * limits) -> bool
        getErrorLimits(IPidControl self, DVector data) -> bool
        """
        return _yarp.IPidControl_getErrorLimits(self, *args)


    def getError(self, *args):
        """
        getError(IPidControl self, int j, double * err) -> bool
        getError(IPidControl self, int j, DVector data) -> bool
        """
        return _yarp.IPidControl_getError(self, *args)


    def getErrors(self, *args):
        """
        getErrors(IPidControl self, double * errs) -> bool
        getErrors(IPidControl self, DVector data) -> bool
        """
        return _yarp.IPidControl_getErrors(self, *args)


    def getOutput(self, *args):
        """
        getOutput(IPidControl self, int j, double * out) -> bool
        getOutput(IPidControl self, int j, DVector data) -> bool
        """
        return _yarp.IPidControl_getOutput(self, *args)


    def getOutputs(self, *args):
        """
        getOutputs(IPidControl self, double * outs) -> bool
        getOutputs(IPidControl self, DVector data) -> bool
        """
        return _yarp.IPidControl_getOutputs(self, *args)


    def setPid(self, *args):
        """
        setPid(IPidControl self, yarp::dev::PidControlTypeEnum const & pidtype, int j, Pid pid) -> bool
        setPid(IPidControl self, int j, Pid pid) -> bool
        """
        return _yarp.IPidControl_setPid(self, *args)


    def setPids(self, *args):
        """
        setPids(IPidControl self, Pid pids) -> bool
        setPids(IPidControl self, yarp::dev::PidControlTypeEnum const & pidtype, Pid pids) -> bool
        setPids(IPidControl self, PidVector pids) -> bool
        """
        return _yarp.IPidControl_setPids(self, *args)


    def getPid(self, *args):
        """
        getPid(IPidControl self, yarp::dev::PidControlTypeEnum const & pidtype, int j, Pid pid) -> bool
        getPid(IPidControl self, int j, PidVector pid) -> bool
        """
        return _yarp.IPidControl_getPid(self, *args)


    def getPids(self, *args):
        """
        getPids(IPidControl self, Pid pids) -> bool
        getPids(IPidControl self, yarp::dev::PidControlTypeEnum const & pidtype, Pid pids) -> bool
        getPids(IPidControl self, PidVector pids) -> bool
        """
        return _yarp.IPidControl_getPids(self, *args)

IPidControl_swigregister = _yarp.IPidControl_swigregister
IPidControl_swigregister(IPidControl)

class IPositionDirect(_object):
    """Proxy of C++ yarp::dev::IPositionDirect class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IPositionDirect, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IPositionDirect, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_IPositionDirect
    __del__ = lambda self: None

    def setPosition(self, j, ref):
        """setPosition(IPositionDirect self, int j, double ref) -> bool"""
        return _yarp.IPositionDirect_setPosition(self, j, ref)


    def getRefPosition(self, joint, ref):
        """getRefPosition(IPositionDirect self, int const joint, double * ref) -> bool"""
        return _yarp.IPositionDirect_getRefPosition(self, joint, ref)


    def getRefPositions(self, *args):
        """
        getRefPositions(IPositionDirect self, double * refs) -> bool
        getRefPositions(IPositionDirect self, int const n_joint, int const * joints, double * refs) -> bool
        """
        return _yarp.IPositionDirect_getRefPositions(self, *args)


    def getAxes(self, *args):
        """
        getAxes(IPositionDirect self, int * ax) -> bool
        getAxes(IPositionDirect self) -> int
        """
        return _yarp.IPositionDirect_getAxes(self, *args)


    def setPositions(self, *args):
        """
        setPositions(IPositionDirect self, int const n_joint, int const * joints, double * refs) -> bool
        setPositions(IPositionDirect self, double const * refs) -> bool
        setPositions(IPositionDirect self, DVector data) -> bool
        """
        return _yarp.IPositionDirect_setPositions(self, *args)

IPositionDirect_swigregister = _yarp.IPositionDirect_swigregister
IPositionDirect_swigregister(IPositionDirect)

class IPositionDirectRaw(_object):
    """Proxy of C++ yarp::dev::IPositionDirectRaw class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IPositionDirectRaw, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IPositionDirectRaw, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_IPositionDirectRaw
    __del__ = lambda self: None

    def getAxes(self, axes):
        """getAxes(IPositionDirectRaw self, int * axes) -> bool"""
        return _yarp.IPositionDirectRaw_getAxes(self, axes)


    def setPositionRaw(self, j, ref):
        """setPositionRaw(IPositionDirectRaw self, int j, double ref) -> bool"""
        return _yarp.IPositionDirectRaw_setPositionRaw(self, j, ref)


    def setPositionsRaw(self, *args):
        """
        setPositionsRaw(IPositionDirectRaw self, int const n_joint, int const * joints, double * refs) -> bool
        setPositionsRaw(IPositionDirectRaw self, double const * refs) -> bool
        """
        return _yarp.IPositionDirectRaw_setPositionsRaw(self, *args)


    def getRefPositionRaw(self, joint, ref):
        """getRefPositionRaw(IPositionDirectRaw self, int const joint, double * ref) -> bool"""
        return _yarp.IPositionDirectRaw_getRefPositionRaw(self, joint, ref)


    def getRefPositionsRaw(self, *args):
        """
        getRefPositionsRaw(IPositionDirectRaw self, double * refs) -> bool
        getRefPositionsRaw(IPositionDirectRaw self, int const n_joint, int const * joints, double * refs) -> bool
        """
        return _yarp.IPositionDirectRaw_getRefPositionsRaw(self, *args)

IPositionDirectRaw_swigregister = _yarp.IPositionDirectRaw_swigregister
IPositionDirectRaw_swigregister(IPositionDirectRaw)

class DVector(_object):
    """Proxy of C++ std::vector<(double)> class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, DVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, DVector, name)
    __repr__ = _swig_repr

    def iterator(self):
        """iterator(DVector self) -> SwigPyIterator"""
        return _yarp.DVector_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        """__nonzero__(DVector self) -> bool"""
        return _yarp.DVector___nonzero__(self)


    def __bool__(self):
        """__bool__(DVector self) -> bool"""
        return _yarp.DVector___bool__(self)


    def __len__(self):
        """__len__(DVector self) -> std::vector< double >::size_type"""
        return _yarp.DVector___len__(self)


    def __getslice__(self, i, j):
        """__getslice__(DVector self, std::vector< double >::difference_type i, std::vector< double >::difference_type j) -> DVector"""
        return _yarp.DVector___getslice__(self, i, j)


    def __setslice__(self, *args):
        """
        __setslice__(DVector self, std::vector< double >::difference_type i, std::vector< double >::difference_type j)
        __setslice__(DVector self, std::vector< double >::difference_type i, std::vector< double >::difference_type j, DVector v)
        """
        return _yarp.DVector___setslice__(self, *args)


    def __delslice__(self, i, j):
        """__delslice__(DVector self, std::vector< double >::difference_type i, std::vector< double >::difference_type j)"""
        return _yarp.DVector___delslice__(self, i, j)


    def __delitem__(self, *args):
        """
        __delitem__(DVector self, std::vector< double >::difference_type i)
        __delitem__(DVector self, PySliceObject * slice)
        """
        return _yarp.DVector___delitem__(self, *args)


    def __getitem__(self, *args):
        """
        __getitem__(DVector self, PySliceObject * slice) -> DVector
        __getitem__(DVector self, std::vector< double >::difference_type i) -> std::vector< double >::value_type const &
        """
        return _yarp.DVector___getitem__(self, *args)


    def __setitem__(self, *args):
        """
        __setitem__(DVector self, PySliceObject * slice, DVector v)
        __setitem__(DVector self, PySliceObject * slice)
        __setitem__(DVector self, std::vector< double >::difference_type i, std::vector< double >::value_type const & x)
        """
        return _yarp.DVector___setitem__(self, *args)


    def pop(self):
        """pop(DVector self) -> std::vector< double >::value_type"""
        return _yarp.DVector_pop(self)


    def append(self, x):
        """append(DVector self, std::vector< double >::value_type const & x)"""
        return _yarp.DVector_append(self, x)


    def empty(self):
        """empty(DVector self) -> bool"""
        return _yarp.DVector_empty(self)


    def size(self):
        """size(DVector self) -> std::vector< double >::size_type"""
        return _yarp.DVector_size(self)


    def swap(self, v):
        """swap(DVector self, DVector v)"""
        return _yarp.DVector_swap(self, v)


    def begin(self):
        """begin(DVector self) -> std::vector< double >::iterator"""
        return _yarp.DVector_begin(self)


    def end(self):
        """end(DVector self) -> std::vector< double >::iterator"""
        return _yarp.DVector_end(self)


    def rbegin(self):
        """rbegin(DVector self) -> std::vector< double >::reverse_iterator"""
        return _yarp.DVector_rbegin(self)


    def rend(self):
        """rend(DVector self) -> std::vector< double >::reverse_iterator"""
        return _yarp.DVector_rend(self)


    def clear(self):
        """clear(DVector self)"""
        return _yarp.DVector_clear(self)


    def get_allocator(self):
        """get_allocator(DVector self) -> std::vector< double >::allocator_type"""
        return _yarp.DVector_get_allocator(self)


    def pop_back(self):
        """pop_back(DVector self)"""
        return _yarp.DVector_pop_back(self)


    def erase(self, *args):
        """
        erase(DVector self, std::vector< double >::iterator pos) -> std::vector< double >::iterator
        erase(DVector self, std::vector< double >::iterator first, std::vector< double >::iterator last) -> std::vector< double >::iterator
        """
        return _yarp.DVector_erase(self, *args)


    def __init__(self, *args):
        """
        __init__(std::vector<(double)> self) -> DVector
        __init__(std::vector<(double)> self, DVector arg2) -> DVector
        __init__(std::vector<(double)> self, std::vector< double >::size_type size) -> DVector
        __init__(std::vector<(double)> self, std::vector< double >::size_type size, std::vector< double >::value_type const & value) -> DVector
        """
        this = _yarp.new_DVector(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def push_back(self, x):
        """push_back(DVector self, std::vector< double >::value_type const & x)"""
        return _yarp.DVector_push_back(self, x)


    def front(self):
        """front(DVector self) -> std::vector< double >::value_type const &"""
        return _yarp.DVector_front(self)


    def back(self):
        """back(DVector self) -> std::vector< double >::value_type const &"""
        return _yarp.DVector_back(self)


    def assign(self, n, x):
        """assign(DVector self, std::vector< double >::size_type n, std::vector< double >::value_type const & x)"""
        return _yarp.DVector_assign(self, n, x)


    def resize(self, *args):
        """
        resize(DVector self, std::vector< double >::size_type new_size)
        resize(DVector self, std::vector< double >::size_type new_size, std::vector< double >::value_type const & x)
        """
        return _yarp.DVector_resize(self, *args)


    def insert(self, *args):
        """
        insert(DVector self, std::vector< double >::iterator pos, std::vector< double >::value_type const & x) -> std::vector< double >::iterator
        insert(DVector self, std::vector< double >::iterator pos, std::vector< double >::size_type n, std::vector< double >::value_type const & x)
        """
        return _yarp.DVector_insert(self, *args)


    def reserve(self, n):
        """reserve(DVector self, std::vector< double >::size_type n)"""
        return _yarp.DVector_reserve(self, n)


    def capacity(self):
        """capacity(DVector self) -> std::vector< double >::size_type"""
        return _yarp.DVector_capacity(self)

    __swig_destroy__ = _yarp.delete_DVector
    __del__ = lambda self: None
DVector_swigregister = _yarp.DVector_swigregister
DVector_swigregister(DVector)

class BVector(_object):
    """Proxy of C++ std::vector<(bool)> class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, BVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, BVector, name)
    __repr__ = _swig_repr

    def iterator(self):
        """iterator(BVector self) -> SwigPyIterator"""
        return _yarp.BVector_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        """__nonzero__(BVector self) -> bool"""
        return _yarp.BVector___nonzero__(self)


    def __bool__(self):
        """__bool__(BVector self) -> bool"""
        return _yarp.BVector___bool__(self)


    def __len__(self):
        """__len__(BVector self) -> std::vector< bool >::size_type"""
        return _yarp.BVector___len__(self)


    def __getslice__(self, i, j):
        """__getslice__(BVector self, std::vector< bool >::difference_type i, std::vector< bool >::difference_type j) -> BVector"""
        return _yarp.BVector___getslice__(self, i, j)


    def __setslice__(self, *args):
        """
        __setslice__(BVector self, std::vector< bool >::difference_type i, std::vector< bool >::difference_type j)
        __setslice__(BVector self, std::vector< bool >::difference_type i, std::vector< bool >::difference_type j, BVector v)
        """
        return _yarp.BVector___setslice__(self, *args)


    def __delslice__(self, i, j):
        """__delslice__(BVector self, std::vector< bool >::difference_type i, std::vector< bool >::difference_type j)"""
        return _yarp.BVector___delslice__(self, i, j)


    def __delitem__(self, *args):
        """
        __delitem__(BVector self, std::vector< bool >::difference_type i)
        __delitem__(BVector self, PySliceObject * slice)
        """
        return _yarp.BVector___delitem__(self, *args)


    def __getitem__(self, *args):
        """
        __getitem__(BVector self, PySliceObject * slice) -> BVector
        __getitem__(BVector self, std::vector< bool >::difference_type i) -> std::vector< bool >::value_type
        """
        return _yarp.BVector___getitem__(self, *args)


    def __setitem__(self, *args):
        """
        __setitem__(BVector self, PySliceObject * slice, BVector v)
        __setitem__(BVector self, PySliceObject * slice)
        __setitem__(BVector self, std::vector< bool >::difference_type i, std::vector< bool >::value_type x)
        """
        return _yarp.BVector___setitem__(self, *args)


    def pop(self):
        """pop(BVector self) -> std::vector< bool >::value_type"""
        return _yarp.BVector_pop(self)


    def append(self, x):
        """append(BVector self, std::vector< bool >::value_type x)"""
        return _yarp.BVector_append(self, x)


    def empty(self):
        """empty(BVector self) -> bool"""
        return _yarp.BVector_empty(self)


    def size(self):
        """size(BVector self) -> std::vector< bool >::size_type"""
        return _yarp.BVector_size(self)


    def swap(self, v):
        """swap(BVector self, BVector v)"""
        return _yarp.BVector_swap(self, v)


    def begin(self):
        """begin(BVector self) -> std::vector< bool >::iterator"""
        return _yarp.BVector_begin(self)


    def end(self):
        """end(BVector self) -> std::vector< bool >::iterator"""
        return _yarp.BVector_end(self)


    def rbegin(self):
        """rbegin(BVector self) -> std::vector< bool >::reverse_iterator"""
        return _yarp.BVector_rbegin(self)


    def rend(self):
        """rend(BVector self) -> std::vector< bool >::reverse_iterator"""
        return _yarp.BVector_rend(self)


    def clear(self):
        """clear(BVector self)"""
        return _yarp.BVector_clear(self)


    def get_allocator(self):
        """get_allocator(BVector self) -> std::vector< bool >::allocator_type"""
        return _yarp.BVector_get_allocator(self)


    def pop_back(self):
        """pop_back(BVector self)"""
        return _yarp.BVector_pop_back(self)


    def erase(self, *args):
        """
        erase(BVector self, std::vector< bool >::iterator pos) -> std::vector< bool >::iterator
        erase(BVector self, std::vector< bool >::iterator first, std::vector< bool >::iterator last) -> std::vector< bool >::iterator
        """
        return _yarp.BVector_erase(self, *args)


    def __init__(self, *args):
        """
        __init__(std::vector<(bool)> self) -> BVector
        __init__(std::vector<(bool)> self, BVector arg2) -> BVector
        __init__(std::vector<(bool)> self, std::vector< bool >::size_type size) -> BVector
        __init__(std::vector<(bool)> self, std::vector< bool >::size_type size, std::vector< bool >::value_type value) -> BVector
        """
        this = _yarp.new_BVector(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def push_back(self, x):
        """push_back(BVector self, std::vector< bool >::value_type x)"""
        return _yarp.BVector_push_back(self, x)


    def front(self):
        """front(BVector self) -> std::vector< bool >::value_type"""
        return _yarp.BVector_front(self)


    def back(self):
        """back(BVector self) -> std::vector< bool >::value_type"""
        return _yarp.BVector_back(self)


    def assign(self, n, x):
        """assign(BVector self, std::vector< bool >::size_type n, std::vector< bool >::value_type x)"""
        return _yarp.BVector_assign(self, n, x)


    def resize(self, *args):
        """
        resize(BVector self, std::vector< bool >::size_type new_size)
        resize(BVector self, std::vector< bool >::size_type new_size, std::vector< bool >::value_type x)
        """
        return _yarp.BVector_resize(self, *args)


    def insert(self, *args):
        """
        insert(BVector self, std::vector< bool >::iterator pos, std::vector< bool >::value_type x) -> std::vector< bool >::iterator
        insert(BVector self, std::vector< bool >::iterator pos, std::vector< bool >::size_type n, std::vector< bool >::value_type x)
        """
        return _yarp.BVector_insert(self, *args)


    def reserve(self, n):
        """reserve(BVector self, std::vector< bool >::size_type n)"""
        return _yarp.BVector_reserve(self, n)


    def capacity(self):
        """capacity(BVector self) -> std::vector< bool >::size_type"""
        return _yarp.BVector_capacity(self)

    __swig_destroy__ = _yarp.delete_BVector
    __del__ = lambda self: None
BVector_swigregister = _yarp.BVector_swigregister
BVector_swigregister(BVector)

class SVector(_object):
    """Proxy of C++ std::vector<(std::string)> class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SVector, name)
    __repr__ = _swig_repr

    def iterator(self):
        """iterator(SVector self) -> SwigPyIterator"""
        return _yarp.SVector_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        """__nonzero__(SVector self) -> bool"""
        return _yarp.SVector___nonzero__(self)


    def __bool__(self):
        """__bool__(SVector self) -> bool"""
        return _yarp.SVector___bool__(self)


    def __len__(self):
        """__len__(SVector self) -> std::vector< std::string >::size_type"""
        return _yarp.SVector___len__(self)


    def __getslice__(self, i, j):
        """__getslice__(SVector self, std::vector< std::string >::difference_type i, std::vector< std::string >::difference_type j) -> SVector"""
        return _yarp.SVector___getslice__(self, i, j)


    def __setslice__(self, *args):
        """
        __setslice__(SVector self, std::vector< std::string >::difference_type i, std::vector< std::string >::difference_type j)
        __setslice__(SVector self, std::vector< std::string >::difference_type i, std::vector< std::string >::difference_type j, SVector v)
        """
        return _yarp.SVector___setslice__(self, *args)


    def __delslice__(self, i, j):
        """__delslice__(SVector self, std::vector< std::string >::difference_type i, std::vector< std::string >::difference_type j)"""
        return _yarp.SVector___delslice__(self, i, j)


    def __delitem__(self, *args):
        """
        __delitem__(SVector self, std::vector< std::string >::difference_type i)
        __delitem__(SVector self, PySliceObject * slice)
        """
        return _yarp.SVector___delitem__(self, *args)


    def __getitem__(self, *args):
        """
        __getitem__(SVector self, PySliceObject * slice) -> SVector
        __getitem__(SVector self, std::vector< std::string >::difference_type i) -> std::vector< std::string >::value_type const &
        """
        return _yarp.SVector___getitem__(self, *args)


    def __setitem__(self, *args):
        """
        __setitem__(SVector self, PySliceObject * slice, SVector v)
        __setitem__(SVector self, PySliceObject * slice)
        __setitem__(SVector self, std::vector< std::string >::difference_type i, std::vector< std::string >::value_type const & x)
        """
        return _yarp.SVector___setitem__(self, *args)


    def pop(self):
        """pop(SVector self) -> std::vector< std::string >::value_type"""
        return _yarp.SVector_pop(self)


    def append(self, x):
        """append(SVector self, std::vector< std::string >::value_type const & x)"""
        return _yarp.SVector_append(self, x)


    def empty(self):
        """empty(SVector self) -> bool"""
        return _yarp.SVector_empty(self)


    def size(self):
        """size(SVector self) -> std::vector< std::string >::size_type"""
        return _yarp.SVector_size(self)


    def swap(self, v):
        """swap(SVector self, SVector v)"""
        return _yarp.SVector_swap(self, v)


    def begin(self):
        """begin(SVector self) -> std::vector< std::string >::iterator"""
        return _yarp.SVector_begin(self)


    def end(self):
        """end(SVector self) -> std::vector< std::string >::iterator"""
        return _yarp.SVector_end(self)


    def rbegin(self):
        """rbegin(SVector self) -> std::vector< std::string >::reverse_iterator"""
        return _yarp.SVector_rbegin(self)


    def rend(self):
        """rend(SVector self) -> std::vector< std::string >::reverse_iterator"""
        return _yarp.SVector_rend(self)


    def clear(self):
        """clear(SVector self)"""
        return _yarp.SVector_clear(self)


    def get_allocator(self):
        """get_allocator(SVector self) -> std::vector< std::string >::allocator_type"""
        return _yarp.SVector_get_allocator(self)


    def pop_back(self):
        """pop_back(SVector self)"""
        return _yarp.SVector_pop_back(self)


    def erase(self, *args):
        """
        erase(SVector self, std::vector< std::string >::iterator pos) -> std::vector< std::string >::iterator
        erase(SVector self, std::vector< std::string >::iterator first, std::vector< std::string >::iterator last) -> std::vector< std::string >::iterator
        """
        return _yarp.SVector_erase(self, *args)


    def __init__(self, *args):
        """
        __init__(std::vector<(std::string)> self) -> SVector
        __init__(std::vector<(std::string)> self, SVector arg2) -> SVector
        __init__(std::vector<(std::string)> self, std::vector< std::string >::size_type size) -> SVector
        __init__(std::vector<(std::string)> self, std::vector< std::string >::size_type size, std::vector< std::string >::value_type const & value) -> SVector
        """
        this = _yarp.new_SVector(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def push_back(self, x):
        """push_back(SVector self, std::vector< std::string >::value_type const & x)"""
        return _yarp.SVector_push_back(self, x)


    def front(self):
        """front(SVector self) -> std::vector< std::string >::value_type const &"""
        return _yarp.SVector_front(self)


    def back(self):
        """back(SVector self) -> std::vector< std::string >::value_type const &"""
        return _yarp.SVector_back(self)


    def assign(self, n, x):
        """assign(SVector self, std::vector< std::string >::size_type n, std::vector< std::string >::value_type const & x)"""
        return _yarp.SVector_assign(self, n, x)


    def resize(self, *args):
        """
        resize(SVector self, std::vector< std::string >::size_type new_size)
        resize(SVector self, std::vector< std::string >::size_type new_size, std::vector< std::string >::value_type const & x)
        """
        return _yarp.SVector_resize(self, *args)


    def insert(self, *args):
        """
        insert(SVector self, std::vector< std::string >::iterator pos, std::vector< std::string >::value_type const & x) -> std::vector< std::string >::iterator
        insert(SVector self, std::vector< std::string >::iterator pos, std::vector< std::string >::size_type n, std::vector< std::string >::value_type const & x)
        """
        return _yarp.SVector_insert(self, *args)


    def reserve(self, n):
        """reserve(SVector self, std::vector< std::string >::size_type n)"""
        return _yarp.SVector_reserve(self, n)


    def capacity(self):
        """capacity(SVector self) -> std::vector< std::string >::size_type"""
        return _yarp.SVector_capacity(self)

    __swig_destroy__ = _yarp.delete_SVector
    __del__ = lambda self: None
SVector_swigregister = _yarp.SVector_swigregister
SVector_swigregister(SVector)

class IVector(_object):
    """Proxy of C++ std::vector<(int)> class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IVector, name)
    __repr__ = _swig_repr

    def iterator(self):
        """iterator(IVector self) -> SwigPyIterator"""
        return _yarp.IVector_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        """__nonzero__(IVector self) -> bool"""
        return _yarp.IVector___nonzero__(self)


    def __bool__(self):
        """__bool__(IVector self) -> bool"""
        return _yarp.IVector___bool__(self)


    def __len__(self):
        """__len__(IVector self) -> std::vector< int >::size_type"""
        return _yarp.IVector___len__(self)


    def __getslice__(self, i, j):
        """__getslice__(IVector self, std::vector< int >::difference_type i, std::vector< int >::difference_type j) -> IVector"""
        return _yarp.IVector___getslice__(self, i, j)


    def __setslice__(self, *args):
        """
        __setslice__(IVector self, std::vector< int >::difference_type i, std::vector< int >::difference_type j)
        __setslice__(IVector self, std::vector< int >::difference_type i, std::vector< int >::difference_type j, IVector v)
        """
        return _yarp.IVector___setslice__(self, *args)


    def __delslice__(self, i, j):
        """__delslice__(IVector self, std::vector< int >::difference_type i, std::vector< int >::difference_type j)"""
        return _yarp.IVector___delslice__(self, i, j)


    def __delitem__(self, *args):
        """
        __delitem__(IVector self, std::vector< int >::difference_type i)
        __delitem__(IVector self, PySliceObject * slice)
        """
        return _yarp.IVector___delitem__(self, *args)


    def __getitem__(self, *args):
        """
        __getitem__(IVector self, PySliceObject * slice) -> IVector
        __getitem__(IVector self, std::vector< int >::difference_type i) -> std::vector< int >::value_type const &
        """
        return _yarp.IVector___getitem__(self, *args)


    def __setitem__(self, *args):
        """
        __setitem__(IVector self, PySliceObject * slice, IVector v)
        __setitem__(IVector self, PySliceObject * slice)
        __setitem__(IVector self, std::vector< int >::difference_type i, std::vector< int >::value_type const & x)
        """
        return _yarp.IVector___setitem__(self, *args)


    def pop(self):
        """pop(IVector self) -> std::vector< int >::value_type"""
        return _yarp.IVector_pop(self)


    def append(self, x):
        """append(IVector self, std::vector< int >::value_type const & x)"""
        return _yarp.IVector_append(self, x)


    def empty(self):
        """empty(IVector self) -> bool"""
        return _yarp.IVector_empty(self)


    def size(self):
        """size(IVector self) -> std::vector< int >::size_type"""
        return _yarp.IVector_size(self)


    def swap(self, v):
        """swap(IVector self, IVector v)"""
        return _yarp.IVector_swap(self, v)


    def begin(self):
        """begin(IVector self) -> std::vector< int >::iterator"""
        return _yarp.IVector_begin(self)


    def end(self):
        """end(IVector self) -> std::vector< int >::iterator"""
        return _yarp.IVector_end(self)


    def rbegin(self):
        """rbegin(IVector self) -> std::vector< int >::reverse_iterator"""
        return _yarp.IVector_rbegin(self)


    def rend(self):
        """rend(IVector self) -> std::vector< int >::reverse_iterator"""
        return _yarp.IVector_rend(self)


    def clear(self):
        """clear(IVector self)"""
        return _yarp.IVector_clear(self)


    def get_allocator(self):
        """get_allocator(IVector self) -> std::vector< int >::allocator_type"""
        return _yarp.IVector_get_allocator(self)


    def pop_back(self):
        """pop_back(IVector self)"""
        return _yarp.IVector_pop_back(self)


    def erase(self, *args):
        """
        erase(IVector self, std::vector< int >::iterator pos) -> std::vector< int >::iterator
        erase(IVector self, std::vector< int >::iterator first, std::vector< int >::iterator last) -> std::vector< int >::iterator
        """
        return _yarp.IVector_erase(self, *args)


    def __init__(self, *args):
        """
        __init__(std::vector<(int)> self) -> IVector
        __init__(std::vector<(int)> self, IVector arg2) -> IVector
        __init__(std::vector<(int)> self, std::vector< int >::size_type size) -> IVector
        __init__(std::vector<(int)> self, std::vector< int >::size_type size, std::vector< int >::value_type const & value) -> IVector
        """
        this = _yarp.new_IVector(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def push_back(self, x):
        """push_back(IVector self, std::vector< int >::value_type const & x)"""
        return _yarp.IVector_push_back(self, x)


    def front(self):
        """front(IVector self) -> std::vector< int >::value_type const &"""
        return _yarp.IVector_front(self)


    def back(self):
        """back(IVector self) -> std::vector< int >::value_type const &"""
        return _yarp.IVector_back(self)


    def assign(self, n, x):
        """assign(IVector self, std::vector< int >::size_type n, std::vector< int >::value_type const & x)"""
        return _yarp.IVector_assign(self, n, x)


    def resize(self, *args):
        """
        resize(IVector self, std::vector< int >::size_type new_size)
        resize(IVector self, std::vector< int >::size_type new_size, std::vector< int >::value_type const & x)
        """
        return _yarp.IVector_resize(self, *args)


    def insert(self, *args):
        """
        insert(IVector self, std::vector< int >::iterator pos, std::vector< int >::value_type const & x) -> std::vector< int >::iterator
        insert(IVector self, std::vector< int >::iterator pos, std::vector< int >::size_type n, std::vector< int >::value_type const & x)
        """
        return _yarp.IVector_insert(self, *args)


    def reserve(self, n):
        """reserve(IVector self, std::vector< int >::size_type n)"""
        return _yarp.IVector_reserve(self, n)


    def capacity(self):
        """capacity(IVector self) -> std::vector< int >::size_type"""
        return _yarp.IVector_capacity(self)

    __swig_destroy__ = _yarp.delete_IVector
    __del__ = lambda self: None
IVector_swigregister = _yarp.IVector_swigregister
IVector_swigregister(IVector)

class PidVector(_object):
    """Proxy of C++ std::vector<(yarp::dev::Pid)> class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PidVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PidVector, name)
    __repr__ = _swig_repr

    def iterator(self):
        """iterator(PidVector self) -> SwigPyIterator"""
        return _yarp.PidVector_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        """__nonzero__(PidVector self) -> bool"""
        return _yarp.PidVector___nonzero__(self)


    def __bool__(self):
        """__bool__(PidVector self) -> bool"""
        return _yarp.PidVector___bool__(self)


    def __len__(self):
        """__len__(PidVector self) -> std::vector< yarp::dev::Pid >::size_type"""
        return _yarp.PidVector___len__(self)


    def __getslice__(self, i, j):
        """__getslice__(PidVector self, std::vector< yarp::dev::Pid >::difference_type i, std::vector< yarp::dev::Pid >::difference_type j) -> PidVector"""
        return _yarp.PidVector___getslice__(self, i, j)


    def __setslice__(self, *args):
        """
        __setslice__(PidVector self, std::vector< yarp::dev::Pid >::difference_type i, std::vector< yarp::dev::Pid >::difference_type j)
        __setslice__(PidVector self, std::vector< yarp::dev::Pid >::difference_type i, std::vector< yarp::dev::Pid >::difference_type j, PidVector v)
        """
        return _yarp.PidVector___setslice__(self, *args)


    def __delslice__(self, i, j):
        """__delslice__(PidVector self, std::vector< yarp::dev::Pid >::difference_type i, std::vector< yarp::dev::Pid >::difference_type j)"""
        return _yarp.PidVector___delslice__(self, i, j)


    def __delitem__(self, *args):
        """
        __delitem__(PidVector self, std::vector< yarp::dev::Pid >::difference_type i)
        __delitem__(PidVector self, PySliceObject * slice)
        """
        return _yarp.PidVector___delitem__(self, *args)


    def __getitem__(self, *args):
        """
        __getitem__(PidVector self, PySliceObject * slice) -> PidVector
        __getitem__(PidVector self, std::vector< yarp::dev::Pid >::difference_type i) -> Pid
        """
        return _yarp.PidVector___getitem__(self, *args)


    def __setitem__(self, *args):
        """
        __setitem__(PidVector self, PySliceObject * slice, PidVector v)
        __setitem__(PidVector self, PySliceObject * slice)
        __setitem__(PidVector self, std::vector< yarp::dev::Pid >::difference_type i, Pid x)
        """
        return _yarp.PidVector___setitem__(self, *args)


    def pop(self):
        """pop(PidVector self) -> Pid"""
        return _yarp.PidVector_pop(self)


    def append(self, x):
        """append(PidVector self, Pid x)"""
        return _yarp.PidVector_append(self, x)


    def empty(self):
        """empty(PidVector self) -> bool"""
        return _yarp.PidVector_empty(self)


    def size(self):
        """size(PidVector self) -> std::vector< yarp::dev::Pid >::size_type"""
        return _yarp.PidVector_size(self)


    def swap(self, v):
        """swap(PidVector self, PidVector v)"""
        return _yarp.PidVector_swap(self, v)


    def begin(self):
        """begin(PidVector self) -> std::vector< yarp::dev::Pid >::iterator"""
        return _yarp.PidVector_begin(self)


    def end(self):
        """end(PidVector self) -> std::vector< yarp::dev::Pid >::iterator"""
        return _yarp.PidVector_end(self)


    def rbegin(self):
        """rbegin(PidVector self) -> std::vector< yarp::dev::Pid >::reverse_iterator"""
        return _yarp.PidVector_rbegin(self)


    def rend(self):
        """rend(PidVector self) -> std::vector< yarp::dev::Pid >::reverse_iterator"""
        return _yarp.PidVector_rend(self)


    def clear(self):
        """clear(PidVector self)"""
        return _yarp.PidVector_clear(self)


    def get_allocator(self):
        """get_allocator(PidVector self) -> std::vector< yarp::dev::Pid >::allocator_type"""
        return _yarp.PidVector_get_allocator(self)


    def pop_back(self):
        """pop_back(PidVector self)"""
        return _yarp.PidVector_pop_back(self)


    def erase(self, *args):
        """
        erase(PidVector self, std::vector< yarp::dev::Pid >::iterator pos) -> std::vector< yarp::dev::Pid >::iterator
        erase(PidVector self, std::vector< yarp::dev::Pid >::iterator first, std::vector< yarp::dev::Pid >::iterator last) -> std::vector< yarp::dev::Pid >::iterator
        """
        return _yarp.PidVector_erase(self, *args)


    def __init__(self, *args):
        """
        __init__(std::vector<(yarp::dev::Pid)> self) -> PidVector
        __init__(std::vector<(yarp::dev::Pid)> self, PidVector arg2) -> PidVector
        __init__(std::vector<(yarp::dev::Pid)> self, std::vector< yarp::dev::Pid >::size_type size) -> PidVector
        __init__(std::vector<(yarp::dev::Pid)> self, std::vector< yarp::dev::Pid >::size_type size, Pid value) -> PidVector
        """
        this = _yarp.new_PidVector(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def push_back(self, x):
        """push_back(PidVector self, Pid x)"""
        return _yarp.PidVector_push_back(self, x)


    def front(self):
        """front(PidVector self) -> Pid"""
        return _yarp.PidVector_front(self)


    def back(self):
        """back(PidVector self) -> Pid"""
        return _yarp.PidVector_back(self)


    def assign(self, n, x):
        """assign(PidVector self, std::vector< yarp::dev::Pid >::size_type n, Pid x)"""
        return _yarp.PidVector_assign(self, n, x)


    def resize(self, *args):
        """
        resize(PidVector self, std::vector< yarp::dev::Pid >::size_type new_size)
        resize(PidVector self, std::vector< yarp::dev::Pid >::size_type new_size, Pid x)
        """
        return _yarp.PidVector_resize(self, *args)


    def insert(self, *args):
        """
        insert(PidVector self, std::vector< yarp::dev::Pid >::iterator pos, Pid x) -> std::vector< yarp::dev::Pid >::iterator
        insert(PidVector self, std::vector< yarp::dev::Pid >::iterator pos, std::vector< yarp::dev::Pid >::size_type n, Pid x)
        """
        return _yarp.PidVector_insert(self, *args)


    def reserve(self, n):
        """reserve(PidVector self, std::vector< yarp::dev::Pid >::size_type n)"""
        return _yarp.PidVector_reserve(self, n)


    def capacity(self):
        """capacity(PidVector self) -> std::vector< yarp::dev::Pid >::size_type"""
        return _yarp.PidVector_capacity(self)

    __swig_destroy__ = _yarp.delete_PidVector
    __del__ = lambda self: None
PidVector_swigregister = _yarp.PidVector_swigregister
PidVector_swigregister(PidVector)

class ImageRgb(Image):
    """Proxy of C++ yarp::sig::ImageOf<(yarp::sig::PixelRgb)> class."""

    __swig_setmethods__ = {}
    for _s in [Image]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ImageRgb, name, value)
    __swig_getmethods__ = {}
    for _s in [Image]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ImageRgb, name)
    __repr__ = _swig_repr

    def __init__(self):
        """__init__(yarp::sig::ImageOf<(yarp::sig::PixelRgb)> self) -> ImageRgb"""
        this = _yarp.new_ImageRgb()
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def getPixelSize(self):
        """getPixelSize(ImageRgb self) -> int"""
        return _yarp.ImageRgb_getPixelSize(self)


    def getPixelCode(self):
        """getPixelCode(ImageRgb self) -> int"""
        return _yarp.ImageRgb_getPixelCode(self)


    def pixel(self, x, y):
        """pixel(ImageRgb self, int x, int y) -> PixelRgb"""
        return _yarp.ImageRgb_pixel(self, x, y)


    def access(self, x, y):
        """access(ImageRgb self, int x, int y) -> PixelRgb"""
        return _yarp.ImageRgb_access(self, x, y)


    def safePixel(self, *args):
        """
        safePixel(ImageRgb self, int x, int y) -> PixelRgb
        safePixel(ImageRgb self, int x, int y) -> PixelRgb
        """
        return _yarp.ImageRgb_safePixel(self, *args)

    __swig_destroy__ = _yarp.delete_ImageRgb
    __del__ = lambda self: None
ImageRgb_swigregister = _yarp.ImageRgb_swigregister
ImageRgb_swigregister(ImageRgb)

class TypedReaderImageRgb(_object):
    """Proxy of C++ yarp::os::TypedReader<(yarp::sig::ImageOf<(yarp::sig::PixelRgb)>)> class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, TypedReaderImageRgb, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, TypedReaderImageRgb, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def setStrict(self, strict=True):
        """
        setStrict(TypedReaderImageRgb self, bool strict=True)
        setStrict(TypedReaderImageRgb self)
        """
        return _yarp.TypedReaderImageRgb_setStrict(self, strict)


    def read(self, shouldWait=True):
        """
        read(TypedReaderImageRgb self, bool shouldWait=True) -> ImageRgb
        read(TypedReaderImageRgb self) -> ImageRgb
        """
        return _yarp.TypedReaderImageRgb_read(self, shouldWait)


    def interrupt(self):
        """interrupt(TypedReaderImageRgb self)"""
        return _yarp.TypedReaderImageRgb_interrupt(self)


    def lastRead(self):
        """lastRead(TypedReaderImageRgb self) -> ImageRgb"""
        return _yarp.TypedReaderImageRgb_lastRead(self)


    def isClosed(self):
        """isClosed(TypedReaderImageRgb self) -> bool"""
        return _yarp.TypedReaderImageRgb_isClosed(self)


    def useCallback(self, callback):
        """useCallback(TypedReaderImageRgb self, TypedReaderCallbackImageRgb callback)"""
        return _yarp.TypedReaderImageRgb_useCallback(self, callback)


    def disableCallback(self):
        """disableCallback(TypedReaderImageRgb self)"""
        return _yarp.TypedReaderImageRgb_disableCallback(self)


    def getPendingReads(self):
        """getPendingReads(TypedReaderImageRgb self) -> int"""
        return _yarp.TypedReaderImageRgb_getPendingReads(self)

    __swig_destroy__ = _yarp.delete_TypedReaderImageRgb
    __del__ = lambda self: None

    def getName(self):
        """getName(TypedReaderImageRgb self) -> yarp::os::ConstString"""
        return _yarp.TypedReaderImageRgb_getName(self)


    def setReplier(self, reader):
        """setReplier(TypedReaderImageRgb self, PortReader reader)"""
        return _yarp.TypedReaderImageRgb_setReplier(self, reader)


    def acquire(self):
        """acquire(TypedReaderImageRgb self) -> void *"""
        return _yarp.TypedReaderImageRgb_acquire(self)


    def release(self, handle):
        """release(TypedReaderImageRgb self, void * handle)"""
        return _yarp.TypedReaderImageRgb_release(self, handle)


    def setTargetPeriod(self, period):
        """setTargetPeriod(TypedReaderImageRgb self, double period)"""
        return _yarp.TypedReaderImageRgb_setTargetPeriod(self, period)

TypedReaderImageRgb_swigregister = _yarp.TypedReaderImageRgb_swigregister
TypedReaderImageRgb_swigregister(TypedReaderImageRgb)

class TypedReaderCallbackImageRgb(_object):
    """Proxy of C++ yarp::os::TypedReaderCallback<(yarp::sig::ImageOf<(yarp::sig::PixelRgb)>)> class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, TypedReaderCallbackImageRgb, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, TypedReaderCallbackImageRgb, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_TypedReaderCallbackImageRgb
    __del__ = lambda self: None

    def onRead(self, *args):
        """
        onRead(TypedReaderCallbackImageRgb self, ImageRgb datum)
        onRead(TypedReaderCallbackImageRgb self, ImageRgb datum, TypedReaderImageRgb reader)
        """
        return _yarp.TypedReaderCallbackImageRgb_onRead(self, *args)


    def __init__(self):
        """__init__(yarp::os::TypedReaderCallback<(yarp::sig::ImageOf<(yarp::sig::PixelRgb)>)> self) -> TypedReaderCallbackImageRgb"""
        this = _yarp.new_TypedReaderCallbackImageRgb()
        try:
            self.this.append(this)
        except Exception:
            self.this = this
TypedReaderCallbackImageRgb_swigregister = _yarp.TypedReaderCallbackImageRgb_swigregister
TypedReaderCallbackImageRgb_swigregister(TypedReaderCallbackImageRgb)

class BufferedPortImageRgb(Contactable, TypedReaderImageRgb, TypedReaderCallbackImageRgb):
    """Proxy of C++ yarp::os::BufferedPort<(yarp::sig::ImageOf<(yarp::sig::PixelRgb)>)> class."""

    __swig_setmethods__ = {}
    for _s in [Contactable, TypedReaderImageRgb, TypedReaderCallbackImageRgb]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, BufferedPortImageRgb, name, value)
    __swig_getmethods__ = {}
    for _s in [Contactable, TypedReaderImageRgb, TypedReaderCallbackImageRgb]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, BufferedPortImageRgb, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(yarp::os::BufferedPort<(yarp::sig::ImageOf<(yarp::sig::PixelRgb)>)> self) -> BufferedPortImageRgb
        __init__(yarp::os::BufferedPort<(yarp::sig::ImageOf<(yarp::sig::PixelRgb)>)> self, Port port) -> BufferedPortImageRgb
        """
        this = _yarp.new_BufferedPortImageRgb(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _yarp.delete_BufferedPortImageRgb
    __del__ = lambda self: None

    def addOutput(self, *args):
        """
        addOutput(BufferedPortImageRgb self, yarp::os::ConstString const & name) -> bool
        addOutput(BufferedPortImageRgb self, yarp::os::ConstString const & name, yarp::os::ConstString const & carrier) -> bool
        addOutput(BufferedPortImageRgb self, Contact contact) -> bool
        """
        return _yarp.BufferedPortImageRgb_addOutput(self, *args)


    def close(self):
        """close(BufferedPortImageRgb self)"""
        return _yarp.BufferedPortImageRgb_close(self)


    def interrupt(self):
        """interrupt(BufferedPortImageRgb self)"""
        return _yarp.BufferedPortImageRgb_interrupt(self)


    def resume(self):
        """resume(BufferedPortImageRgb self)"""
        return _yarp.BufferedPortImageRgb_resume(self)


    def getPendingReads(self):
        """getPendingReads(BufferedPortImageRgb self) -> int"""
        return _yarp.BufferedPortImageRgb_getPendingReads(self)


    def where(self):
        """where(BufferedPortImageRgb self) -> Contact"""
        return _yarp.BufferedPortImageRgb_where(self)


    def getName(self):
        """getName(BufferedPortImageRgb self) -> yarp::os::ConstString"""
        return _yarp.BufferedPortImageRgb_getName(self)


    def prepare(self):
        """prepare(BufferedPortImageRgb self) -> ImageRgb"""
        return _yarp.BufferedPortImageRgb_prepare(self)


    def unprepare(self):
        """unprepare(BufferedPortImageRgb self) -> bool"""
        return _yarp.BufferedPortImageRgb_unprepare(self)


    def write(self, forceStrict=False):
        """
        write(BufferedPortImageRgb self, bool forceStrict=False)
        write(BufferedPortImageRgb self)
        """
        return _yarp.BufferedPortImageRgb_write(self, forceStrict)


    def writeStrict(self):
        """writeStrict(BufferedPortImageRgb self)"""
        return _yarp.BufferedPortImageRgb_writeStrict(self)


    def waitForWrite(self):
        """waitForWrite(BufferedPortImageRgb self)"""
        return _yarp.BufferedPortImageRgb_waitForWrite(self)


    def setStrict(self, strict=True):
        """
        setStrict(BufferedPortImageRgb self, bool strict=True)
        setStrict(BufferedPortImageRgb self)
        """
        return _yarp.BufferedPortImageRgb_setStrict(self, strict)


    def read(self, shouldWait=True):
        """
        read(BufferedPortImageRgb self, bool shouldWait=True) -> ImageRgb
        read(BufferedPortImageRgb self) -> ImageRgb
        """
        return _yarp.BufferedPortImageRgb_read(self, shouldWait)


    def lastRead(self):
        """lastRead(BufferedPortImageRgb self) -> ImageRgb"""
        return _yarp.BufferedPortImageRgb_lastRead(self)


    def isClosed(self):
        """isClosed(BufferedPortImageRgb self) -> bool"""
        return _yarp.BufferedPortImageRgb_isClosed(self)


    def setReplier(self, reader):
        """setReplier(BufferedPortImageRgb self, PortReader reader)"""
        return _yarp.BufferedPortImageRgb_setReplier(self, reader)


    def setReader(self, reader):
        """setReader(BufferedPortImageRgb self, PortReader reader)"""
        return _yarp.BufferedPortImageRgb_setReader(self, reader)


    def setAdminReader(self, reader):
        """setAdminReader(BufferedPortImageRgb self, PortReader reader)"""
        return _yarp.BufferedPortImageRgb_setAdminReader(self, reader)


    def onRead(self, *args):
        """
        onRead(BufferedPortImageRgb self, ImageRgb datum, TypedReaderImageRgb reader)
        onRead(BufferedPortImageRgb self, ImageRgb datum)
        """
        return _yarp.BufferedPortImageRgb_onRead(self, *args)


    def useCallback(self, *args):
        """
        useCallback(BufferedPortImageRgb self, TypedReaderCallbackImageRgb callback)
        useCallback(BufferedPortImageRgb self)
        """
        return _yarp.BufferedPortImageRgb_useCallback(self, *args)


    def disableCallback(self):
        """disableCallback(BufferedPortImageRgb self)"""
        return _yarp.BufferedPortImageRgb_disableCallback(self)


    def setEnvelope(self, envelope):
        """setEnvelope(BufferedPortImageRgb self, PortWriter envelope) -> bool"""
        return _yarp.BufferedPortImageRgb_setEnvelope(self, envelope)


    def getEnvelope(self, envelope):
        """getEnvelope(BufferedPortImageRgb self, PortReader envelope) -> bool"""
        return _yarp.BufferedPortImageRgb_getEnvelope(self, envelope)


    def getInputCount(self):
        """getInputCount(BufferedPortImageRgb self) -> int"""
        return _yarp.BufferedPortImageRgb_getInputCount(self)


    def getOutputCount(self):
        """getOutputCount(BufferedPortImageRgb self) -> int"""
        return _yarp.BufferedPortImageRgb_getOutputCount(self)


    def isWriting(self):
        """isWriting(BufferedPortImageRgb self) -> bool"""
        return _yarp.BufferedPortImageRgb_isWriting(self)


    def getReport(self, reporter):
        """getReport(BufferedPortImageRgb self, PortReport reporter)"""
        return _yarp.BufferedPortImageRgb_getReport(self, reporter)


    def setReporter(self, reporter):
        """setReporter(BufferedPortImageRgb self, PortReport reporter)"""
        return _yarp.BufferedPortImageRgb_setReporter(self, reporter)


    def resetReporter(self):
        """resetReporter(BufferedPortImageRgb self)"""
        return _yarp.BufferedPortImageRgb_resetReporter(self)


    def acquire(self):
        """acquire(BufferedPortImageRgb self) -> void *"""
        return _yarp.BufferedPortImageRgb_acquire(self)


    def release(self, handle):
        """release(BufferedPortImageRgb self, void * handle)"""
        return _yarp.BufferedPortImageRgb_release(self, handle)


    def setTargetPeriod(self, period):
        """setTargetPeriod(BufferedPortImageRgb self, double period)"""
        return _yarp.BufferedPortImageRgb_setTargetPeriod(self, period)


    def getType(self):
        """getType(BufferedPortImageRgb self) -> Type"""
        return _yarp.BufferedPortImageRgb_getType(self)


    def promiseType(self, typ):
        """promiseType(BufferedPortImageRgb self, Type const & typ)"""
        return _yarp.BufferedPortImageRgb_promiseType(self, typ)


    def setInputMode(self, expectInput):
        """setInputMode(BufferedPortImageRgb self, bool expectInput)"""
        return _yarp.BufferedPortImageRgb_setInputMode(self, expectInput)


    def setOutputMode(self, expectOutput):
        """setOutputMode(BufferedPortImageRgb self, bool expectOutput)"""
        return _yarp.BufferedPortImageRgb_setOutputMode(self, expectOutput)


    def setRpcMode(self, expectRpc):
        """setRpcMode(BufferedPortImageRgb self, bool expectRpc)"""
        return _yarp.BufferedPortImageRgb_setRpcMode(self, expectRpc)


    def acquireProperties(self, readOnly):
        """acquireProperties(BufferedPortImageRgb self, bool readOnly) -> Property"""
        return _yarp.BufferedPortImageRgb_acquireProperties(self, readOnly)


    def releaseProperties(self, prop):
        """releaseProperties(BufferedPortImageRgb self, Property prop)"""
        return _yarp.BufferedPortImageRgb_releaseProperties(self, prop)


    def includeNodeInName(self, flag):
        """includeNodeInName(BufferedPortImageRgb self, bool flag)"""
        return _yarp.BufferedPortImageRgb_includeNodeInName(self, flag)


    def setCallbackLock(self, mutex):
        """setCallbackLock(BufferedPortImageRgb self, yarp::os::Mutex * mutex) -> bool"""
        return _yarp.BufferedPortImageRgb_setCallbackLock(self, mutex)


    def removeCallbackLock(self):
        """removeCallbackLock(BufferedPortImageRgb self) -> bool"""
        return _yarp.BufferedPortImageRgb_removeCallbackLock(self)


    def lockCallback(self):
        """lockCallback(BufferedPortImageRgb self) -> bool"""
        return _yarp.BufferedPortImageRgb_lockCallback(self)


    def tryLockCallback(self):
        """tryLockCallback(BufferedPortImageRgb self) -> bool"""
        return _yarp.BufferedPortImageRgb_tryLockCallback(self)


    def unlockCallback(self):
        """unlockCallback(BufferedPortImageRgb self)"""
        return _yarp.BufferedPortImageRgb_unlockCallback(self)

BufferedPortImageRgb_swigregister = _yarp.BufferedPortImageRgb_swigregister
BufferedPortImageRgb_swigregister(BufferedPortImageRgb)

class ImageRgba(Image):
    """Proxy of C++ yarp::sig::ImageOf<(yarp::sig::PixelRgba)> class."""

    __swig_setmethods__ = {}
    for _s in [Image]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ImageRgba, name, value)
    __swig_getmethods__ = {}
    for _s in [Image]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ImageRgba, name)
    __repr__ = _swig_repr

    def __init__(self):
        """__init__(yarp::sig::ImageOf<(yarp::sig::PixelRgba)> self) -> ImageRgba"""
        this = _yarp.new_ImageRgba()
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def getPixelSize(self):
        """getPixelSize(ImageRgba self) -> int"""
        return _yarp.ImageRgba_getPixelSize(self)


    def getPixelCode(self):
        """getPixelCode(ImageRgba self) -> int"""
        return _yarp.ImageRgba_getPixelCode(self)


    def pixel(self, x, y):
        """pixel(ImageRgba self, int x, int y) -> PixelRgba"""
        return _yarp.ImageRgba_pixel(self, x, y)


    def access(self, x, y):
        """access(ImageRgba self, int x, int y) -> PixelRgba"""
        return _yarp.ImageRgba_access(self, x, y)


    def safePixel(self, *args):
        """
        safePixel(ImageRgba self, int x, int y) -> PixelRgba
        safePixel(ImageRgba self, int x, int y) -> PixelRgba
        """
        return _yarp.ImageRgba_safePixel(self, *args)

    __swig_destroy__ = _yarp.delete_ImageRgba
    __del__ = lambda self: None
ImageRgba_swigregister = _yarp.ImageRgba_swigregister
ImageRgba_swigregister(ImageRgba)

class TypedReaderImageRgba(_object):
    """Proxy of C++ yarp::os::TypedReader<(yarp::sig::ImageOf<(yarp::sig::PixelRgba)>)> class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, TypedReaderImageRgba, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, TypedReaderImageRgba, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def setStrict(self, strict=True):
        """
        setStrict(TypedReaderImageRgba self, bool strict=True)
        setStrict(TypedReaderImageRgba self)
        """
        return _yarp.TypedReaderImageRgba_setStrict(self, strict)


    def read(self, shouldWait=True):
        """
        read(TypedReaderImageRgba self, bool shouldWait=True) -> ImageRgba
        read(TypedReaderImageRgba self) -> ImageRgba
        """
        return _yarp.TypedReaderImageRgba_read(self, shouldWait)


    def interrupt(self):
        """interrupt(TypedReaderImageRgba self)"""
        return _yarp.TypedReaderImageRgba_interrupt(self)


    def lastRead(self):
        """lastRead(TypedReaderImageRgba self) -> ImageRgba"""
        return _yarp.TypedReaderImageRgba_lastRead(self)


    def isClosed(self):
        """isClosed(TypedReaderImageRgba self) -> bool"""
        return _yarp.TypedReaderImageRgba_isClosed(self)


    def useCallback(self, callback):
        """useCallback(TypedReaderImageRgba self, TypedReaderCallbackImageRgba callback)"""
        return _yarp.TypedReaderImageRgba_useCallback(self, callback)


    def disableCallback(self):
        """disableCallback(TypedReaderImageRgba self)"""
        return _yarp.TypedReaderImageRgba_disableCallback(self)


    def getPendingReads(self):
        """getPendingReads(TypedReaderImageRgba self) -> int"""
        return _yarp.TypedReaderImageRgba_getPendingReads(self)

    __swig_destroy__ = _yarp.delete_TypedReaderImageRgba
    __del__ = lambda self: None

    def getName(self):
        """getName(TypedReaderImageRgba self) -> yarp::os::ConstString"""
        return _yarp.TypedReaderImageRgba_getName(self)


    def setReplier(self, reader):
        """setReplier(TypedReaderImageRgba self, PortReader reader)"""
        return _yarp.TypedReaderImageRgba_setReplier(self, reader)


    def acquire(self):
        """acquire(TypedReaderImageRgba self) -> void *"""
        return _yarp.TypedReaderImageRgba_acquire(self)


    def release(self, handle):
        """release(TypedReaderImageRgba self, void * handle)"""
        return _yarp.TypedReaderImageRgba_release(self, handle)


    def setTargetPeriod(self, period):
        """setTargetPeriod(TypedReaderImageRgba self, double period)"""
        return _yarp.TypedReaderImageRgba_setTargetPeriod(self, period)

TypedReaderImageRgba_swigregister = _yarp.TypedReaderImageRgba_swigregister
TypedReaderImageRgba_swigregister(TypedReaderImageRgba)

class TypedReaderCallbackImageRgba(_object):
    """Proxy of C++ yarp::os::TypedReaderCallback<(yarp::sig::ImageOf<(yarp::sig::PixelRgba)>)> class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, TypedReaderCallbackImageRgba, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, TypedReaderCallbackImageRgba, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_TypedReaderCallbackImageRgba
    __del__ = lambda self: None

    def onRead(self, *args):
        """
        onRead(TypedReaderCallbackImageRgba self, ImageRgba datum)
        onRead(TypedReaderCallbackImageRgba self, ImageRgba datum, TypedReaderImageRgba reader)
        """
        return _yarp.TypedReaderCallbackImageRgba_onRead(self, *args)


    def __init__(self):
        """__init__(yarp::os::TypedReaderCallback<(yarp::sig::ImageOf<(yarp::sig::PixelRgba)>)> self) -> TypedReaderCallbackImageRgba"""
        this = _yarp.new_TypedReaderCallbackImageRgba()
        try:
            self.this.append(this)
        except Exception:
            self.this = this
TypedReaderCallbackImageRgba_swigregister = _yarp.TypedReaderCallbackImageRgba_swigregister
TypedReaderCallbackImageRgba_swigregister(TypedReaderCallbackImageRgba)

class BufferedPortImageRgba(Contactable, TypedReaderImageRgba, TypedReaderCallbackImageRgba):
    """Proxy of C++ yarp::os::BufferedPort<(yarp::sig::ImageOf<(yarp::sig::PixelRgba)>)> class."""

    __swig_setmethods__ = {}
    for _s in [Contactable, TypedReaderImageRgba, TypedReaderCallbackImageRgba]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, BufferedPortImageRgba, name, value)
    __swig_getmethods__ = {}
    for _s in [Contactable, TypedReaderImageRgba, TypedReaderCallbackImageRgba]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, BufferedPortImageRgba, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(yarp::os::BufferedPort<(yarp::sig::ImageOf<(yarp::sig::PixelRgba)>)> self) -> BufferedPortImageRgba
        __init__(yarp::os::BufferedPort<(yarp::sig::ImageOf<(yarp::sig::PixelRgba)>)> self, Port port) -> BufferedPortImageRgba
        """
        this = _yarp.new_BufferedPortImageRgba(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _yarp.delete_BufferedPortImageRgba
    __del__ = lambda self: None

    def addOutput(self, *args):
        """
        addOutput(BufferedPortImageRgba self, yarp::os::ConstString const & name) -> bool
        addOutput(BufferedPortImageRgba self, yarp::os::ConstString const & name, yarp::os::ConstString const & carrier) -> bool
        addOutput(BufferedPortImageRgba self, Contact contact) -> bool
        """
        return _yarp.BufferedPortImageRgba_addOutput(self, *args)


    def close(self):
        """close(BufferedPortImageRgba self)"""
        return _yarp.BufferedPortImageRgba_close(self)


    def interrupt(self):
        """interrupt(BufferedPortImageRgba self)"""
        return _yarp.BufferedPortImageRgba_interrupt(self)


    def resume(self):
        """resume(BufferedPortImageRgba self)"""
        return _yarp.BufferedPortImageRgba_resume(self)


    def getPendingReads(self):
        """getPendingReads(BufferedPortImageRgba self) -> int"""
        return _yarp.BufferedPortImageRgba_getPendingReads(self)


    def where(self):
        """where(BufferedPortImageRgba self) -> Contact"""
        return _yarp.BufferedPortImageRgba_where(self)


    def getName(self):
        """getName(BufferedPortImageRgba self) -> yarp::os::ConstString"""
        return _yarp.BufferedPortImageRgba_getName(self)


    def prepare(self):
        """prepare(BufferedPortImageRgba self) -> ImageRgba"""
        return _yarp.BufferedPortImageRgba_prepare(self)


    def unprepare(self):
        """unprepare(BufferedPortImageRgba self) -> bool"""
        return _yarp.BufferedPortImageRgba_unprepare(self)


    def write(self, forceStrict=False):
        """
        write(BufferedPortImageRgba self, bool forceStrict=False)
        write(BufferedPortImageRgba self)
        """
        return _yarp.BufferedPortImageRgba_write(self, forceStrict)


    def writeStrict(self):
        """writeStrict(BufferedPortImageRgba self)"""
        return _yarp.BufferedPortImageRgba_writeStrict(self)


    def waitForWrite(self):
        """waitForWrite(BufferedPortImageRgba self)"""
        return _yarp.BufferedPortImageRgba_waitForWrite(self)


    def setStrict(self, strict=True):
        """
        setStrict(BufferedPortImageRgba self, bool strict=True)
        setStrict(BufferedPortImageRgba self)
        """
        return _yarp.BufferedPortImageRgba_setStrict(self, strict)


    def read(self, shouldWait=True):
        """
        read(BufferedPortImageRgba self, bool shouldWait=True) -> ImageRgba
        read(BufferedPortImageRgba self) -> ImageRgba
        """
        return _yarp.BufferedPortImageRgba_read(self, shouldWait)


    def lastRead(self):
        """lastRead(BufferedPortImageRgba self) -> ImageRgba"""
        return _yarp.BufferedPortImageRgba_lastRead(self)


    def isClosed(self):
        """isClosed(BufferedPortImageRgba self) -> bool"""
        return _yarp.BufferedPortImageRgba_isClosed(self)


    def setReplier(self, reader):
        """setReplier(BufferedPortImageRgba self, PortReader reader)"""
        return _yarp.BufferedPortImageRgba_setReplier(self, reader)


    def setReader(self, reader):
        """setReader(BufferedPortImageRgba self, PortReader reader)"""
        return _yarp.BufferedPortImageRgba_setReader(self, reader)


    def setAdminReader(self, reader):
        """setAdminReader(BufferedPortImageRgba self, PortReader reader)"""
        return _yarp.BufferedPortImageRgba_setAdminReader(self, reader)


    def onRead(self, *args):
        """
        onRead(BufferedPortImageRgba self, ImageRgba datum, TypedReaderImageRgba reader)
        onRead(BufferedPortImageRgba self, ImageRgba datum)
        """
        return _yarp.BufferedPortImageRgba_onRead(self, *args)


    def useCallback(self, *args):
        """
        useCallback(BufferedPortImageRgba self, TypedReaderCallbackImageRgba callback)
        useCallback(BufferedPortImageRgba self)
        """
        return _yarp.BufferedPortImageRgba_useCallback(self, *args)


    def disableCallback(self):
        """disableCallback(BufferedPortImageRgba self)"""
        return _yarp.BufferedPortImageRgba_disableCallback(self)


    def setEnvelope(self, envelope):
        """setEnvelope(BufferedPortImageRgba self, PortWriter envelope) -> bool"""
        return _yarp.BufferedPortImageRgba_setEnvelope(self, envelope)


    def getEnvelope(self, envelope):
        """getEnvelope(BufferedPortImageRgba self, PortReader envelope) -> bool"""
        return _yarp.BufferedPortImageRgba_getEnvelope(self, envelope)


    def getInputCount(self):
        """getInputCount(BufferedPortImageRgba self) -> int"""
        return _yarp.BufferedPortImageRgba_getInputCount(self)


    def getOutputCount(self):
        """getOutputCount(BufferedPortImageRgba self) -> int"""
        return _yarp.BufferedPortImageRgba_getOutputCount(self)


    def isWriting(self):
        """isWriting(BufferedPortImageRgba self) -> bool"""
        return _yarp.BufferedPortImageRgba_isWriting(self)


    def getReport(self, reporter):
        """getReport(BufferedPortImageRgba self, PortReport reporter)"""
        return _yarp.BufferedPortImageRgba_getReport(self, reporter)


    def setReporter(self, reporter):
        """setReporter(BufferedPortImageRgba self, PortReport reporter)"""
        return _yarp.BufferedPortImageRgba_setReporter(self, reporter)


    def resetReporter(self):
        """resetReporter(BufferedPortImageRgba self)"""
        return _yarp.BufferedPortImageRgba_resetReporter(self)


    def acquire(self):
        """acquire(BufferedPortImageRgba self) -> void *"""
        return _yarp.BufferedPortImageRgba_acquire(self)


    def release(self, handle):
        """release(BufferedPortImageRgba self, void * handle)"""
        return _yarp.BufferedPortImageRgba_release(self, handle)


    def setTargetPeriod(self, period):
        """setTargetPeriod(BufferedPortImageRgba self, double period)"""
        return _yarp.BufferedPortImageRgba_setTargetPeriod(self, period)


    def getType(self):
        """getType(BufferedPortImageRgba self) -> Type"""
        return _yarp.BufferedPortImageRgba_getType(self)


    def promiseType(self, typ):
        """promiseType(BufferedPortImageRgba self, Type const & typ)"""
        return _yarp.BufferedPortImageRgba_promiseType(self, typ)


    def setInputMode(self, expectInput):
        """setInputMode(BufferedPortImageRgba self, bool expectInput)"""
        return _yarp.BufferedPortImageRgba_setInputMode(self, expectInput)


    def setOutputMode(self, expectOutput):
        """setOutputMode(BufferedPortImageRgba self, bool expectOutput)"""
        return _yarp.BufferedPortImageRgba_setOutputMode(self, expectOutput)


    def setRpcMode(self, expectRpc):
        """setRpcMode(BufferedPortImageRgba self, bool expectRpc)"""
        return _yarp.BufferedPortImageRgba_setRpcMode(self, expectRpc)


    def acquireProperties(self, readOnly):
        """acquireProperties(BufferedPortImageRgba self, bool readOnly) -> Property"""
        return _yarp.BufferedPortImageRgba_acquireProperties(self, readOnly)


    def releaseProperties(self, prop):
        """releaseProperties(BufferedPortImageRgba self, Property prop)"""
        return _yarp.BufferedPortImageRgba_releaseProperties(self, prop)


    def includeNodeInName(self, flag):
        """includeNodeInName(BufferedPortImageRgba self, bool flag)"""
        return _yarp.BufferedPortImageRgba_includeNodeInName(self, flag)


    def setCallbackLock(self, mutex):
        """setCallbackLock(BufferedPortImageRgba self, yarp::os::Mutex * mutex) -> bool"""
        return _yarp.BufferedPortImageRgba_setCallbackLock(self, mutex)


    def removeCallbackLock(self):
        """removeCallbackLock(BufferedPortImageRgba self) -> bool"""
        return _yarp.BufferedPortImageRgba_removeCallbackLock(self)


    def lockCallback(self):
        """lockCallback(BufferedPortImageRgba self) -> bool"""
        return _yarp.BufferedPortImageRgba_lockCallback(self)


    def tryLockCallback(self):
        """tryLockCallback(BufferedPortImageRgba self) -> bool"""
        return _yarp.BufferedPortImageRgba_tryLockCallback(self)


    def unlockCallback(self):
        """unlockCallback(BufferedPortImageRgba self)"""
        return _yarp.BufferedPortImageRgba_unlockCallback(self)

BufferedPortImageRgba_swigregister = _yarp.BufferedPortImageRgba_swigregister
BufferedPortImageRgba_swigregister(BufferedPortImageRgba)

class ImageMono(Image):
    """Proxy of C++ yarp::sig::ImageOf<(yarp::sig::PixelMono)> class."""

    __swig_setmethods__ = {}
    for _s in [Image]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ImageMono, name, value)
    __swig_getmethods__ = {}
    for _s in [Image]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ImageMono, name)
    __repr__ = _swig_repr

    def __init__(self):
        """__init__(yarp::sig::ImageOf<(yarp::sig::PixelMono)> self) -> ImageMono"""
        this = _yarp.new_ImageMono()
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def getPixelSize(self):
        """getPixelSize(ImageMono self) -> int"""
        return _yarp.ImageMono_getPixelSize(self)


    def getPixelCode(self):
        """getPixelCode(ImageMono self) -> int"""
        return _yarp.ImageMono_getPixelCode(self)


    def pixel(self, x, y):
        """pixel(ImageMono self, int x, int y) -> unsigned char &"""
        return _yarp.ImageMono_pixel(self, x, y)


    def access(self, x, y):
        """access(ImageMono self, int x, int y) -> unsigned char &"""
        return _yarp.ImageMono_access(self, x, y)


    def safePixel(self, *args):
        """
        safePixel(ImageMono self, int x, int y) -> unsigned char
        safePixel(ImageMono self, int x, int y) -> unsigned char const &
        """
        return _yarp.ImageMono_safePixel(self, *args)

    __swig_destroy__ = _yarp.delete_ImageMono
    __del__ = lambda self: None
ImageMono_swigregister = _yarp.ImageMono_swigregister
ImageMono_swigregister(ImageMono)

class TypedReaderImageMono(_object):
    """Proxy of C++ yarp::os::TypedReader<(yarp::sig::ImageOf<(yarp::sig::PixelMono)>)> class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, TypedReaderImageMono, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, TypedReaderImageMono, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def setStrict(self, strict=True):
        """
        setStrict(TypedReaderImageMono self, bool strict=True)
        setStrict(TypedReaderImageMono self)
        """
        return _yarp.TypedReaderImageMono_setStrict(self, strict)


    def read(self, shouldWait=True):
        """
        read(TypedReaderImageMono self, bool shouldWait=True) -> ImageMono
        read(TypedReaderImageMono self) -> ImageMono
        """
        return _yarp.TypedReaderImageMono_read(self, shouldWait)


    def interrupt(self):
        """interrupt(TypedReaderImageMono self)"""
        return _yarp.TypedReaderImageMono_interrupt(self)


    def lastRead(self):
        """lastRead(TypedReaderImageMono self) -> ImageMono"""
        return _yarp.TypedReaderImageMono_lastRead(self)


    def isClosed(self):
        """isClosed(TypedReaderImageMono self) -> bool"""
        return _yarp.TypedReaderImageMono_isClosed(self)


    def useCallback(self, callback):
        """useCallback(TypedReaderImageMono self, TypedReaderCallbackImageMono callback)"""
        return _yarp.TypedReaderImageMono_useCallback(self, callback)


    def disableCallback(self):
        """disableCallback(TypedReaderImageMono self)"""
        return _yarp.TypedReaderImageMono_disableCallback(self)


    def getPendingReads(self):
        """getPendingReads(TypedReaderImageMono self) -> int"""
        return _yarp.TypedReaderImageMono_getPendingReads(self)

    __swig_destroy__ = _yarp.delete_TypedReaderImageMono
    __del__ = lambda self: None

    def getName(self):
        """getName(TypedReaderImageMono self) -> yarp::os::ConstString"""
        return _yarp.TypedReaderImageMono_getName(self)


    def setReplier(self, reader):
        """setReplier(TypedReaderImageMono self, PortReader reader)"""
        return _yarp.TypedReaderImageMono_setReplier(self, reader)


    def acquire(self):
        """acquire(TypedReaderImageMono self) -> void *"""
        return _yarp.TypedReaderImageMono_acquire(self)


    def release(self, handle):
        """release(TypedReaderImageMono self, void * handle)"""
        return _yarp.TypedReaderImageMono_release(self, handle)


    def setTargetPeriod(self, period):
        """setTargetPeriod(TypedReaderImageMono self, double period)"""
        return _yarp.TypedReaderImageMono_setTargetPeriod(self, period)

TypedReaderImageMono_swigregister = _yarp.TypedReaderImageMono_swigregister
TypedReaderImageMono_swigregister(TypedReaderImageMono)

class TypedReaderCallbackImageMono(_object):
    """Proxy of C++ yarp::os::TypedReaderCallback<(yarp::sig::ImageOf<(yarp::sig::PixelMono)>)> class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, TypedReaderCallbackImageMono, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, TypedReaderCallbackImageMono, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_TypedReaderCallbackImageMono
    __del__ = lambda self: None

    def onRead(self, *args):
        """
        onRead(TypedReaderCallbackImageMono self, ImageMono datum)
        onRead(TypedReaderCallbackImageMono self, ImageMono datum, TypedReaderImageMono reader)
        """
        return _yarp.TypedReaderCallbackImageMono_onRead(self, *args)


    def __init__(self):
        """__init__(yarp::os::TypedReaderCallback<(yarp::sig::ImageOf<(yarp::sig::PixelMono)>)> self) -> TypedReaderCallbackImageMono"""
        this = _yarp.new_TypedReaderCallbackImageMono()
        try:
            self.this.append(this)
        except Exception:
            self.this = this
TypedReaderCallbackImageMono_swigregister = _yarp.TypedReaderCallbackImageMono_swigregister
TypedReaderCallbackImageMono_swigregister(TypedReaderCallbackImageMono)

class BufferedPortImageMono(Contactable, TypedReaderImageMono, TypedReaderCallbackImageMono):
    """Proxy of C++ yarp::os::BufferedPort<(yarp::sig::ImageOf<(yarp::sig::PixelMono)>)> class."""

    __swig_setmethods__ = {}
    for _s in [Contactable, TypedReaderImageMono, TypedReaderCallbackImageMono]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, BufferedPortImageMono, name, value)
    __swig_getmethods__ = {}
    for _s in [Contactable, TypedReaderImageMono, TypedReaderCallbackImageMono]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, BufferedPortImageMono, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(yarp::os::BufferedPort<(yarp::sig::ImageOf<(yarp::sig::PixelMono)>)> self) -> BufferedPortImageMono
        __init__(yarp::os::BufferedPort<(yarp::sig::ImageOf<(yarp::sig::PixelMono)>)> self, Port port) -> BufferedPortImageMono
        """
        this = _yarp.new_BufferedPortImageMono(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _yarp.delete_BufferedPortImageMono
    __del__ = lambda self: None

    def addOutput(self, *args):
        """
        addOutput(BufferedPortImageMono self, yarp::os::ConstString const & name) -> bool
        addOutput(BufferedPortImageMono self, yarp::os::ConstString const & name, yarp::os::ConstString const & carrier) -> bool
        addOutput(BufferedPortImageMono self, Contact contact) -> bool
        """
        return _yarp.BufferedPortImageMono_addOutput(self, *args)


    def close(self):
        """close(BufferedPortImageMono self)"""
        return _yarp.BufferedPortImageMono_close(self)


    def interrupt(self):
        """interrupt(BufferedPortImageMono self)"""
        return _yarp.BufferedPortImageMono_interrupt(self)


    def resume(self):
        """resume(BufferedPortImageMono self)"""
        return _yarp.BufferedPortImageMono_resume(self)


    def getPendingReads(self):
        """getPendingReads(BufferedPortImageMono self) -> int"""
        return _yarp.BufferedPortImageMono_getPendingReads(self)


    def where(self):
        """where(BufferedPortImageMono self) -> Contact"""
        return _yarp.BufferedPortImageMono_where(self)


    def getName(self):
        """getName(BufferedPortImageMono self) -> yarp::os::ConstString"""
        return _yarp.BufferedPortImageMono_getName(self)


    def prepare(self):
        """prepare(BufferedPortImageMono self) -> ImageMono"""
        return _yarp.BufferedPortImageMono_prepare(self)


    def unprepare(self):
        """unprepare(BufferedPortImageMono self) -> bool"""
        return _yarp.BufferedPortImageMono_unprepare(self)


    def write(self, forceStrict=False):
        """
        write(BufferedPortImageMono self, bool forceStrict=False)
        write(BufferedPortImageMono self)
        """
        return _yarp.BufferedPortImageMono_write(self, forceStrict)


    def writeStrict(self):
        """writeStrict(BufferedPortImageMono self)"""
        return _yarp.BufferedPortImageMono_writeStrict(self)


    def waitForWrite(self):
        """waitForWrite(BufferedPortImageMono self)"""
        return _yarp.BufferedPortImageMono_waitForWrite(self)


    def setStrict(self, strict=True):
        """
        setStrict(BufferedPortImageMono self, bool strict=True)
        setStrict(BufferedPortImageMono self)
        """
        return _yarp.BufferedPortImageMono_setStrict(self, strict)


    def read(self, shouldWait=True):
        """
        read(BufferedPortImageMono self, bool shouldWait=True) -> ImageMono
        read(BufferedPortImageMono self) -> ImageMono
        """
        return _yarp.BufferedPortImageMono_read(self, shouldWait)


    def lastRead(self):
        """lastRead(BufferedPortImageMono self) -> ImageMono"""
        return _yarp.BufferedPortImageMono_lastRead(self)


    def isClosed(self):
        """isClosed(BufferedPortImageMono self) -> bool"""
        return _yarp.BufferedPortImageMono_isClosed(self)


    def setReplier(self, reader):
        """setReplier(BufferedPortImageMono self, PortReader reader)"""
        return _yarp.BufferedPortImageMono_setReplier(self, reader)


    def setReader(self, reader):
        """setReader(BufferedPortImageMono self, PortReader reader)"""
        return _yarp.BufferedPortImageMono_setReader(self, reader)


    def setAdminReader(self, reader):
        """setAdminReader(BufferedPortImageMono self, PortReader reader)"""
        return _yarp.BufferedPortImageMono_setAdminReader(self, reader)


    def onRead(self, *args):
        """
        onRead(BufferedPortImageMono self, ImageMono datum, TypedReaderImageMono reader)
        onRead(BufferedPortImageMono self, ImageMono datum)
        """
        return _yarp.BufferedPortImageMono_onRead(self, *args)


    def useCallback(self, *args):
        """
        useCallback(BufferedPortImageMono self, TypedReaderCallbackImageMono callback)
        useCallback(BufferedPortImageMono self)
        """
        return _yarp.BufferedPortImageMono_useCallback(self, *args)


    def disableCallback(self):
        """disableCallback(BufferedPortImageMono self)"""
        return _yarp.BufferedPortImageMono_disableCallback(self)


    def setEnvelope(self, envelope):
        """setEnvelope(BufferedPortImageMono self, PortWriter envelope) -> bool"""
        return _yarp.BufferedPortImageMono_setEnvelope(self, envelope)


    def getEnvelope(self, envelope):
        """getEnvelope(BufferedPortImageMono self, PortReader envelope) -> bool"""
        return _yarp.BufferedPortImageMono_getEnvelope(self, envelope)


    def getInputCount(self):
        """getInputCount(BufferedPortImageMono self) -> int"""
        return _yarp.BufferedPortImageMono_getInputCount(self)


    def getOutputCount(self):
        """getOutputCount(BufferedPortImageMono self) -> int"""
        return _yarp.BufferedPortImageMono_getOutputCount(self)


    def isWriting(self):
        """isWriting(BufferedPortImageMono self) -> bool"""
        return _yarp.BufferedPortImageMono_isWriting(self)


    def getReport(self, reporter):
        """getReport(BufferedPortImageMono self, PortReport reporter)"""
        return _yarp.BufferedPortImageMono_getReport(self, reporter)


    def setReporter(self, reporter):
        """setReporter(BufferedPortImageMono self, PortReport reporter)"""
        return _yarp.BufferedPortImageMono_setReporter(self, reporter)


    def resetReporter(self):
        """resetReporter(BufferedPortImageMono self)"""
        return _yarp.BufferedPortImageMono_resetReporter(self)


    def acquire(self):
        """acquire(BufferedPortImageMono self) -> void *"""
        return _yarp.BufferedPortImageMono_acquire(self)


    def release(self, handle):
        """release(BufferedPortImageMono self, void * handle)"""
        return _yarp.BufferedPortImageMono_release(self, handle)


    def setTargetPeriod(self, period):
        """setTargetPeriod(BufferedPortImageMono self, double period)"""
        return _yarp.BufferedPortImageMono_setTargetPeriod(self, period)


    def getType(self):
        """getType(BufferedPortImageMono self) -> Type"""
        return _yarp.BufferedPortImageMono_getType(self)


    def promiseType(self, typ):
        """promiseType(BufferedPortImageMono self, Type const & typ)"""
        return _yarp.BufferedPortImageMono_promiseType(self, typ)


    def setInputMode(self, expectInput):
        """setInputMode(BufferedPortImageMono self, bool expectInput)"""
        return _yarp.BufferedPortImageMono_setInputMode(self, expectInput)


    def setOutputMode(self, expectOutput):
        """setOutputMode(BufferedPortImageMono self, bool expectOutput)"""
        return _yarp.BufferedPortImageMono_setOutputMode(self, expectOutput)


    def setRpcMode(self, expectRpc):
        """setRpcMode(BufferedPortImageMono self, bool expectRpc)"""
        return _yarp.BufferedPortImageMono_setRpcMode(self, expectRpc)


    def acquireProperties(self, readOnly):
        """acquireProperties(BufferedPortImageMono self, bool readOnly) -> Property"""
        return _yarp.BufferedPortImageMono_acquireProperties(self, readOnly)


    def releaseProperties(self, prop):
        """releaseProperties(BufferedPortImageMono self, Property prop)"""
        return _yarp.BufferedPortImageMono_releaseProperties(self, prop)


    def includeNodeInName(self, flag):
        """includeNodeInName(BufferedPortImageMono self, bool flag)"""
        return _yarp.BufferedPortImageMono_includeNodeInName(self, flag)


    def setCallbackLock(self, mutex):
        """setCallbackLock(BufferedPortImageMono self, yarp::os::Mutex * mutex) -> bool"""
        return _yarp.BufferedPortImageMono_setCallbackLock(self, mutex)


    def removeCallbackLock(self):
        """removeCallbackLock(BufferedPortImageMono self) -> bool"""
        return _yarp.BufferedPortImageMono_removeCallbackLock(self)


    def lockCallback(self):
        """lockCallback(BufferedPortImageMono self) -> bool"""
        return _yarp.BufferedPortImageMono_lockCallback(self)


    def tryLockCallback(self):
        """tryLockCallback(BufferedPortImageMono self) -> bool"""
        return _yarp.BufferedPortImageMono_tryLockCallback(self)


    def unlockCallback(self):
        """unlockCallback(BufferedPortImageMono self)"""
        return _yarp.BufferedPortImageMono_unlockCallback(self)

BufferedPortImageMono_swigregister = _yarp.BufferedPortImageMono_swigregister
BufferedPortImageMono_swigregister(BufferedPortImageMono)

class ImageMono16(Image):
    """Proxy of C++ yarp::sig::ImageOf<(yarp::sig::PixelMono16)> class."""

    __swig_setmethods__ = {}
    for _s in [Image]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ImageMono16, name, value)
    __swig_getmethods__ = {}
    for _s in [Image]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ImageMono16, name)
    __repr__ = _swig_repr

    def __init__(self):
        """__init__(yarp::sig::ImageOf<(yarp::sig::PixelMono16)> self) -> ImageMono16"""
        this = _yarp.new_ImageMono16()
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def getPixelSize(self):
        """getPixelSize(ImageMono16 self) -> int"""
        return _yarp.ImageMono16_getPixelSize(self)


    def getPixelCode(self):
        """getPixelCode(ImageMono16 self) -> int"""
        return _yarp.ImageMono16_getPixelCode(self)


    def pixel(self, x, y):
        """pixel(ImageMono16 self, int x, int y) -> yarp::os::NetUint16 &"""
        return _yarp.ImageMono16_pixel(self, x, y)


    def access(self, x, y):
        """access(ImageMono16 self, int x, int y) -> yarp::os::NetUint16 &"""
        return _yarp.ImageMono16_access(self, x, y)


    def safePixel(self, *args):
        """
        safePixel(ImageMono16 self, int x, int y) -> yarp::os::NetUint16
        safePixel(ImageMono16 self, int x, int y) -> yarp::os::NetUint16 const &
        """
        return _yarp.ImageMono16_safePixel(self, *args)

    __swig_destroy__ = _yarp.delete_ImageMono16
    __del__ = lambda self: None
ImageMono16_swigregister = _yarp.ImageMono16_swigregister
ImageMono16_swigregister(ImageMono16)

class TypedReaderImageMono16(_object):
    """Proxy of C++ yarp::os::TypedReader<(yarp::sig::ImageOf<(yarp::sig::PixelMono16)>)> class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, TypedReaderImageMono16, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, TypedReaderImageMono16, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def setStrict(self, strict=True):
        """
        setStrict(TypedReaderImageMono16 self, bool strict=True)
        setStrict(TypedReaderImageMono16 self)
        """
        return _yarp.TypedReaderImageMono16_setStrict(self, strict)


    def read(self, shouldWait=True):
        """
        read(TypedReaderImageMono16 self, bool shouldWait=True) -> ImageMono16
        read(TypedReaderImageMono16 self) -> ImageMono16
        """
        return _yarp.TypedReaderImageMono16_read(self, shouldWait)


    def interrupt(self):
        """interrupt(TypedReaderImageMono16 self)"""
        return _yarp.TypedReaderImageMono16_interrupt(self)


    def lastRead(self):
        """lastRead(TypedReaderImageMono16 self) -> ImageMono16"""
        return _yarp.TypedReaderImageMono16_lastRead(self)


    def isClosed(self):
        """isClosed(TypedReaderImageMono16 self) -> bool"""
        return _yarp.TypedReaderImageMono16_isClosed(self)


    def useCallback(self, callback):
        """useCallback(TypedReaderImageMono16 self, TypedReaderCallbackImageMono16 callback)"""
        return _yarp.TypedReaderImageMono16_useCallback(self, callback)


    def disableCallback(self):
        """disableCallback(TypedReaderImageMono16 self)"""
        return _yarp.TypedReaderImageMono16_disableCallback(self)


    def getPendingReads(self):
        """getPendingReads(TypedReaderImageMono16 self) -> int"""
        return _yarp.TypedReaderImageMono16_getPendingReads(self)

    __swig_destroy__ = _yarp.delete_TypedReaderImageMono16
    __del__ = lambda self: None

    def getName(self):
        """getName(TypedReaderImageMono16 self) -> yarp::os::ConstString"""
        return _yarp.TypedReaderImageMono16_getName(self)


    def setReplier(self, reader):
        """setReplier(TypedReaderImageMono16 self, PortReader reader)"""
        return _yarp.TypedReaderImageMono16_setReplier(self, reader)


    def acquire(self):
        """acquire(TypedReaderImageMono16 self) -> void *"""
        return _yarp.TypedReaderImageMono16_acquire(self)


    def release(self, handle):
        """release(TypedReaderImageMono16 self, void * handle)"""
        return _yarp.TypedReaderImageMono16_release(self, handle)


    def setTargetPeriod(self, period):
        """setTargetPeriod(TypedReaderImageMono16 self, double period)"""
        return _yarp.TypedReaderImageMono16_setTargetPeriod(self, period)

TypedReaderImageMono16_swigregister = _yarp.TypedReaderImageMono16_swigregister
TypedReaderImageMono16_swigregister(TypedReaderImageMono16)

class TypedReaderCallbackImageMono16(_object):
    """Proxy of C++ yarp::os::TypedReaderCallback<(yarp::sig::ImageOf<(yarp::sig::PixelMono16)>)> class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, TypedReaderCallbackImageMono16, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, TypedReaderCallbackImageMono16, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_TypedReaderCallbackImageMono16
    __del__ = lambda self: None

    def onRead(self, *args):
        """
        onRead(TypedReaderCallbackImageMono16 self, ImageMono16 datum)
        onRead(TypedReaderCallbackImageMono16 self, ImageMono16 datum, TypedReaderImageMono16 reader)
        """
        return _yarp.TypedReaderCallbackImageMono16_onRead(self, *args)


    def __init__(self):
        """__init__(yarp::os::TypedReaderCallback<(yarp::sig::ImageOf<(yarp::sig::PixelMono16)>)> self) -> TypedReaderCallbackImageMono16"""
        this = _yarp.new_TypedReaderCallbackImageMono16()
        try:
            self.this.append(this)
        except Exception:
            self.this = this
TypedReaderCallbackImageMono16_swigregister = _yarp.TypedReaderCallbackImageMono16_swigregister
TypedReaderCallbackImageMono16_swigregister(TypedReaderCallbackImageMono16)

class BufferedPortImageMono16(Contactable, TypedReaderImageMono16, TypedReaderCallbackImageMono16):
    """Proxy of C++ yarp::os::BufferedPort<(yarp::sig::ImageOf<(yarp::sig::PixelMono16)>)> class."""

    __swig_setmethods__ = {}
    for _s in [Contactable, TypedReaderImageMono16, TypedReaderCallbackImageMono16]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, BufferedPortImageMono16, name, value)
    __swig_getmethods__ = {}
    for _s in [Contactable, TypedReaderImageMono16, TypedReaderCallbackImageMono16]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, BufferedPortImageMono16, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(yarp::os::BufferedPort<(yarp::sig::ImageOf<(yarp::sig::PixelMono16)>)> self) -> BufferedPortImageMono16
        __init__(yarp::os::BufferedPort<(yarp::sig::ImageOf<(yarp::sig::PixelMono16)>)> self, Port port) -> BufferedPortImageMono16
        """
        this = _yarp.new_BufferedPortImageMono16(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _yarp.delete_BufferedPortImageMono16
    __del__ = lambda self: None

    def addOutput(self, *args):
        """
        addOutput(BufferedPortImageMono16 self, yarp::os::ConstString const & name) -> bool
        addOutput(BufferedPortImageMono16 self, yarp::os::ConstString const & name, yarp::os::ConstString const & carrier) -> bool
        addOutput(BufferedPortImageMono16 self, Contact contact) -> bool
        """
        return _yarp.BufferedPortImageMono16_addOutput(self, *args)


    def close(self):
        """close(BufferedPortImageMono16 self)"""
        return _yarp.BufferedPortImageMono16_close(self)


    def interrupt(self):
        """interrupt(BufferedPortImageMono16 self)"""
        return _yarp.BufferedPortImageMono16_interrupt(self)


    def resume(self):
        """resume(BufferedPortImageMono16 self)"""
        return _yarp.BufferedPortImageMono16_resume(self)


    def getPendingReads(self):
        """getPendingReads(BufferedPortImageMono16 self) -> int"""
        return _yarp.BufferedPortImageMono16_getPendingReads(self)


    def where(self):
        """where(BufferedPortImageMono16 self) -> Contact"""
        return _yarp.BufferedPortImageMono16_where(self)


    def getName(self):
        """getName(BufferedPortImageMono16 self) -> yarp::os::ConstString"""
        return _yarp.BufferedPortImageMono16_getName(self)


    def prepare(self):
        """prepare(BufferedPortImageMono16 self) -> ImageMono16"""
        return _yarp.BufferedPortImageMono16_prepare(self)


    def unprepare(self):
        """unprepare(BufferedPortImageMono16 self) -> bool"""
        return _yarp.BufferedPortImageMono16_unprepare(self)


    def write(self, forceStrict=False):
        """
        write(BufferedPortImageMono16 self, bool forceStrict=False)
        write(BufferedPortImageMono16 self)
        """
        return _yarp.BufferedPortImageMono16_write(self, forceStrict)


    def writeStrict(self):
        """writeStrict(BufferedPortImageMono16 self)"""
        return _yarp.BufferedPortImageMono16_writeStrict(self)


    def waitForWrite(self):
        """waitForWrite(BufferedPortImageMono16 self)"""
        return _yarp.BufferedPortImageMono16_waitForWrite(self)


    def setStrict(self, strict=True):
        """
        setStrict(BufferedPortImageMono16 self, bool strict=True)
        setStrict(BufferedPortImageMono16 self)
        """
        return _yarp.BufferedPortImageMono16_setStrict(self, strict)


    def read(self, shouldWait=True):
        """
        read(BufferedPortImageMono16 self, bool shouldWait=True) -> ImageMono16
        read(BufferedPortImageMono16 self) -> ImageMono16
        """
        return _yarp.BufferedPortImageMono16_read(self, shouldWait)


    def lastRead(self):
        """lastRead(BufferedPortImageMono16 self) -> ImageMono16"""
        return _yarp.BufferedPortImageMono16_lastRead(self)


    def isClosed(self):
        """isClosed(BufferedPortImageMono16 self) -> bool"""
        return _yarp.BufferedPortImageMono16_isClosed(self)


    def setReplier(self, reader):
        """setReplier(BufferedPortImageMono16 self, PortReader reader)"""
        return _yarp.BufferedPortImageMono16_setReplier(self, reader)


    def setReader(self, reader):
        """setReader(BufferedPortImageMono16 self, PortReader reader)"""
        return _yarp.BufferedPortImageMono16_setReader(self, reader)


    def setAdminReader(self, reader):
        """setAdminReader(BufferedPortImageMono16 self, PortReader reader)"""
        return _yarp.BufferedPortImageMono16_setAdminReader(self, reader)


    def onRead(self, *args):
        """
        onRead(BufferedPortImageMono16 self, ImageMono16 datum, TypedReaderImageMono16 reader)
        onRead(BufferedPortImageMono16 self, ImageMono16 datum)
        """
        return _yarp.BufferedPortImageMono16_onRead(self, *args)


    def useCallback(self, *args):
        """
        useCallback(BufferedPortImageMono16 self, TypedReaderCallbackImageMono16 callback)
        useCallback(BufferedPortImageMono16 self)
        """
        return _yarp.BufferedPortImageMono16_useCallback(self, *args)


    def disableCallback(self):
        """disableCallback(BufferedPortImageMono16 self)"""
        return _yarp.BufferedPortImageMono16_disableCallback(self)


    def setEnvelope(self, envelope):
        """setEnvelope(BufferedPortImageMono16 self, PortWriter envelope) -> bool"""
        return _yarp.BufferedPortImageMono16_setEnvelope(self, envelope)


    def getEnvelope(self, envelope):
        """getEnvelope(BufferedPortImageMono16 self, PortReader envelope) -> bool"""
        return _yarp.BufferedPortImageMono16_getEnvelope(self, envelope)


    def getInputCount(self):
        """getInputCount(BufferedPortImageMono16 self) -> int"""
        return _yarp.BufferedPortImageMono16_getInputCount(self)


    def getOutputCount(self):
        """getOutputCount(BufferedPortImageMono16 self) -> int"""
        return _yarp.BufferedPortImageMono16_getOutputCount(self)


    def isWriting(self):
        """isWriting(BufferedPortImageMono16 self) -> bool"""
        return _yarp.BufferedPortImageMono16_isWriting(self)


    def getReport(self, reporter):
        """getReport(BufferedPortImageMono16 self, PortReport reporter)"""
        return _yarp.BufferedPortImageMono16_getReport(self, reporter)


    def setReporter(self, reporter):
        """setReporter(BufferedPortImageMono16 self, PortReport reporter)"""
        return _yarp.BufferedPortImageMono16_setReporter(self, reporter)


    def resetReporter(self):
        """resetReporter(BufferedPortImageMono16 self)"""
        return _yarp.BufferedPortImageMono16_resetReporter(self)


    def acquire(self):
        """acquire(BufferedPortImageMono16 self) -> void *"""
        return _yarp.BufferedPortImageMono16_acquire(self)


    def release(self, handle):
        """release(BufferedPortImageMono16 self, void * handle)"""
        return _yarp.BufferedPortImageMono16_release(self, handle)


    def setTargetPeriod(self, period):
        """setTargetPeriod(BufferedPortImageMono16 self, double period)"""
        return _yarp.BufferedPortImageMono16_setTargetPeriod(self, period)


    def getType(self):
        """getType(BufferedPortImageMono16 self) -> Type"""
        return _yarp.BufferedPortImageMono16_getType(self)


    def promiseType(self, typ):
        """promiseType(BufferedPortImageMono16 self, Type const & typ)"""
        return _yarp.BufferedPortImageMono16_promiseType(self, typ)


    def setInputMode(self, expectInput):
        """setInputMode(BufferedPortImageMono16 self, bool expectInput)"""
        return _yarp.BufferedPortImageMono16_setInputMode(self, expectInput)


    def setOutputMode(self, expectOutput):
        """setOutputMode(BufferedPortImageMono16 self, bool expectOutput)"""
        return _yarp.BufferedPortImageMono16_setOutputMode(self, expectOutput)


    def setRpcMode(self, expectRpc):
        """setRpcMode(BufferedPortImageMono16 self, bool expectRpc)"""
        return _yarp.BufferedPortImageMono16_setRpcMode(self, expectRpc)


    def acquireProperties(self, readOnly):
        """acquireProperties(BufferedPortImageMono16 self, bool readOnly) -> Property"""
        return _yarp.BufferedPortImageMono16_acquireProperties(self, readOnly)


    def releaseProperties(self, prop):
        """releaseProperties(BufferedPortImageMono16 self, Property prop)"""
        return _yarp.BufferedPortImageMono16_releaseProperties(self, prop)


    def includeNodeInName(self, flag):
        """includeNodeInName(BufferedPortImageMono16 self, bool flag)"""
        return _yarp.BufferedPortImageMono16_includeNodeInName(self, flag)


    def setCallbackLock(self, mutex):
        """setCallbackLock(BufferedPortImageMono16 self, yarp::os::Mutex * mutex) -> bool"""
        return _yarp.BufferedPortImageMono16_setCallbackLock(self, mutex)


    def removeCallbackLock(self):
        """removeCallbackLock(BufferedPortImageMono16 self) -> bool"""
        return _yarp.BufferedPortImageMono16_removeCallbackLock(self)


    def lockCallback(self):
        """lockCallback(BufferedPortImageMono16 self) -> bool"""
        return _yarp.BufferedPortImageMono16_lockCallback(self)


    def tryLockCallback(self):
        """tryLockCallback(BufferedPortImageMono16 self) -> bool"""
        return _yarp.BufferedPortImageMono16_tryLockCallback(self)


    def unlockCallback(self):
        """unlockCallback(BufferedPortImageMono16 self)"""
        return _yarp.BufferedPortImageMono16_unlockCallback(self)

BufferedPortImageMono16_swigregister = _yarp.BufferedPortImageMono16_swigregister
BufferedPortImageMono16_swigregister(BufferedPortImageMono16)

class ImageInt(Image):
    """Proxy of C++ yarp::sig::ImageOf<(yarp::sig::PixelInt)> class."""

    __swig_setmethods__ = {}
    for _s in [Image]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ImageInt, name, value)
    __swig_getmethods__ = {}
    for _s in [Image]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ImageInt, name)
    __repr__ = _swig_repr

    def __init__(self):
        """__init__(yarp::sig::ImageOf<(yarp::sig::PixelInt)> self) -> ImageInt"""
        this = _yarp.new_ImageInt()
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def getPixelSize(self):
        """getPixelSize(ImageInt self) -> int"""
        return _yarp.ImageInt_getPixelSize(self)


    def getPixelCode(self):
        """getPixelCode(ImageInt self) -> int"""
        return _yarp.ImageInt_getPixelCode(self)


    def pixel(self, x, y):
        """pixel(ImageInt self, int x, int y) -> int &"""
        return _yarp.ImageInt_pixel(self, x, y)


    def access(self, x, y):
        """access(ImageInt self, int x, int y) -> int &"""
        return _yarp.ImageInt_access(self, x, y)


    def safePixel(self, *args):
        """
        safePixel(ImageInt self, int x, int y) -> int
        safePixel(ImageInt self, int x, int y) -> int const &
        """
        return _yarp.ImageInt_safePixel(self, *args)


    def getPixel(self, x, y):
        """getPixel(ImageInt self, int x, int y) -> int"""
        return _yarp.ImageInt_getPixel(self, x, y)


    def setPixel(self, x, y, v):
        """setPixel(ImageInt self, int x, int y, int v)"""
        return _yarp.ImageInt_setPixel(self, x, y, v)

    __swig_destroy__ = _yarp.delete_ImageInt
    __del__ = lambda self: None
ImageInt_swigregister = _yarp.ImageInt_swigregister
ImageInt_swigregister(ImageInt)

class TypedReaderImageInt(_object):
    """Proxy of C++ yarp::os::TypedReader<(yarp::sig::ImageOf<(yarp::sig::PixelInt)>)> class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, TypedReaderImageInt, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, TypedReaderImageInt, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def setStrict(self, strict=True):
        """
        setStrict(TypedReaderImageInt self, bool strict=True)
        setStrict(TypedReaderImageInt self)
        """
        return _yarp.TypedReaderImageInt_setStrict(self, strict)


    def read(self, shouldWait=True):
        """
        read(TypedReaderImageInt self, bool shouldWait=True) -> ImageInt
        read(TypedReaderImageInt self) -> ImageInt
        """
        return _yarp.TypedReaderImageInt_read(self, shouldWait)


    def interrupt(self):
        """interrupt(TypedReaderImageInt self)"""
        return _yarp.TypedReaderImageInt_interrupt(self)


    def lastRead(self):
        """lastRead(TypedReaderImageInt self) -> ImageInt"""
        return _yarp.TypedReaderImageInt_lastRead(self)


    def isClosed(self):
        """isClosed(TypedReaderImageInt self) -> bool"""
        return _yarp.TypedReaderImageInt_isClosed(self)


    def useCallback(self, callback):
        """useCallback(TypedReaderImageInt self, TypedReaderCallbackImageInt callback)"""
        return _yarp.TypedReaderImageInt_useCallback(self, callback)


    def disableCallback(self):
        """disableCallback(TypedReaderImageInt self)"""
        return _yarp.TypedReaderImageInt_disableCallback(self)


    def getPendingReads(self):
        """getPendingReads(TypedReaderImageInt self) -> int"""
        return _yarp.TypedReaderImageInt_getPendingReads(self)

    __swig_destroy__ = _yarp.delete_TypedReaderImageInt
    __del__ = lambda self: None

    def getName(self):
        """getName(TypedReaderImageInt self) -> yarp::os::ConstString"""
        return _yarp.TypedReaderImageInt_getName(self)


    def setReplier(self, reader):
        """setReplier(TypedReaderImageInt self, PortReader reader)"""
        return _yarp.TypedReaderImageInt_setReplier(self, reader)


    def acquire(self):
        """acquire(TypedReaderImageInt self) -> void *"""
        return _yarp.TypedReaderImageInt_acquire(self)


    def release(self, handle):
        """release(TypedReaderImageInt self, void * handle)"""
        return _yarp.TypedReaderImageInt_release(self, handle)


    def setTargetPeriod(self, period):
        """setTargetPeriod(TypedReaderImageInt self, double period)"""
        return _yarp.TypedReaderImageInt_setTargetPeriod(self, period)

TypedReaderImageInt_swigregister = _yarp.TypedReaderImageInt_swigregister
TypedReaderImageInt_swigregister(TypedReaderImageInt)

class TypedReaderCallbackImageInt(_object):
    """Proxy of C++ yarp::os::TypedReaderCallback<(yarp::sig::ImageOf<(yarp::sig::PixelInt)>)> class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, TypedReaderCallbackImageInt, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, TypedReaderCallbackImageInt, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_TypedReaderCallbackImageInt
    __del__ = lambda self: None

    def onRead(self, *args):
        """
        onRead(TypedReaderCallbackImageInt self, ImageInt datum)
        onRead(TypedReaderCallbackImageInt self, ImageInt datum, TypedReaderImageInt reader)
        """
        return _yarp.TypedReaderCallbackImageInt_onRead(self, *args)


    def __init__(self):
        """__init__(yarp::os::TypedReaderCallback<(yarp::sig::ImageOf<(yarp::sig::PixelInt)>)> self) -> TypedReaderCallbackImageInt"""
        this = _yarp.new_TypedReaderCallbackImageInt()
        try:
            self.this.append(this)
        except Exception:
            self.this = this
TypedReaderCallbackImageInt_swigregister = _yarp.TypedReaderCallbackImageInt_swigregister
TypedReaderCallbackImageInt_swigregister(TypedReaderCallbackImageInt)

class BufferedPortImageInt(Contactable, TypedReaderImageInt, TypedReaderCallbackImageInt):
    """Proxy of C++ yarp::os::BufferedPort<(yarp::sig::ImageOf<(yarp::sig::PixelInt)>)> class."""

    __swig_setmethods__ = {}
    for _s in [Contactable, TypedReaderImageInt, TypedReaderCallbackImageInt]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, BufferedPortImageInt, name, value)
    __swig_getmethods__ = {}
    for _s in [Contactable, TypedReaderImageInt, TypedReaderCallbackImageInt]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, BufferedPortImageInt, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(yarp::os::BufferedPort<(yarp::sig::ImageOf<(yarp::sig::PixelInt)>)> self) -> BufferedPortImageInt
        __init__(yarp::os::BufferedPort<(yarp::sig::ImageOf<(yarp::sig::PixelInt)>)> self, Port port) -> BufferedPortImageInt
        """
        this = _yarp.new_BufferedPortImageInt(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _yarp.delete_BufferedPortImageInt
    __del__ = lambda self: None

    def addOutput(self, *args):
        """
        addOutput(BufferedPortImageInt self, yarp::os::ConstString const & name) -> bool
        addOutput(BufferedPortImageInt self, yarp::os::ConstString const & name, yarp::os::ConstString const & carrier) -> bool
        addOutput(BufferedPortImageInt self, Contact contact) -> bool
        """
        return _yarp.BufferedPortImageInt_addOutput(self, *args)


    def close(self):
        """close(BufferedPortImageInt self)"""
        return _yarp.BufferedPortImageInt_close(self)


    def interrupt(self):
        """interrupt(BufferedPortImageInt self)"""
        return _yarp.BufferedPortImageInt_interrupt(self)


    def resume(self):
        """resume(BufferedPortImageInt self)"""
        return _yarp.BufferedPortImageInt_resume(self)


    def getPendingReads(self):
        """getPendingReads(BufferedPortImageInt self) -> int"""
        return _yarp.BufferedPortImageInt_getPendingReads(self)


    def where(self):
        """where(BufferedPortImageInt self) -> Contact"""
        return _yarp.BufferedPortImageInt_where(self)


    def getName(self):
        """getName(BufferedPortImageInt self) -> yarp::os::ConstString"""
        return _yarp.BufferedPortImageInt_getName(self)


    def prepare(self):
        """prepare(BufferedPortImageInt self) -> ImageInt"""
        return _yarp.BufferedPortImageInt_prepare(self)


    def unprepare(self):
        """unprepare(BufferedPortImageInt self) -> bool"""
        return _yarp.BufferedPortImageInt_unprepare(self)


    def write(self, forceStrict=False):
        """
        write(BufferedPortImageInt self, bool forceStrict=False)
        write(BufferedPortImageInt self)
        """
        return _yarp.BufferedPortImageInt_write(self, forceStrict)


    def writeStrict(self):
        """writeStrict(BufferedPortImageInt self)"""
        return _yarp.BufferedPortImageInt_writeStrict(self)


    def waitForWrite(self):
        """waitForWrite(BufferedPortImageInt self)"""
        return _yarp.BufferedPortImageInt_waitForWrite(self)


    def setStrict(self, strict=True):
        """
        setStrict(BufferedPortImageInt self, bool strict=True)
        setStrict(BufferedPortImageInt self)
        """
        return _yarp.BufferedPortImageInt_setStrict(self, strict)


    def read(self, shouldWait=True):
        """
        read(BufferedPortImageInt self, bool shouldWait=True) -> ImageInt
        read(BufferedPortImageInt self) -> ImageInt
        """
        return _yarp.BufferedPortImageInt_read(self, shouldWait)


    def lastRead(self):
        """lastRead(BufferedPortImageInt self) -> ImageInt"""
        return _yarp.BufferedPortImageInt_lastRead(self)


    def isClosed(self):
        """isClosed(BufferedPortImageInt self) -> bool"""
        return _yarp.BufferedPortImageInt_isClosed(self)


    def setReplier(self, reader):
        """setReplier(BufferedPortImageInt self, PortReader reader)"""
        return _yarp.BufferedPortImageInt_setReplier(self, reader)


    def setReader(self, reader):
        """setReader(BufferedPortImageInt self, PortReader reader)"""
        return _yarp.BufferedPortImageInt_setReader(self, reader)


    def setAdminReader(self, reader):
        """setAdminReader(BufferedPortImageInt self, PortReader reader)"""
        return _yarp.BufferedPortImageInt_setAdminReader(self, reader)


    def onRead(self, *args):
        """
        onRead(BufferedPortImageInt self, ImageInt datum, TypedReaderImageInt reader)
        onRead(BufferedPortImageInt self, ImageInt datum)
        """
        return _yarp.BufferedPortImageInt_onRead(self, *args)


    def useCallback(self, *args):
        """
        useCallback(BufferedPortImageInt self, TypedReaderCallbackImageInt callback)
        useCallback(BufferedPortImageInt self)
        """
        return _yarp.BufferedPortImageInt_useCallback(self, *args)


    def disableCallback(self):
        """disableCallback(BufferedPortImageInt self)"""
        return _yarp.BufferedPortImageInt_disableCallback(self)


    def setEnvelope(self, envelope):
        """setEnvelope(BufferedPortImageInt self, PortWriter envelope) -> bool"""
        return _yarp.BufferedPortImageInt_setEnvelope(self, envelope)


    def getEnvelope(self, envelope):
        """getEnvelope(BufferedPortImageInt self, PortReader envelope) -> bool"""
        return _yarp.BufferedPortImageInt_getEnvelope(self, envelope)


    def getInputCount(self):
        """getInputCount(BufferedPortImageInt self) -> int"""
        return _yarp.BufferedPortImageInt_getInputCount(self)


    def getOutputCount(self):
        """getOutputCount(BufferedPortImageInt self) -> int"""
        return _yarp.BufferedPortImageInt_getOutputCount(self)


    def isWriting(self):
        """isWriting(BufferedPortImageInt self) -> bool"""
        return _yarp.BufferedPortImageInt_isWriting(self)


    def getReport(self, reporter):
        """getReport(BufferedPortImageInt self, PortReport reporter)"""
        return _yarp.BufferedPortImageInt_getReport(self, reporter)


    def setReporter(self, reporter):
        """setReporter(BufferedPortImageInt self, PortReport reporter)"""
        return _yarp.BufferedPortImageInt_setReporter(self, reporter)


    def resetReporter(self):
        """resetReporter(BufferedPortImageInt self)"""
        return _yarp.BufferedPortImageInt_resetReporter(self)


    def acquire(self):
        """acquire(BufferedPortImageInt self) -> void *"""
        return _yarp.BufferedPortImageInt_acquire(self)


    def release(self, handle):
        """release(BufferedPortImageInt self, void * handle)"""
        return _yarp.BufferedPortImageInt_release(self, handle)


    def setTargetPeriod(self, period):
        """setTargetPeriod(BufferedPortImageInt self, double period)"""
        return _yarp.BufferedPortImageInt_setTargetPeriod(self, period)


    def getType(self):
        """getType(BufferedPortImageInt self) -> Type"""
        return _yarp.BufferedPortImageInt_getType(self)


    def promiseType(self, typ):
        """promiseType(BufferedPortImageInt self, Type const & typ)"""
        return _yarp.BufferedPortImageInt_promiseType(self, typ)


    def setInputMode(self, expectInput):
        """setInputMode(BufferedPortImageInt self, bool expectInput)"""
        return _yarp.BufferedPortImageInt_setInputMode(self, expectInput)


    def setOutputMode(self, expectOutput):
        """setOutputMode(BufferedPortImageInt self, bool expectOutput)"""
        return _yarp.BufferedPortImageInt_setOutputMode(self, expectOutput)


    def setRpcMode(self, expectRpc):
        """setRpcMode(BufferedPortImageInt self, bool expectRpc)"""
        return _yarp.BufferedPortImageInt_setRpcMode(self, expectRpc)


    def acquireProperties(self, readOnly):
        """acquireProperties(BufferedPortImageInt self, bool readOnly) -> Property"""
        return _yarp.BufferedPortImageInt_acquireProperties(self, readOnly)


    def releaseProperties(self, prop):
        """releaseProperties(BufferedPortImageInt self, Property prop)"""
        return _yarp.BufferedPortImageInt_releaseProperties(self, prop)


    def includeNodeInName(self, flag):
        """includeNodeInName(BufferedPortImageInt self, bool flag)"""
        return _yarp.BufferedPortImageInt_includeNodeInName(self, flag)


    def setCallbackLock(self, mutex):
        """setCallbackLock(BufferedPortImageInt self, yarp::os::Mutex * mutex) -> bool"""
        return _yarp.BufferedPortImageInt_setCallbackLock(self, mutex)


    def removeCallbackLock(self):
        """removeCallbackLock(BufferedPortImageInt self) -> bool"""
        return _yarp.BufferedPortImageInt_removeCallbackLock(self)


    def lockCallback(self):
        """lockCallback(BufferedPortImageInt self) -> bool"""
        return _yarp.BufferedPortImageInt_lockCallback(self)


    def tryLockCallback(self):
        """tryLockCallback(BufferedPortImageInt self) -> bool"""
        return _yarp.BufferedPortImageInt_tryLockCallback(self)


    def unlockCallback(self):
        """unlockCallback(BufferedPortImageInt self)"""
        return _yarp.BufferedPortImageInt_unlockCallback(self)

BufferedPortImageInt_swigregister = _yarp.BufferedPortImageInt_swigregister
BufferedPortImageInt_swigregister(BufferedPortImageInt)

class TypedReaderSound(_object):
    """Proxy of C++ yarp::os::TypedReader<(yarp::sig::Sound)> class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, TypedReaderSound, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, TypedReaderSound, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def setStrict(self, strict=True):
        """
        setStrict(TypedReaderSound self, bool strict=True)
        setStrict(TypedReaderSound self)
        """
        return _yarp.TypedReaderSound_setStrict(self, strict)


    def read(self, shouldWait=True):
        """
        read(TypedReaderSound self, bool shouldWait=True) -> Sound
        read(TypedReaderSound self) -> Sound
        """
        return _yarp.TypedReaderSound_read(self, shouldWait)


    def interrupt(self):
        """interrupt(TypedReaderSound self)"""
        return _yarp.TypedReaderSound_interrupt(self)


    def lastRead(self):
        """lastRead(TypedReaderSound self) -> Sound"""
        return _yarp.TypedReaderSound_lastRead(self)


    def isClosed(self):
        """isClosed(TypedReaderSound self) -> bool"""
        return _yarp.TypedReaderSound_isClosed(self)


    def useCallback(self, callback):
        """useCallback(TypedReaderSound self, TypedReaderCallbackSound callback)"""
        return _yarp.TypedReaderSound_useCallback(self, callback)


    def disableCallback(self):
        """disableCallback(TypedReaderSound self)"""
        return _yarp.TypedReaderSound_disableCallback(self)


    def getPendingReads(self):
        """getPendingReads(TypedReaderSound self) -> int"""
        return _yarp.TypedReaderSound_getPendingReads(self)

    __swig_destroy__ = _yarp.delete_TypedReaderSound
    __del__ = lambda self: None

    def getName(self):
        """getName(TypedReaderSound self) -> yarp::os::ConstString"""
        return _yarp.TypedReaderSound_getName(self)


    def setReplier(self, reader):
        """setReplier(TypedReaderSound self, PortReader reader)"""
        return _yarp.TypedReaderSound_setReplier(self, reader)


    def acquire(self):
        """acquire(TypedReaderSound self) -> void *"""
        return _yarp.TypedReaderSound_acquire(self)


    def release(self, handle):
        """release(TypedReaderSound self, void * handle)"""
        return _yarp.TypedReaderSound_release(self, handle)


    def setTargetPeriod(self, period):
        """setTargetPeriod(TypedReaderSound self, double period)"""
        return _yarp.TypedReaderSound_setTargetPeriod(self, period)

TypedReaderSound_swigregister = _yarp.TypedReaderSound_swigregister
TypedReaderSound_swigregister(TypedReaderSound)

class TypedReaderCallbackSound(_object):
    """Proxy of C++ yarp::os::TypedReaderCallback<(yarp::sig::Sound)> class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, TypedReaderCallbackSound, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, TypedReaderCallbackSound, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_TypedReaderCallbackSound
    __del__ = lambda self: None

    def onRead(self, *args):
        """
        onRead(TypedReaderCallbackSound self, Sound datum)
        onRead(TypedReaderCallbackSound self, Sound datum, TypedReaderSound reader)
        """
        return _yarp.TypedReaderCallbackSound_onRead(self, *args)


    def __init__(self):
        """__init__(yarp::os::TypedReaderCallback<(yarp::sig::Sound)> self) -> TypedReaderCallbackSound"""
        this = _yarp.new_TypedReaderCallbackSound()
        try:
            self.this.append(this)
        except Exception:
            self.this = this
TypedReaderCallbackSound_swigregister = _yarp.TypedReaderCallbackSound_swigregister
TypedReaderCallbackSound_swigregister(TypedReaderCallbackSound)

class BufferedPortSound(Contactable, TypedReaderSound, TypedReaderCallbackSound):
    """Proxy of C++ yarp::os::BufferedPort<(yarp::sig::Sound)> class."""

    __swig_setmethods__ = {}
    for _s in [Contactable, TypedReaderSound, TypedReaderCallbackSound]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, BufferedPortSound, name, value)
    __swig_getmethods__ = {}
    for _s in [Contactable, TypedReaderSound, TypedReaderCallbackSound]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, BufferedPortSound, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(yarp::os::BufferedPort<(yarp::sig::Sound)> self) -> BufferedPortSound
        __init__(yarp::os::BufferedPort<(yarp::sig::Sound)> self, Port port) -> BufferedPortSound
        """
        this = _yarp.new_BufferedPortSound(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _yarp.delete_BufferedPortSound
    __del__ = lambda self: None

    def addOutput(self, *args):
        """
        addOutput(BufferedPortSound self, yarp::os::ConstString const & name) -> bool
        addOutput(BufferedPortSound self, yarp::os::ConstString const & name, yarp::os::ConstString const & carrier) -> bool
        addOutput(BufferedPortSound self, Contact contact) -> bool
        """
        return _yarp.BufferedPortSound_addOutput(self, *args)


    def close(self):
        """close(BufferedPortSound self)"""
        return _yarp.BufferedPortSound_close(self)


    def interrupt(self):
        """interrupt(BufferedPortSound self)"""
        return _yarp.BufferedPortSound_interrupt(self)


    def resume(self):
        """resume(BufferedPortSound self)"""
        return _yarp.BufferedPortSound_resume(self)


    def getPendingReads(self):
        """getPendingReads(BufferedPortSound self) -> int"""
        return _yarp.BufferedPortSound_getPendingReads(self)


    def where(self):
        """where(BufferedPortSound self) -> Contact"""
        return _yarp.BufferedPortSound_where(self)


    def getName(self):
        """getName(BufferedPortSound self) -> yarp::os::ConstString"""
        return _yarp.BufferedPortSound_getName(self)


    def prepare(self):
        """prepare(BufferedPortSound self) -> Sound"""
        return _yarp.BufferedPortSound_prepare(self)


    def unprepare(self):
        """unprepare(BufferedPortSound self) -> bool"""
        return _yarp.BufferedPortSound_unprepare(self)


    def write(self, forceStrict=False):
        """
        write(BufferedPortSound self, bool forceStrict=False)
        write(BufferedPortSound self)
        """
        return _yarp.BufferedPortSound_write(self, forceStrict)


    def writeStrict(self):
        """writeStrict(BufferedPortSound self)"""
        return _yarp.BufferedPortSound_writeStrict(self)


    def waitForWrite(self):
        """waitForWrite(BufferedPortSound self)"""
        return _yarp.BufferedPortSound_waitForWrite(self)


    def setStrict(self, strict=True):
        """
        setStrict(BufferedPortSound self, bool strict=True)
        setStrict(BufferedPortSound self)
        """
        return _yarp.BufferedPortSound_setStrict(self, strict)


    def read(self, shouldWait=True):
        """
        read(BufferedPortSound self, bool shouldWait=True) -> Sound
        read(BufferedPortSound self) -> Sound
        """
        return _yarp.BufferedPortSound_read(self, shouldWait)


    def lastRead(self):
        """lastRead(BufferedPortSound self) -> Sound"""
        return _yarp.BufferedPortSound_lastRead(self)


    def isClosed(self):
        """isClosed(BufferedPortSound self) -> bool"""
        return _yarp.BufferedPortSound_isClosed(self)


    def setReplier(self, reader):
        """setReplier(BufferedPortSound self, PortReader reader)"""
        return _yarp.BufferedPortSound_setReplier(self, reader)


    def setReader(self, reader):
        """setReader(BufferedPortSound self, PortReader reader)"""
        return _yarp.BufferedPortSound_setReader(self, reader)


    def setAdminReader(self, reader):
        """setAdminReader(BufferedPortSound self, PortReader reader)"""
        return _yarp.BufferedPortSound_setAdminReader(self, reader)


    def onRead(self, *args):
        """
        onRead(BufferedPortSound self, Sound datum, TypedReaderSound reader)
        onRead(BufferedPortSound self, Sound datum)
        """
        return _yarp.BufferedPortSound_onRead(self, *args)


    def useCallback(self, *args):
        """
        useCallback(BufferedPortSound self, TypedReaderCallbackSound callback)
        useCallback(BufferedPortSound self)
        """
        return _yarp.BufferedPortSound_useCallback(self, *args)


    def disableCallback(self):
        """disableCallback(BufferedPortSound self)"""
        return _yarp.BufferedPortSound_disableCallback(self)


    def setEnvelope(self, envelope):
        """setEnvelope(BufferedPortSound self, PortWriter envelope) -> bool"""
        return _yarp.BufferedPortSound_setEnvelope(self, envelope)


    def getEnvelope(self, envelope):
        """getEnvelope(BufferedPortSound self, PortReader envelope) -> bool"""
        return _yarp.BufferedPortSound_getEnvelope(self, envelope)


    def getInputCount(self):
        """getInputCount(BufferedPortSound self) -> int"""
        return _yarp.BufferedPortSound_getInputCount(self)


    def getOutputCount(self):
        """getOutputCount(BufferedPortSound self) -> int"""
        return _yarp.BufferedPortSound_getOutputCount(self)


    def isWriting(self):
        """isWriting(BufferedPortSound self) -> bool"""
        return _yarp.BufferedPortSound_isWriting(self)


    def getReport(self, reporter):
        """getReport(BufferedPortSound self, PortReport reporter)"""
        return _yarp.BufferedPortSound_getReport(self, reporter)


    def setReporter(self, reporter):
        """setReporter(BufferedPortSound self, PortReport reporter)"""
        return _yarp.BufferedPortSound_setReporter(self, reporter)


    def resetReporter(self):
        """resetReporter(BufferedPortSound self)"""
        return _yarp.BufferedPortSound_resetReporter(self)


    def acquire(self):
        """acquire(BufferedPortSound self) -> void *"""
        return _yarp.BufferedPortSound_acquire(self)


    def release(self, handle):
        """release(BufferedPortSound self, void * handle)"""
        return _yarp.BufferedPortSound_release(self, handle)


    def setTargetPeriod(self, period):
        """setTargetPeriod(BufferedPortSound self, double period)"""
        return _yarp.BufferedPortSound_setTargetPeriod(self, period)


    def getType(self):
        """getType(BufferedPortSound self) -> Type"""
        return _yarp.BufferedPortSound_getType(self)


    def promiseType(self, typ):
        """promiseType(BufferedPortSound self, Type const & typ)"""
        return _yarp.BufferedPortSound_promiseType(self, typ)


    def setInputMode(self, expectInput):
        """setInputMode(BufferedPortSound self, bool expectInput)"""
        return _yarp.BufferedPortSound_setInputMode(self, expectInput)


    def setOutputMode(self, expectOutput):
        """setOutputMode(BufferedPortSound self, bool expectOutput)"""
        return _yarp.BufferedPortSound_setOutputMode(self, expectOutput)


    def setRpcMode(self, expectRpc):
        """setRpcMode(BufferedPortSound self, bool expectRpc)"""
        return _yarp.BufferedPortSound_setRpcMode(self, expectRpc)


    def acquireProperties(self, readOnly):
        """acquireProperties(BufferedPortSound self, bool readOnly) -> Property"""
        return _yarp.BufferedPortSound_acquireProperties(self, readOnly)


    def releaseProperties(self, prop):
        """releaseProperties(BufferedPortSound self, Property prop)"""
        return _yarp.BufferedPortSound_releaseProperties(self, prop)


    def includeNodeInName(self, flag):
        """includeNodeInName(BufferedPortSound self, bool flag)"""
        return _yarp.BufferedPortSound_includeNodeInName(self, flag)


    def setCallbackLock(self, mutex):
        """setCallbackLock(BufferedPortSound self, yarp::os::Mutex * mutex) -> bool"""
        return _yarp.BufferedPortSound_setCallbackLock(self, mutex)


    def removeCallbackLock(self):
        """removeCallbackLock(BufferedPortSound self) -> bool"""
        return _yarp.BufferedPortSound_removeCallbackLock(self)


    def lockCallback(self):
        """lockCallback(BufferedPortSound self) -> bool"""
        return _yarp.BufferedPortSound_lockCallback(self)


    def tryLockCallback(self):
        """tryLockCallback(BufferedPortSound self) -> bool"""
        return _yarp.BufferedPortSound_tryLockCallback(self)


    def unlockCallback(self):
        """unlockCallback(BufferedPortSound self)"""
        return _yarp.BufferedPortSound_unlockCallback(self)

BufferedPortSound_swigregister = _yarp.BufferedPortSound_swigregister
BufferedPortSound_swigregister(BufferedPortSound)

class TypedReaderVector(_object):
    """Proxy of C++ yarp::os::TypedReader<(yarp::sig::Vector)> class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, TypedReaderVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, TypedReaderVector, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def setStrict(self, strict=True):
        """
        setStrict(TypedReaderVector self, bool strict=True)
        setStrict(TypedReaderVector self)
        """
        return _yarp.TypedReaderVector_setStrict(self, strict)


    def read(self, shouldWait=True):
        """
        read(TypedReaderVector self, bool shouldWait=True) -> Vector
        read(TypedReaderVector self) -> Vector
        """
        return _yarp.TypedReaderVector_read(self, shouldWait)


    def interrupt(self):
        """interrupt(TypedReaderVector self)"""
        return _yarp.TypedReaderVector_interrupt(self)


    def lastRead(self):
        """lastRead(TypedReaderVector self) -> Vector"""
        return _yarp.TypedReaderVector_lastRead(self)


    def isClosed(self):
        """isClosed(TypedReaderVector self) -> bool"""
        return _yarp.TypedReaderVector_isClosed(self)


    def useCallback(self, callback):
        """useCallback(TypedReaderVector self, TypedReaderCallbackVector callback)"""
        return _yarp.TypedReaderVector_useCallback(self, callback)


    def disableCallback(self):
        """disableCallback(TypedReaderVector self)"""
        return _yarp.TypedReaderVector_disableCallback(self)


    def getPendingReads(self):
        """getPendingReads(TypedReaderVector self) -> int"""
        return _yarp.TypedReaderVector_getPendingReads(self)

    __swig_destroy__ = _yarp.delete_TypedReaderVector
    __del__ = lambda self: None

    def getName(self):
        """getName(TypedReaderVector self) -> yarp::os::ConstString"""
        return _yarp.TypedReaderVector_getName(self)


    def setReplier(self, reader):
        """setReplier(TypedReaderVector self, PortReader reader)"""
        return _yarp.TypedReaderVector_setReplier(self, reader)


    def acquire(self):
        """acquire(TypedReaderVector self) -> void *"""
        return _yarp.TypedReaderVector_acquire(self)


    def release(self, handle):
        """release(TypedReaderVector self, void * handle)"""
        return _yarp.TypedReaderVector_release(self, handle)


    def setTargetPeriod(self, period):
        """setTargetPeriod(TypedReaderVector self, double period)"""
        return _yarp.TypedReaderVector_setTargetPeriod(self, period)

TypedReaderVector_swigregister = _yarp.TypedReaderVector_swigregister
TypedReaderVector_swigregister(TypedReaderVector)

class TypedReaderCallbackVector(_object):
    """Proxy of C++ yarp::os::TypedReaderCallback<(yarp::sig::Vector)> class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, TypedReaderCallbackVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, TypedReaderCallbackVector, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_TypedReaderCallbackVector
    __del__ = lambda self: None

    def onRead(self, *args):
        """
        onRead(TypedReaderCallbackVector self, Vector datum)
        onRead(TypedReaderCallbackVector self, Vector datum, TypedReaderVector reader)
        """
        return _yarp.TypedReaderCallbackVector_onRead(self, *args)


    def __init__(self):
        """__init__(yarp::os::TypedReaderCallback<(yarp::sig::Vector)> self) -> TypedReaderCallbackVector"""
        this = _yarp.new_TypedReaderCallbackVector()
        try:
            self.this.append(this)
        except Exception:
            self.this = this
TypedReaderCallbackVector_swigregister = _yarp.TypedReaderCallbackVector_swigregister
TypedReaderCallbackVector_swigregister(TypedReaderCallbackVector)

class BufferedPortVector(Contactable, TypedReaderVector, TypedReaderCallbackVector):
    """Proxy of C++ yarp::os::BufferedPort<(yarp::sig::Vector)> class."""

    __swig_setmethods__ = {}
    for _s in [Contactable, TypedReaderVector, TypedReaderCallbackVector]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, BufferedPortVector, name, value)
    __swig_getmethods__ = {}
    for _s in [Contactable, TypedReaderVector, TypedReaderCallbackVector]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, BufferedPortVector, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(yarp::os::BufferedPort<(yarp::sig::Vector)> self) -> BufferedPortVector
        __init__(yarp::os::BufferedPort<(yarp::sig::Vector)> self, Port port) -> BufferedPortVector
        """
        this = _yarp.new_BufferedPortVector(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _yarp.delete_BufferedPortVector
    __del__ = lambda self: None

    def addOutput(self, *args):
        """
        addOutput(BufferedPortVector self, yarp::os::ConstString const & name) -> bool
        addOutput(BufferedPortVector self, yarp::os::ConstString const & name, yarp::os::ConstString const & carrier) -> bool
        addOutput(BufferedPortVector self, Contact contact) -> bool
        """
        return _yarp.BufferedPortVector_addOutput(self, *args)


    def close(self):
        """close(BufferedPortVector self)"""
        return _yarp.BufferedPortVector_close(self)


    def interrupt(self):
        """interrupt(BufferedPortVector self)"""
        return _yarp.BufferedPortVector_interrupt(self)


    def resume(self):
        """resume(BufferedPortVector self)"""
        return _yarp.BufferedPortVector_resume(self)


    def getPendingReads(self):
        """getPendingReads(BufferedPortVector self) -> int"""
        return _yarp.BufferedPortVector_getPendingReads(self)


    def where(self):
        """where(BufferedPortVector self) -> Contact"""
        return _yarp.BufferedPortVector_where(self)


    def getName(self):
        """getName(BufferedPortVector self) -> yarp::os::ConstString"""
        return _yarp.BufferedPortVector_getName(self)


    def prepare(self):
        """prepare(BufferedPortVector self) -> Vector"""
        return _yarp.BufferedPortVector_prepare(self)


    def unprepare(self):
        """unprepare(BufferedPortVector self) -> bool"""
        return _yarp.BufferedPortVector_unprepare(self)


    def write(self, forceStrict=False):
        """
        write(BufferedPortVector self, bool forceStrict=False)
        write(BufferedPortVector self)
        """
        return _yarp.BufferedPortVector_write(self, forceStrict)


    def writeStrict(self):
        """writeStrict(BufferedPortVector self)"""
        return _yarp.BufferedPortVector_writeStrict(self)


    def waitForWrite(self):
        """waitForWrite(BufferedPortVector self)"""
        return _yarp.BufferedPortVector_waitForWrite(self)


    def setStrict(self, strict=True):
        """
        setStrict(BufferedPortVector self, bool strict=True)
        setStrict(BufferedPortVector self)
        """
        return _yarp.BufferedPortVector_setStrict(self, strict)


    def read(self, shouldWait=True):
        """
        read(BufferedPortVector self, bool shouldWait=True) -> Vector
        read(BufferedPortVector self) -> Vector
        """
        return _yarp.BufferedPortVector_read(self, shouldWait)


    def lastRead(self):
        """lastRead(BufferedPortVector self) -> Vector"""
        return _yarp.BufferedPortVector_lastRead(self)


    def isClosed(self):
        """isClosed(BufferedPortVector self) -> bool"""
        return _yarp.BufferedPortVector_isClosed(self)


    def setReplier(self, reader):
        """setReplier(BufferedPortVector self, PortReader reader)"""
        return _yarp.BufferedPortVector_setReplier(self, reader)


    def setReader(self, reader):
        """setReader(BufferedPortVector self, PortReader reader)"""
        return _yarp.BufferedPortVector_setReader(self, reader)


    def setAdminReader(self, reader):
        """setAdminReader(BufferedPortVector self, PortReader reader)"""
        return _yarp.BufferedPortVector_setAdminReader(self, reader)


    def onRead(self, *args):
        """
        onRead(BufferedPortVector self, Vector datum, TypedReaderVector reader)
        onRead(BufferedPortVector self, Vector datum)
        """
        return _yarp.BufferedPortVector_onRead(self, *args)


    def useCallback(self, *args):
        """
        useCallback(BufferedPortVector self, TypedReaderCallbackVector callback)
        useCallback(BufferedPortVector self)
        """
        return _yarp.BufferedPortVector_useCallback(self, *args)


    def disableCallback(self):
        """disableCallback(BufferedPortVector self)"""
        return _yarp.BufferedPortVector_disableCallback(self)


    def setEnvelope(self, envelope):
        """setEnvelope(BufferedPortVector self, PortWriter envelope) -> bool"""
        return _yarp.BufferedPortVector_setEnvelope(self, envelope)


    def getEnvelope(self, envelope):
        """getEnvelope(BufferedPortVector self, PortReader envelope) -> bool"""
        return _yarp.BufferedPortVector_getEnvelope(self, envelope)


    def getInputCount(self):
        """getInputCount(BufferedPortVector self) -> int"""
        return _yarp.BufferedPortVector_getInputCount(self)


    def getOutputCount(self):
        """getOutputCount(BufferedPortVector self) -> int"""
        return _yarp.BufferedPortVector_getOutputCount(self)


    def isWriting(self):
        """isWriting(BufferedPortVector self) -> bool"""
        return _yarp.BufferedPortVector_isWriting(self)


    def getReport(self, reporter):
        """getReport(BufferedPortVector self, PortReport reporter)"""
        return _yarp.BufferedPortVector_getReport(self, reporter)


    def setReporter(self, reporter):
        """setReporter(BufferedPortVector self, PortReport reporter)"""
        return _yarp.BufferedPortVector_setReporter(self, reporter)


    def resetReporter(self):
        """resetReporter(BufferedPortVector self)"""
        return _yarp.BufferedPortVector_resetReporter(self)


    def acquire(self):
        """acquire(BufferedPortVector self) -> void *"""
        return _yarp.BufferedPortVector_acquire(self)


    def release(self, handle):
        """release(BufferedPortVector self, void * handle)"""
        return _yarp.BufferedPortVector_release(self, handle)


    def setTargetPeriod(self, period):
        """setTargetPeriod(BufferedPortVector self, double period)"""
        return _yarp.BufferedPortVector_setTargetPeriod(self, period)


    def getType(self):
        """getType(BufferedPortVector self) -> Type"""
        return _yarp.BufferedPortVector_getType(self)


    def promiseType(self, typ):
        """promiseType(BufferedPortVector self, Type const & typ)"""
        return _yarp.BufferedPortVector_promiseType(self, typ)


    def setInputMode(self, expectInput):
        """setInputMode(BufferedPortVector self, bool expectInput)"""
        return _yarp.BufferedPortVector_setInputMode(self, expectInput)


    def setOutputMode(self, expectOutput):
        """setOutputMode(BufferedPortVector self, bool expectOutput)"""
        return _yarp.BufferedPortVector_setOutputMode(self, expectOutput)


    def setRpcMode(self, expectRpc):
        """setRpcMode(BufferedPortVector self, bool expectRpc)"""
        return _yarp.BufferedPortVector_setRpcMode(self, expectRpc)


    def acquireProperties(self, readOnly):
        """acquireProperties(BufferedPortVector self, bool readOnly) -> Property"""
        return _yarp.BufferedPortVector_acquireProperties(self, readOnly)


    def releaseProperties(self, prop):
        """releaseProperties(BufferedPortVector self, Property prop)"""
        return _yarp.BufferedPortVector_releaseProperties(self, prop)


    def includeNodeInName(self, flag):
        """includeNodeInName(BufferedPortVector self, bool flag)"""
        return _yarp.BufferedPortVector_includeNodeInName(self, flag)


    def setCallbackLock(self, mutex):
        """setCallbackLock(BufferedPortVector self, yarp::os::Mutex * mutex) -> bool"""
        return _yarp.BufferedPortVector_setCallbackLock(self, mutex)


    def removeCallbackLock(self):
        """removeCallbackLock(BufferedPortVector self) -> bool"""
        return _yarp.BufferedPortVector_removeCallbackLock(self)


    def lockCallback(self):
        """lockCallback(BufferedPortVector self) -> bool"""
        return _yarp.BufferedPortVector_lockCallback(self)


    def tryLockCallback(self):
        """tryLockCallback(BufferedPortVector self) -> bool"""
        return _yarp.BufferedPortVector_tryLockCallback(self)


    def unlockCallback(self):
        """unlockCallback(BufferedPortVector self)"""
        return _yarp.BufferedPortVector_unlockCallback(self)

BufferedPortVector_swigregister = _yarp.BufferedPortVector_swigregister
BufferedPortVector_swigregister(BufferedPortVector)

class ImageFloat(Image):
    """Proxy of C++ yarp::sig::ImageOf<(yarp::sig::PixelFloat)> class."""

    __swig_setmethods__ = {}
    for _s in [Image]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ImageFloat, name, value)
    __swig_getmethods__ = {}
    for _s in [Image]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ImageFloat, name)
    __repr__ = _swig_repr

    def __init__(self):
        """__init__(yarp::sig::ImageOf<(yarp::sig::PixelFloat)> self) -> ImageFloat"""
        this = _yarp.new_ImageFloat()
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def getPixelSize(self):
        """getPixelSize(ImageFloat self) -> int"""
        return _yarp.ImageFloat_getPixelSize(self)


    def getPixelCode(self):
        """getPixelCode(ImageFloat self) -> int"""
        return _yarp.ImageFloat_getPixelCode(self)


    def pixel(self, x, y):
        """pixel(ImageFloat self, int x, int y) -> float &"""
        return _yarp.ImageFloat_pixel(self, x, y)


    def access(self, x, y):
        """access(ImageFloat self, int x, int y) -> float &"""
        return _yarp.ImageFloat_access(self, x, y)


    def safePixel(self, *args):
        """
        safePixel(ImageFloat self, int x, int y) -> float
        safePixel(ImageFloat self, int x, int y) -> float const &
        """
        return _yarp.ImageFloat_safePixel(self, *args)


    def getPixel(self, x, y):
        """getPixel(ImageFloat self, int x, int y) -> float"""
        return _yarp.ImageFloat_getPixel(self, x, y)


    def setPixel(self, x, y, v):
        """setPixel(ImageFloat self, int x, int y, float v)"""
        return _yarp.ImageFloat_setPixel(self, x, y, v)

    __swig_destroy__ = _yarp.delete_ImageFloat
    __del__ = lambda self: None
ImageFloat_swigregister = _yarp.ImageFloat_swigregister
ImageFloat_swigregister(ImageFloat)

class TypedReaderImageFloat(_object):
    """Proxy of C++ yarp::os::TypedReader<(yarp::sig::ImageOf<(yarp::sig::PixelFloat)>)> class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, TypedReaderImageFloat, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, TypedReaderImageFloat, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def setStrict(self, strict=True):
        """
        setStrict(TypedReaderImageFloat self, bool strict=True)
        setStrict(TypedReaderImageFloat self)
        """
        return _yarp.TypedReaderImageFloat_setStrict(self, strict)


    def read(self, shouldWait=True):
        """
        read(TypedReaderImageFloat self, bool shouldWait=True) -> ImageFloat
        read(TypedReaderImageFloat self) -> ImageFloat
        """
        return _yarp.TypedReaderImageFloat_read(self, shouldWait)


    def interrupt(self):
        """interrupt(TypedReaderImageFloat self)"""
        return _yarp.TypedReaderImageFloat_interrupt(self)


    def lastRead(self):
        """lastRead(TypedReaderImageFloat self) -> ImageFloat"""
        return _yarp.TypedReaderImageFloat_lastRead(self)


    def isClosed(self):
        """isClosed(TypedReaderImageFloat self) -> bool"""
        return _yarp.TypedReaderImageFloat_isClosed(self)


    def useCallback(self, callback):
        """useCallback(TypedReaderImageFloat self, TypedReaderCallbackImageFloat callback)"""
        return _yarp.TypedReaderImageFloat_useCallback(self, callback)


    def disableCallback(self):
        """disableCallback(TypedReaderImageFloat self)"""
        return _yarp.TypedReaderImageFloat_disableCallback(self)


    def getPendingReads(self):
        """getPendingReads(TypedReaderImageFloat self) -> int"""
        return _yarp.TypedReaderImageFloat_getPendingReads(self)

    __swig_destroy__ = _yarp.delete_TypedReaderImageFloat
    __del__ = lambda self: None

    def getName(self):
        """getName(TypedReaderImageFloat self) -> yarp::os::ConstString"""
        return _yarp.TypedReaderImageFloat_getName(self)


    def setReplier(self, reader):
        """setReplier(TypedReaderImageFloat self, PortReader reader)"""
        return _yarp.TypedReaderImageFloat_setReplier(self, reader)


    def acquire(self):
        """acquire(TypedReaderImageFloat self) -> void *"""
        return _yarp.TypedReaderImageFloat_acquire(self)


    def release(self, handle):
        """release(TypedReaderImageFloat self, void * handle)"""
        return _yarp.TypedReaderImageFloat_release(self, handle)


    def setTargetPeriod(self, period):
        """setTargetPeriod(TypedReaderImageFloat self, double period)"""
        return _yarp.TypedReaderImageFloat_setTargetPeriod(self, period)

TypedReaderImageFloat_swigregister = _yarp.TypedReaderImageFloat_swigregister
TypedReaderImageFloat_swigregister(TypedReaderImageFloat)

class TypedReaderCallbackImageFloat(_object):
    """Proxy of C++ yarp::os::TypedReaderCallback<(yarp::sig::ImageOf<(yarp::sig::PixelFloat)>)> class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, TypedReaderCallbackImageFloat, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, TypedReaderCallbackImageFloat, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_TypedReaderCallbackImageFloat
    __del__ = lambda self: None

    def onRead(self, *args):
        """
        onRead(TypedReaderCallbackImageFloat self, ImageFloat datum)
        onRead(TypedReaderCallbackImageFloat self, ImageFloat datum, TypedReaderImageFloat reader)
        """
        return _yarp.TypedReaderCallbackImageFloat_onRead(self, *args)


    def __init__(self):
        """__init__(yarp::os::TypedReaderCallback<(yarp::sig::ImageOf<(yarp::sig::PixelFloat)>)> self) -> TypedReaderCallbackImageFloat"""
        this = _yarp.new_TypedReaderCallbackImageFloat()
        try:
            self.this.append(this)
        except Exception:
            self.this = this
TypedReaderCallbackImageFloat_swigregister = _yarp.TypedReaderCallbackImageFloat_swigregister
TypedReaderCallbackImageFloat_swigregister(TypedReaderCallbackImageFloat)

class BufferedPortImageFloat(Contactable, TypedReaderImageFloat, TypedReaderCallbackImageFloat):
    """Proxy of C++ yarp::os::BufferedPort<(yarp::sig::ImageOf<(yarp::sig::PixelFloat)>)> class."""

    __swig_setmethods__ = {}
    for _s in [Contactable, TypedReaderImageFloat, TypedReaderCallbackImageFloat]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, BufferedPortImageFloat, name, value)
    __swig_getmethods__ = {}
    for _s in [Contactable, TypedReaderImageFloat, TypedReaderCallbackImageFloat]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, BufferedPortImageFloat, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(yarp::os::BufferedPort<(yarp::sig::ImageOf<(yarp::sig::PixelFloat)>)> self) -> BufferedPortImageFloat
        __init__(yarp::os::BufferedPort<(yarp::sig::ImageOf<(yarp::sig::PixelFloat)>)> self, Port port) -> BufferedPortImageFloat
        """
        this = _yarp.new_BufferedPortImageFloat(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _yarp.delete_BufferedPortImageFloat
    __del__ = lambda self: None

    def addOutput(self, *args):
        """
        addOutput(BufferedPortImageFloat self, yarp::os::ConstString const & name) -> bool
        addOutput(BufferedPortImageFloat self, yarp::os::ConstString const & name, yarp::os::ConstString const & carrier) -> bool
        addOutput(BufferedPortImageFloat self, Contact contact) -> bool
        """
        return _yarp.BufferedPortImageFloat_addOutput(self, *args)


    def close(self):
        """close(BufferedPortImageFloat self)"""
        return _yarp.BufferedPortImageFloat_close(self)


    def interrupt(self):
        """interrupt(BufferedPortImageFloat self)"""
        return _yarp.BufferedPortImageFloat_interrupt(self)


    def resume(self):
        """resume(BufferedPortImageFloat self)"""
        return _yarp.BufferedPortImageFloat_resume(self)


    def getPendingReads(self):
        """getPendingReads(BufferedPortImageFloat self) -> int"""
        return _yarp.BufferedPortImageFloat_getPendingReads(self)


    def where(self):
        """where(BufferedPortImageFloat self) -> Contact"""
        return _yarp.BufferedPortImageFloat_where(self)


    def getName(self):
        """getName(BufferedPortImageFloat self) -> yarp::os::ConstString"""
        return _yarp.BufferedPortImageFloat_getName(self)


    def prepare(self):
        """prepare(BufferedPortImageFloat self) -> ImageFloat"""
        return _yarp.BufferedPortImageFloat_prepare(self)


    def unprepare(self):
        """unprepare(BufferedPortImageFloat self) -> bool"""
        return _yarp.BufferedPortImageFloat_unprepare(self)


    def write(self, forceStrict=False):
        """
        write(BufferedPortImageFloat self, bool forceStrict=False)
        write(BufferedPortImageFloat self)
        """
        return _yarp.BufferedPortImageFloat_write(self, forceStrict)


    def writeStrict(self):
        """writeStrict(BufferedPortImageFloat self)"""
        return _yarp.BufferedPortImageFloat_writeStrict(self)


    def waitForWrite(self):
        """waitForWrite(BufferedPortImageFloat self)"""
        return _yarp.BufferedPortImageFloat_waitForWrite(self)


    def setStrict(self, strict=True):
        """
        setStrict(BufferedPortImageFloat self, bool strict=True)
        setStrict(BufferedPortImageFloat self)
        """
        return _yarp.BufferedPortImageFloat_setStrict(self, strict)


    def read(self, shouldWait=True):
        """
        read(BufferedPortImageFloat self, bool shouldWait=True) -> ImageFloat
        read(BufferedPortImageFloat self) -> ImageFloat
        """
        return _yarp.BufferedPortImageFloat_read(self, shouldWait)


    def lastRead(self):
        """lastRead(BufferedPortImageFloat self) -> ImageFloat"""
        return _yarp.BufferedPortImageFloat_lastRead(self)


    def isClosed(self):
        """isClosed(BufferedPortImageFloat self) -> bool"""
        return _yarp.BufferedPortImageFloat_isClosed(self)


    def setReplier(self, reader):
        """setReplier(BufferedPortImageFloat self, PortReader reader)"""
        return _yarp.BufferedPortImageFloat_setReplier(self, reader)


    def setReader(self, reader):
        """setReader(BufferedPortImageFloat self, PortReader reader)"""
        return _yarp.BufferedPortImageFloat_setReader(self, reader)


    def setAdminReader(self, reader):
        """setAdminReader(BufferedPortImageFloat self, PortReader reader)"""
        return _yarp.BufferedPortImageFloat_setAdminReader(self, reader)


    def onRead(self, *args):
        """
        onRead(BufferedPortImageFloat self, ImageFloat datum, TypedReaderImageFloat reader)
        onRead(BufferedPortImageFloat self, ImageFloat datum)
        """
        return _yarp.BufferedPortImageFloat_onRead(self, *args)


    def useCallback(self, *args):
        """
        useCallback(BufferedPortImageFloat self, TypedReaderCallbackImageFloat callback)
        useCallback(BufferedPortImageFloat self)
        """
        return _yarp.BufferedPortImageFloat_useCallback(self, *args)


    def disableCallback(self):
        """disableCallback(BufferedPortImageFloat self)"""
        return _yarp.BufferedPortImageFloat_disableCallback(self)


    def setEnvelope(self, envelope):
        """setEnvelope(BufferedPortImageFloat self, PortWriter envelope) -> bool"""
        return _yarp.BufferedPortImageFloat_setEnvelope(self, envelope)


    def getEnvelope(self, envelope):
        """getEnvelope(BufferedPortImageFloat self, PortReader envelope) -> bool"""
        return _yarp.BufferedPortImageFloat_getEnvelope(self, envelope)


    def getInputCount(self):
        """getInputCount(BufferedPortImageFloat self) -> int"""
        return _yarp.BufferedPortImageFloat_getInputCount(self)


    def getOutputCount(self):
        """getOutputCount(BufferedPortImageFloat self) -> int"""
        return _yarp.BufferedPortImageFloat_getOutputCount(self)


    def isWriting(self):
        """isWriting(BufferedPortImageFloat self) -> bool"""
        return _yarp.BufferedPortImageFloat_isWriting(self)


    def getReport(self, reporter):
        """getReport(BufferedPortImageFloat self, PortReport reporter)"""
        return _yarp.BufferedPortImageFloat_getReport(self, reporter)


    def setReporter(self, reporter):
        """setReporter(BufferedPortImageFloat self, PortReport reporter)"""
        return _yarp.BufferedPortImageFloat_setReporter(self, reporter)


    def resetReporter(self):
        """resetReporter(BufferedPortImageFloat self)"""
        return _yarp.BufferedPortImageFloat_resetReporter(self)


    def acquire(self):
        """acquire(BufferedPortImageFloat self) -> void *"""
        return _yarp.BufferedPortImageFloat_acquire(self)


    def release(self, handle):
        """release(BufferedPortImageFloat self, void * handle)"""
        return _yarp.BufferedPortImageFloat_release(self, handle)


    def setTargetPeriod(self, period):
        """setTargetPeriod(BufferedPortImageFloat self, double period)"""
        return _yarp.BufferedPortImageFloat_setTargetPeriod(self, period)


    def getType(self):
        """getType(BufferedPortImageFloat self) -> Type"""
        return _yarp.BufferedPortImageFloat_getType(self)


    def promiseType(self, typ):
        """promiseType(BufferedPortImageFloat self, Type const & typ)"""
        return _yarp.BufferedPortImageFloat_promiseType(self, typ)


    def setInputMode(self, expectInput):
        """setInputMode(BufferedPortImageFloat self, bool expectInput)"""
        return _yarp.BufferedPortImageFloat_setInputMode(self, expectInput)


    def setOutputMode(self, expectOutput):
        """setOutputMode(BufferedPortImageFloat self, bool expectOutput)"""
        return _yarp.BufferedPortImageFloat_setOutputMode(self, expectOutput)


    def setRpcMode(self, expectRpc):
        """setRpcMode(BufferedPortImageFloat self, bool expectRpc)"""
        return _yarp.BufferedPortImageFloat_setRpcMode(self, expectRpc)


    def acquireProperties(self, readOnly):
        """acquireProperties(BufferedPortImageFloat self, bool readOnly) -> Property"""
        return _yarp.BufferedPortImageFloat_acquireProperties(self, readOnly)


    def releaseProperties(self, prop):
        """releaseProperties(BufferedPortImageFloat self, Property prop)"""
        return _yarp.BufferedPortImageFloat_releaseProperties(self, prop)


    def includeNodeInName(self, flag):
        """includeNodeInName(BufferedPortImageFloat self, bool flag)"""
        return _yarp.BufferedPortImageFloat_includeNodeInName(self, flag)


    def setCallbackLock(self, mutex):
        """setCallbackLock(BufferedPortImageFloat self, yarp::os::Mutex * mutex) -> bool"""
        return _yarp.BufferedPortImageFloat_setCallbackLock(self, mutex)


    def removeCallbackLock(self):
        """removeCallbackLock(BufferedPortImageFloat self) -> bool"""
        return _yarp.BufferedPortImageFloat_removeCallbackLock(self)


    def lockCallback(self):
        """lockCallback(BufferedPortImageFloat self) -> bool"""
        return _yarp.BufferedPortImageFloat_lockCallback(self)


    def tryLockCallback(self):
        """tryLockCallback(BufferedPortImageFloat self) -> bool"""
        return _yarp.BufferedPortImageFloat_tryLockCallback(self)


    def unlockCallback(self):
        """unlockCallback(BufferedPortImageFloat self)"""
        return _yarp.BufferedPortImageFloat_unlockCallback(self)

BufferedPortImageFloat_swigregister = _yarp.BufferedPortImageFloat_swigregister
BufferedPortImageFloat_swigregister(BufferedPortImageFloat)

class ImageRgbFloat(Image):
    """Proxy of C++ yarp::sig::ImageOf<(yarp::sig::PixelRgbFloat)> class."""

    __swig_setmethods__ = {}
    for _s in [Image]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ImageRgbFloat, name, value)
    __swig_getmethods__ = {}
    for _s in [Image]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ImageRgbFloat, name)
    __repr__ = _swig_repr

    def __init__(self):
        """__init__(yarp::sig::ImageOf<(yarp::sig::PixelRgbFloat)> self) -> ImageRgbFloat"""
        this = _yarp.new_ImageRgbFloat()
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def getPixelSize(self):
        """getPixelSize(ImageRgbFloat self) -> int"""
        return _yarp.ImageRgbFloat_getPixelSize(self)


    def getPixelCode(self):
        """getPixelCode(ImageRgbFloat self) -> int"""
        return _yarp.ImageRgbFloat_getPixelCode(self)


    def pixel(self, x, y):
        """pixel(ImageRgbFloat self, int x, int y) -> PixelRgbFloat"""
        return _yarp.ImageRgbFloat_pixel(self, x, y)


    def access(self, x, y):
        """access(ImageRgbFloat self, int x, int y) -> PixelRgbFloat"""
        return _yarp.ImageRgbFloat_access(self, x, y)


    def safePixel(self, *args):
        """
        safePixel(ImageRgbFloat self, int x, int y) -> PixelRgbFloat
        safePixel(ImageRgbFloat self, int x, int y) -> PixelRgbFloat
        """
        return _yarp.ImageRgbFloat_safePixel(self, *args)

    __swig_destroy__ = _yarp.delete_ImageRgbFloat
    __del__ = lambda self: None
ImageRgbFloat_swigregister = _yarp.ImageRgbFloat_swigregister
ImageRgbFloat_swigregister(ImageRgbFloat)

class TypedReaderImageRgbFloat(_object):
    """Proxy of C++ yarp::os::TypedReader<(yarp::sig::ImageOf<(yarp::sig::PixelRgbFloat)>)> class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, TypedReaderImageRgbFloat, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, TypedReaderImageRgbFloat, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def setStrict(self, strict=True):
        """
        setStrict(TypedReaderImageRgbFloat self, bool strict=True)
        setStrict(TypedReaderImageRgbFloat self)
        """
        return _yarp.TypedReaderImageRgbFloat_setStrict(self, strict)


    def read(self, shouldWait=True):
        """
        read(TypedReaderImageRgbFloat self, bool shouldWait=True) -> ImageRgbFloat
        read(TypedReaderImageRgbFloat self) -> ImageRgbFloat
        """
        return _yarp.TypedReaderImageRgbFloat_read(self, shouldWait)


    def interrupt(self):
        """interrupt(TypedReaderImageRgbFloat self)"""
        return _yarp.TypedReaderImageRgbFloat_interrupt(self)


    def lastRead(self):
        """lastRead(TypedReaderImageRgbFloat self) -> ImageRgbFloat"""
        return _yarp.TypedReaderImageRgbFloat_lastRead(self)


    def isClosed(self):
        """isClosed(TypedReaderImageRgbFloat self) -> bool"""
        return _yarp.TypedReaderImageRgbFloat_isClosed(self)


    def useCallback(self, callback):
        """useCallback(TypedReaderImageRgbFloat self, TypedReaderCallbackImageRgbFloat callback)"""
        return _yarp.TypedReaderImageRgbFloat_useCallback(self, callback)


    def disableCallback(self):
        """disableCallback(TypedReaderImageRgbFloat self)"""
        return _yarp.TypedReaderImageRgbFloat_disableCallback(self)


    def getPendingReads(self):
        """getPendingReads(TypedReaderImageRgbFloat self) -> int"""
        return _yarp.TypedReaderImageRgbFloat_getPendingReads(self)

    __swig_destroy__ = _yarp.delete_TypedReaderImageRgbFloat
    __del__ = lambda self: None

    def getName(self):
        """getName(TypedReaderImageRgbFloat self) -> yarp::os::ConstString"""
        return _yarp.TypedReaderImageRgbFloat_getName(self)


    def setReplier(self, reader):
        """setReplier(TypedReaderImageRgbFloat self, PortReader reader)"""
        return _yarp.TypedReaderImageRgbFloat_setReplier(self, reader)


    def acquire(self):
        """acquire(TypedReaderImageRgbFloat self) -> void *"""
        return _yarp.TypedReaderImageRgbFloat_acquire(self)


    def release(self, handle):
        """release(TypedReaderImageRgbFloat self, void * handle)"""
        return _yarp.TypedReaderImageRgbFloat_release(self, handle)


    def setTargetPeriod(self, period):
        """setTargetPeriod(TypedReaderImageRgbFloat self, double period)"""
        return _yarp.TypedReaderImageRgbFloat_setTargetPeriod(self, period)

TypedReaderImageRgbFloat_swigregister = _yarp.TypedReaderImageRgbFloat_swigregister
TypedReaderImageRgbFloat_swigregister(TypedReaderImageRgbFloat)

class TypedReaderCallbackImageRgbFloat(_object):
    """Proxy of C++ yarp::os::TypedReaderCallback<(yarp::sig::ImageOf<(yarp::sig::PixelRgbFloat)>)> class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, TypedReaderCallbackImageRgbFloat, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, TypedReaderCallbackImageRgbFloat, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_TypedReaderCallbackImageRgbFloat
    __del__ = lambda self: None

    def onRead(self, *args):
        """
        onRead(TypedReaderCallbackImageRgbFloat self, ImageRgbFloat datum)
        onRead(TypedReaderCallbackImageRgbFloat self, ImageRgbFloat datum, TypedReaderImageRgbFloat reader)
        """
        return _yarp.TypedReaderCallbackImageRgbFloat_onRead(self, *args)


    def __init__(self):
        """__init__(yarp::os::TypedReaderCallback<(yarp::sig::ImageOf<(yarp::sig::PixelRgbFloat)>)> self) -> TypedReaderCallbackImageRgbFloat"""
        this = _yarp.new_TypedReaderCallbackImageRgbFloat()
        try:
            self.this.append(this)
        except Exception:
            self.this = this
TypedReaderCallbackImageRgbFloat_swigregister = _yarp.TypedReaderCallbackImageRgbFloat_swigregister
TypedReaderCallbackImageRgbFloat_swigregister(TypedReaderCallbackImageRgbFloat)

class BufferedPortImageRgbFloat(Contactable, TypedReaderImageRgbFloat, TypedReaderCallbackImageRgbFloat):
    """Proxy of C++ yarp::os::BufferedPort<(yarp::sig::ImageOf<(yarp::sig::PixelRgbFloat)>)> class."""

    __swig_setmethods__ = {}
    for _s in [Contactable, TypedReaderImageRgbFloat, TypedReaderCallbackImageRgbFloat]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, BufferedPortImageRgbFloat, name, value)
    __swig_getmethods__ = {}
    for _s in [Contactable, TypedReaderImageRgbFloat, TypedReaderCallbackImageRgbFloat]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, BufferedPortImageRgbFloat, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(yarp::os::BufferedPort<(yarp::sig::ImageOf<(yarp::sig::PixelRgbFloat)>)> self) -> BufferedPortImageRgbFloat
        __init__(yarp::os::BufferedPort<(yarp::sig::ImageOf<(yarp::sig::PixelRgbFloat)>)> self, Port port) -> BufferedPortImageRgbFloat
        """
        this = _yarp.new_BufferedPortImageRgbFloat(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _yarp.delete_BufferedPortImageRgbFloat
    __del__ = lambda self: None

    def addOutput(self, *args):
        """
        addOutput(BufferedPortImageRgbFloat self, yarp::os::ConstString const & name) -> bool
        addOutput(BufferedPortImageRgbFloat self, yarp::os::ConstString const & name, yarp::os::ConstString const & carrier) -> bool
        addOutput(BufferedPortImageRgbFloat self, Contact contact) -> bool
        """
        return _yarp.BufferedPortImageRgbFloat_addOutput(self, *args)


    def close(self):
        """close(BufferedPortImageRgbFloat self)"""
        return _yarp.BufferedPortImageRgbFloat_close(self)


    def interrupt(self):
        """interrupt(BufferedPortImageRgbFloat self)"""
        return _yarp.BufferedPortImageRgbFloat_interrupt(self)


    def resume(self):
        """resume(BufferedPortImageRgbFloat self)"""
        return _yarp.BufferedPortImageRgbFloat_resume(self)


    def getPendingReads(self):
        """getPendingReads(BufferedPortImageRgbFloat self) -> int"""
        return _yarp.BufferedPortImageRgbFloat_getPendingReads(self)


    def where(self):
        """where(BufferedPortImageRgbFloat self) -> Contact"""
        return _yarp.BufferedPortImageRgbFloat_where(self)


    def getName(self):
        """getName(BufferedPortImageRgbFloat self) -> yarp::os::ConstString"""
        return _yarp.BufferedPortImageRgbFloat_getName(self)


    def prepare(self):
        """prepare(BufferedPortImageRgbFloat self) -> ImageRgbFloat"""
        return _yarp.BufferedPortImageRgbFloat_prepare(self)


    def unprepare(self):
        """unprepare(BufferedPortImageRgbFloat self) -> bool"""
        return _yarp.BufferedPortImageRgbFloat_unprepare(self)


    def write(self, forceStrict=False):
        """
        write(BufferedPortImageRgbFloat self, bool forceStrict=False)
        write(BufferedPortImageRgbFloat self)
        """
        return _yarp.BufferedPortImageRgbFloat_write(self, forceStrict)


    def writeStrict(self):
        """writeStrict(BufferedPortImageRgbFloat self)"""
        return _yarp.BufferedPortImageRgbFloat_writeStrict(self)


    def waitForWrite(self):
        """waitForWrite(BufferedPortImageRgbFloat self)"""
        return _yarp.BufferedPortImageRgbFloat_waitForWrite(self)


    def setStrict(self, strict=True):
        """
        setStrict(BufferedPortImageRgbFloat self, bool strict=True)
        setStrict(BufferedPortImageRgbFloat self)
        """
        return _yarp.BufferedPortImageRgbFloat_setStrict(self, strict)


    def read(self, shouldWait=True):
        """
        read(BufferedPortImageRgbFloat self, bool shouldWait=True) -> ImageRgbFloat
        read(BufferedPortImageRgbFloat self) -> ImageRgbFloat
        """
        return _yarp.BufferedPortImageRgbFloat_read(self, shouldWait)


    def lastRead(self):
        """lastRead(BufferedPortImageRgbFloat self) -> ImageRgbFloat"""
        return _yarp.BufferedPortImageRgbFloat_lastRead(self)


    def isClosed(self):
        """isClosed(BufferedPortImageRgbFloat self) -> bool"""
        return _yarp.BufferedPortImageRgbFloat_isClosed(self)


    def setReplier(self, reader):
        """setReplier(BufferedPortImageRgbFloat self, PortReader reader)"""
        return _yarp.BufferedPortImageRgbFloat_setReplier(self, reader)


    def setReader(self, reader):
        """setReader(BufferedPortImageRgbFloat self, PortReader reader)"""
        return _yarp.BufferedPortImageRgbFloat_setReader(self, reader)


    def setAdminReader(self, reader):
        """setAdminReader(BufferedPortImageRgbFloat self, PortReader reader)"""
        return _yarp.BufferedPortImageRgbFloat_setAdminReader(self, reader)


    def onRead(self, *args):
        """
        onRead(BufferedPortImageRgbFloat self, ImageRgbFloat datum, TypedReaderImageRgbFloat reader)
        onRead(BufferedPortImageRgbFloat self, ImageRgbFloat datum)
        """
        return _yarp.BufferedPortImageRgbFloat_onRead(self, *args)


    def useCallback(self, *args):
        """
        useCallback(BufferedPortImageRgbFloat self, TypedReaderCallbackImageRgbFloat callback)
        useCallback(BufferedPortImageRgbFloat self)
        """
        return _yarp.BufferedPortImageRgbFloat_useCallback(self, *args)


    def disableCallback(self):
        """disableCallback(BufferedPortImageRgbFloat self)"""
        return _yarp.BufferedPortImageRgbFloat_disableCallback(self)


    def setEnvelope(self, envelope):
        """setEnvelope(BufferedPortImageRgbFloat self, PortWriter envelope) -> bool"""
        return _yarp.BufferedPortImageRgbFloat_setEnvelope(self, envelope)


    def getEnvelope(self, envelope):
        """getEnvelope(BufferedPortImageRgbFloat self, PortReader envelope) -> bool"""
        return _yarp.BufferedPortImageRgbFloat_getEnvelope(self, envelope)


    def getInputCount(self):
        """getInputCount(BufferedPortImageRgbFloat self) -> int"""
        return _yarp.BufferedPortImageRgbFloat_getInputCount(self)


    def getOutputCount(self):
        """getOutputCount(BufferedPortImageRgbFloat self) -> int"""
        return _yarp.BufferedPortImageRgbFloat_getOutputCount(self)


    def isWriting(self):
        """isWriting(BufferedPortImageRgbFloat self) -> bool"""
        return _yarp.BufferedPortImageRgbFloat_isWriting(self)


    def getReport(self, reporter):
        """getReport(BufferedPortImageRgbFloat self, PortReport reporter)"""
        return _yarp.BufferedPortImageRgbFloat_getReport(self, reporter)


    def setReporter(self, reporter):
        """setReporter(BufferedPortImageRgbFloat self, PortReport reporter)"""
        return _yarp.BufferedPortImageRgbFloat_setReporter(self, reporter)


    def resetReporter(self):
        """resetReporter(BufferedPortImageRgbFloat self)"""
        return _yarp.BufferedPortImageRgbFloat_resetReporter(self)


    def acquire(self):
        """acquire(BufferedPortImageRgbFloat self) -> void *"""
        return _yarp.BufferedPortImageRgbFloat_acquire(self)


    def release(self, handle):
        """release(BufferedPortImageRgbFloat self, void * handle)"""
        return _yarp.BufferedPortImageRgbFloat_release(self, handle)


    def setTargetPeriod(self, period):
        """setTargetPeriod(BufferedPortImageRgbFloat self, double period)"""
        return _yarp.BufferedPortImageRgbFloat_setTargetPeriod(self, period)


    def getType(self):
        """getType(BufferedPortImageRgbFloat self) -> Type"""
        return _yarp.BufferedPortImageRgbFloat_getType(self)


    def promiseType(self, typ):
        """promiseType(BufferedPortImageRgbFloat self, Type const & typ)"""
        return _yarp.BufferedPortImageRgbFloat_promiseType(self, typ)


    def setInputMode(self, expectInput):
        """setInputMode(BufferedPortImageRgbFloat self, bool expectInput)"""
        return _yarp.BufferedPortImageRgbFloat_setInputMode(self, expectInput)


    def setOutputMode(self, expectOutput):
        """setOutputMode(BufferedPortImageRgbFloat self, bool expectOutput)"""
        return _yarp.BufferedPortImageRgbFloat_setOutputMode(self, expectOutput)


    def setRpcMode(self, expectRpc):
        """setRpcMode(BufferedPortImageRgbFloat self, bool expectRpc)"""
        return _yarp.BufferedPortImageRgbFloat_setRpcMode(self, expectRpc)


    def acquireProperties(self, readOnly):
        """acquireProperties(BufferedPortImageRgbFloat self, bool readOnly) -> Property"""
        return _yarp.BufferedPortImageRgbFloat_acquireProperties(self, readOnly)


    def releaseProperties(self, prop):
        """releaseProperties(BufferedPortImageRgbFloat self, Property prop)"""
        return _yarp.BufferedPortImageRgbFloat_releaseProperties(self, prop)


    def includeNodeInName(self, flag):
        """includeNodeInName(BufferedPortImageRgbFloat self, bool flag)"""
        return _yarp.BufferedPortImageRgbFloat_includeNodeInName(self, flag)


    def setCallbackLock(self, mutex):
        """setCallbackLock(BufferedPortImageRgbFloat self, yarp::os::Mutex * mutex) -> bool"""
        return _yarp.BufferedPortImageRgbFloat_setCallbackLock(self, mutex)


    def removeCallbackLock(self):
        """removeCallbackLock(BufferedPortImageRgbFloat self) -> bool"""
        return _yarp.BufferedPortImageRgbFloat_removeCallbackLock(self)


    def lockCallback(self):
        """lockCallback(BufferedPortImageRgbFloat self) -> bool"""
        return _yarp.BufferedPortImageRgbFloat_lockCallback(self)


    def tryLockCallback(self):
        """tryLockCallback(BufferedPortImageRgbFloat self) -> bool"""
        return _yarp.BufferedPortImageRgbFloat_tryLockCallback(self)


    def unlockCallback(self):
        """unlockCallback(BufferedPortImageRgbFloat self)"""
        return _yarp.BufferedPortImageRgbFloat_unlockCallback(self)

BufferedPortImageRgbFloat_swigregister = _yarp.BufferedPortImageRgbFloat_swigregister
BufferedPortImageRgbFloat_swigregister(BufferedPortImageRgbFloat)

# This file is compatible with both classic and new-style classes.


